---
title: "Create the ``r params$package_name`` R package"
author: "Jacob Bien"
date: "May 27, 2022"
knit: litr::render
params:
  package_name: "litr"
  package_parent_dir: "." # <-- relative to this file's location
---

*[This file was litr-knitted using `litr` version `r utils::packageVersion("litr")`]*

The `litr` package allows one to define an R package by writing an R markdown file.  The package consists of (a) document templates that users can use as the basis for creating an R package, (b) code needed so that when such a R markdown file is knitted, it will generate not just an .html (or some other output format) but also an R package.   The code has the following components:

1. [Functionality for generating the R package when the .Rmd file is knitted.](#generating-package)  In particular, we define a `knitr` [chunk hook](https://bookdown.org/yihui/rmarkdown-cookbook/chunk-hooks.html), which we call `send_to_package()` that identifies code chunks in the .Rmd file that should be included in the package.  To make it so that this chunk hook will be active, we also have a function called `setup()` that is called at the start of `litr::render()` right before `rmarkdown::render()` is called.  The `setup()` function makes it so that when the .Rmd file is knitted, the chunk hook `send_to_package()` will be invoked on each code chunk.  It is also responsible for other preliminaries, such as defining a new `knitr` language engine that can interpret package-level documentation.

2. [Functionality for making sure the R package outputted will not overwrite a manually edited R package.](#hash)  Our approach here is to use a hash that will make it clear whether something has been modified.

3. [Wrapper to `devtools::document()`](#document)  The reason we write a wrapper for `devtools::document()` is because we want it to behave slightly differently.  In particular, `devtools::document()` reminds the reader to edit the roxygen in the `R/` files, whereas in our case, we want to make sure they edit the original .Rmd file, not the `R/` files.

4. [Functionality to alter the rendering process](#rendering)  The focus here is to make it so that all the special `litr` functionality will be active when the .Rmd is rendered.  We implement two ways this can happen.  First, we have several custom [output formats](https://bookdown.org/yihui/rmarkdown/new-formats.html), such as `litr_html_document()`.  When `rmarkdown::render()` is called with one of these `litr` output formats, `setup()` gets called before knitting occurs and some other litr-specific post-processing occurs as well.  The second way is through the function `litr::render()`.  If a user calls `litr::render()` with a non-`litr` output format, e.g. `rmarkdown::html_document()`, then `setup()` gets called before `rmarkdown::render()` and also post-processing can again happen.  Another thing of note about `litr::render()` is that it renders the document in a fresh environment, which ensures identical behavior to when a user presses "Knit" in RStudio.

## Package setup

We start by specifying the information needed in the DESCRIPTION file of the R package. We mostly follow [the R Packages book](https://r-pkgs.org/lifecycle.html#sec-release-version)'s description of version numbering.  Releases 0.0.1, 0.0.2, and 0.0.3 should really have been 0.1.0, 0.2.0, and 0.3.0, because these were not just patches.  Rather, each added quite substantial new functionality.  For this reason, we have gone straight from 0.0.3 to 0.4.0.   We will keep the leftmost number ("major release") at 0 until we feel like the package is complete with all the intended features.

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.8.0",
    Title = "Literate Programming for Writing R Packages",
    Description = "Allows one to fully create an R package in a single .Rmd 
    file.  Includes functionality and .Rmd templates for a literate programming
    approach to R package development.",
    `Authors@R` = c(
      person("Jacob", "Bien", email = "jbien@usc.edu", role = c("aut", "cre")),
      person("Patrick Vossler", role = "aut")
      )
   )
 )

usethis::use_mit_license(copyright_holder = "J. Bien")
```

Let's add some package-level documentation.  This is what will show up when someone types `package?litr` in the console.

```{package_doc}
#' Literate Programming for Writing R Packages
#'
#' Allows one to fully create an R package in a single .Rmd file.  Includes
#' functionality and .Rmd templates for a literate programming approach to R
#' package development.
#' 
#' @examples
#' # Make a file create-rhello.Rmd based on a template
#' \dontrun{
#' rmarkdown::draft("create-rhello.Rmd", 
#'                  template = "make-an-r-package",
#'                  package = "litr",
#'                  edit = FALSE)
#' # Now call litr::render (or press Knit if in RStudio) to generate not just
#' # create-rhello.html, but also an R package called `rhello`.
#' litr::render("create-rhello.Rmd")
#' }
#' @docType package
#' @seealso \code{\link{render}}
```

## A note on circularity

Keeping track of the version of `litr` used is particularly important when using `litr` to develop `litr`.  There is a tendency to want to use the new functionality that we are creating in `create-litr.Rmd` itself as soon as we have defined it.  However, this is circular and thus must be avoided.  To see why we need to be careful, let's consider an actual example that arose when working on `litr` version `0.0.3`.  After release `v0.0.2`, one of the new features we added is a new language engine called `package_doc` that allows us to have a special kind of code block defining the package documentation.  In trying out this feature and making sure it works on `skeleton.Rmd`, we would most likely install version `0.0.3`.  Now that version `0.0.3` is installed, there will be a tendency to want to add a `package_doc` block to `create-litr.Rmd`, and it will appear to work.  However, this is circular, because we have used version `0.0.3` to create version `0.0.3`!  In particular, if we remove `litr` and re-install it from github, we will get version `0.0.2` so that when we attempt to create the package using `litr::render("create-litr.Rmd")`, we will get an error telling us that it doesn't have a language engine named `package_doc`.

The code chunk in this section is for preventing this from happening.

For more on circularity, see the section on [testing litr](#tests).

```{r}
install_version_of_litr <- utils::packageVersion("litr")
remote <- remotes::github_remote(
  repo = "jacobbien/litr-project@*release",
  subdir = "litr"
  )
version_of_latest_release <- stringr::str_remove(remote$ref, "v")
if (install_version_of_litr != version_of_latest_release)
  stop(stringr::str_glue(
    "You should be using the version of litr from the latest release (version",
    " {version_of_latest_release}),\n but you are using version",
    " {install_version_of_litr}.\n",
    "You can install the release version of litr from GitHub by running the",
    " the following command:\n",
    "remotes::install_github(repo='jacobbien/litr-project@*release', subdir = 'litr')"
  ))
```

## Now to the package itself

### Generating the R package {#generating-package}

#### Sending code chunks to the package

We start by defining a [chunk hook](https://bookdown.org/yihui/rmarkdown-cookbook/chunk-hooks.html), which is a function that runs both before and after each code chunk is run in the knitting process.  In this case, the function (called `send_to_package`) is responsible for determining whether the code chunk looks like something that should be exported to the R package.  We don't want all code sent off to our R package.  For example, sometimes we'll want to demonstrate in the Rmd file how a certain function we've just created is used by running it on an example or making a plot.  That bit of example code would not be included in the package.

We start by making sure that code is only sent to the R package once (arbitrarily we have code outputted to the package *before* and not after the chunk is run).

The function then checks if this code chunk is code that should be put into the package.  There are four specific cases it considers:

1. If the special option `send_to` is used in this code chunk, then things are very simple in that the user has explicitly told us where this code should be added.  For example, if `send_to="R/file.R"`, then the code in this chunk will be appended to `R/file.R` in the R package (and if that file doesn't yet exist, it will be created).

2. Is it a piece of code to be sent to the `R/` directory?  In particular, it checks to see if the code chunk begins with the characteristic [roxygen2](https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html) characters `#'`.  If it does, then the name of the object being documented is identified (could be a function, a dataset, an S4 object, etc.) and then we write the code chunk to the file `R/<objectname>.R`.

3. If the code chunk does not start with `#'`, then we check if it has any line starting with `test_that(` or `testthat::test_that(`.  If so, then this whole code chunk is appended to `tests/testthat/tests.R` (and this file is created the first time a test chunk is sent to the package).

4. Next, it checks if the language engine is `Rcpp`.  This occurs when the code chunk starts with `{Rcpp`, rather than the usual `{r` (or alternatively when the `engine="Rcpp"` option is used).  We then invoke `usesthis::use_rcpp()` to set things up appropriately for the use of `Rcpp` within the package.  Finally, we write the code chunk to `src/code.cpp`.  There is a common header used,

```Rcpp
#include <Rcpp.h>
using namespace Rcpp;
```

and we only want this to appear once in `code.cpp`, so we do a bit of work to remove that if it appears in the code chunk.


```{r}
#' A knitr chunk hook for writing R code and tests
#' 
#' This chunk hook detects whether a chunk is defining a function or dataset
#' to be included in the R package (looks for the `roxygen2` comment format `#' `).
#' If so, then it is written to the `R/` directory.  It also looks for chunks 
#' that have one or more lines that start with `test_that(` or 
#' `testthat::test_that(` (potentially with some leading whitespace).  These 
#' chunks are then written to the `tests` directory of the R package.
#' 
#' When the `send_to` option is used, this chunk hook instead simply writes the
#' code chunk to the file specified.
#' 
#' @param before Indicates whether this is being called before or after the 
#' chunk code is executed
#' @param options Has information from the chunk
#' @param envir Environment
#' @keywords internal
send_to_package <- function(before, options, envir) {
  msg <- do_not_edit_message(knitr::current_input(), type = "R")
  if (before == FALSE) {
    # Don't do anything after the code chunk has been executed.
    return()
  }
  package_dir <- knitr::opts_knit$get("root.dir")
  package_name <- fs::path_file(package_dir)
  if (!is.null(options$send_to)) {
    # the user has defined an option that indicates where in the package this
    # code should be written
    file <- file.path(package_dir, options$send_to)
    add_text_to_file(options$code, file, pad = TRUE, msg = msg)
    return()
  }
  if (stringr::str_detect(options$code[1], "^#' ")) {
    # starts with roxygen2, so let's assume this chunk is defining an R function
    # or dataset that belongs in the package
    non_comment <- stringr::str_subset(options$code, "^#", negate = TRUE)
    if (length(non_comment) > 0) {
      if (stringr::str_detect(non_comment[1], "<-")) {
        # a function is being defined
        objname <- stringr::str_match(non_comment[1], "^(.*)\\s*<-\\s*function")[, 2]
        objname <- stringr::str_trim(objname)
      } else if (stringr::str_detect(non_comment[1], '^".+"$')) {
        # a dataset is being documented
        objname <- stringr::str_sub(non_comment[1], start = 2, end = -2)
      } else {
        # Roxygen2 comment wasn't followed by anything recognized, so do not 
        # send this to package
        return()
      }
      file <- file.path(package_dir, "R", stringr::str_glue("{objname}.R"))
      cat(paste(c(msg, "", options$code, ""), collapse = "\n"), file = file)
    }
  }
  else if (any(stringr::str_detect(options$code,
                                   "^\\s*(testthat::)?test_that\\("))) {
    # This chunk is inferred to be a test
    test_dir <- file.path(package_dir, "tests", "testthat")
    test_file <- file.path(test_dir, "tests.R")
    if (!file.exists(test_file)) {
      # It's the first chunk with tests
      if (!dir.exists(test_dir)) usethis::use_testthat()
      cat(c(msg, ""), collapse = "\n", file = test_file)
    }
    cat(
      paste(c(options$code, "", ""), collapse = "\n"),
      file = test_file,
      append = TRUE
    )
  } else if (options$engine == "Rcpp") {
    # To add Rcpp code, we need the package documentation file to exist 
    if (!file.exists(file.path(
      package_dir,
      "R",
      paste0(package_name, "-package.R"))
      )) {
      usethis::use_package_doc(open = FALSE)
    }
    cpp_file <- file.path(package_dir, "src", "code.cpp")
    if (!file.exists(cpp_file)) {
      # set up package for Rcpp
      usethis::use_rcpp(name = "code")
      msg <- do_not_edit_message(knitr::current_input(), type = "c")
      cat(msg, file = cpp_file, append = TRUE)
    }
    # append code to code.cpp, but remove lines that are `#include <Rcpp.h>`
    # or `using namespace Rcpp;` since this already appears at top of file
    cat(paste(c(
      "",
      stringr::str_subset(
        options$code,
        r"(^#include <Rcpp.h>$|^using namespace Rcpp;$)",
        negate = TRUE),
      ""), collapse = "\n"), 
        file = cpp_file,
        append = TRUE)
  }
  return()
}
```

The above code makes use of a number of functions from the `stringr` and `usethis` packages, so we'll need to add those packages to the `Imports` section of the `DESCRIPTION` file:

```{r}
usethis::use_package("stringr")
usethis::use_package("usethis")
```

The code also calls the function `do_not_edit_message()`, which adds a line at the top of the files sent to the R package reminding the user that these are not source files to be edited but rather output of the generating .Rmd file.  There are two variations on this message.

```{r}
#' Generate do-not-edit message to put at top of file
#' 
#' @param rmd_file Name of the Rmd file to mention
#' @param type Whether this is a R/ file, man/ file, or a c file
#' @keywords internal
do_not_edit_message <- function(rmd_file, type = c("R", "man", "c")) {
  if (type[1] == "R")
    return(stringr::str_glue("# Generated from {rmd_file}: do not edit by hand"))
  else if (type[1] == "man")
    return(stringr::str_glue("% Please edit documentation in {rmd_file}."))
  else if (type[1] == "c")
    return(stringr::str_glue("// Generated from {rmd_file}: do not edit by hand"))
  else
    stop("type must be either 'R', 'man', or 'c'.")
}
```

This function will also be used with `type = "man"` by `litr::document()`.

The above also makes use of a simple helper function that inserts text into a specified location of a file (or creates that file if it doesn't exist). **Actually currently it doesn't, but we can replace `cat()` in the above with calls to `add_text_to_file()`.**

```{r}
#' Add Some Text to a File
#' 
#' The text will be added to the file at a particular line specified by
#' `location`.  The first line of `txt` will be on line `location` of the
#' modified file.  If `location` is NULL, then text is added to end of file.
#' If file does not exist, it is created and `location` is ignored (unless 
#' `req_exist` is `TRUE`, in which case an error is thrown).
#' 
#' @param txt Character vector to add to file
#' @param filename Name of file
#' @param location Specifies where text should be added. See description for more.
#' @param req_exist If TRUE, then throws an error if file doesn't exist
#' @param pad If TRUE, then when text is being added to a preexisting file, it adds a newline
#' @param msg An optional message to put at top of file if this is a new file
#' @keywords internal
add_text_to_file <- function(txt, filename, location = NULL, req_exist = FALSE,
                             pad = FALSE, msg = NULL) {
  if (!file.exists(filename)) {
    if (req_exist) stop(stringr::str_glue("Cannot find file {filename}."))
    if (!is.null(msg)) txt <- c(msg, "", txt)
    writeLines(txt, con = filename)
    return()
  }
  if (pad) txt <- c("", txt)
  filetxt <- readLines(filename)
  if (is.null(location) || location == length(filetxt) + 1) {
    filetxt <- c(filetxt, txt)
  }
  else if (location > length(filetxt) + 1 | location < 1) 
    stop("Invalid location")
  else if (location == 1) {
    filetxt <- c(txt, filetxt)
  } else {
    # location is somewhere in middle
    filetxt <- c(filetxt[1:(location - 1)],
                 txt,
                 filetxt[location:length(filetxt)])
  }
  writeLines(filetxt, con = filename)
}
```

```{r}
testthat::test_that("add_text_to_file() works", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  
  # should throw error when file does not exist and req_exist is TRUE:
  myfile <- file.path(dir, "file.txt")
  sometxt <- c("hello", "there")
  testthat::expect_error(add_text_to_file(sometxt, myfile, req_exist = TRUE))

  # should create a new file where one does not exist:
  myfile <- file.path(dir, "file.txt")
  sometxt <- c("hello", "there")
  add_text_to_file(sometxt, myfile)
  testthat::expect_true(fs::file_exists(myfile))
  testthat::expect_equal(sometxt, readLines(myfile))
  
  # should append to end of file by default
  moretxt <- "world"
  add_text_to_file(moretxt, myfile)
  testthat::expect_equal(c(sometxt, moretxt), readLines(myfile))
   
  # should throw error for invalid locations:
  testthat::expect_error(add_text_to_file(sometxt, myfile, 0))
  testthat::expect_error(add_text_to_file(sometxt, myfile, -1))
  testthat::expect_error(add_text_to_file(sometxt, myfile, 5))

  # should add to specified line:
  moretxt2 <- "hi"
  add_text_to_file(moretxt2, myfile, 1)
  testthat::expect_equal(c(moretxt2, sometxt, moretxt), readLines(myfile))

  # should add to specified line:
  moretxt3 <- "hi2"
  add_text_to_file(moretxt3, myfile, 2)
  testthat::expect_equal(c(moretxt2, moretxt3, sometxt, moretxt),
                         readLines(myfile))

  # should add to specified line:
  moretxt4 <- "hi3"
  add_text_to_file(moretxt4, myfile, 6)
  testthat::expect_equal(c(moretxt2, moretxt3, sometxt, moretxt, moretxt4),
                         readLines(myfile))
  fs::dir_delete(dir)
})
```


#### Setting up the R package creation

When the user calls `litr::render()` (either in the console or by pressing "Knit" in RStudio), one of the first things that function does is to call the function `litr::setup()`, which does several things:

1. Creates a new empty directory at the specified location while first making sure that it won't overwrite something it shouldn't.  In particular, we guard against the case that the package was generated by `litr::render()` but then someone went in manually and made some changes.  Even though users should never manually edit the package that was generated by `litr::render()`, we don't want to have them inadvertently lose their work by doing so.  Thus, we only overwrite an R package if we can tell that it is the unedited output of a call to `litr::render()`.  The function `check_unedited()` is responsible for checking this, and is a pretty interesting function which we will describe in [the next section](#hash).  This part of the code also makes use of a function `litr::make_noticeable()`, which is simply a way of making error messages produced by `litr` more easy to see amid a lot of `knitr` output.

2. Adjusts the root directory from the generating .Rmd file's location to the R package's location. **Note: This behavior might not actually be desirable now that additional files will be loaded in.  It might be awkward for a user writing the generating .Rmd file to have to make everything relative to the package.  It might be convenient to provide a `litr::add_file(from, to)` function, where `from` is the path relative to the .Rmd file and `to` is the path relative to the package's location.**

3. Makes it so that the `send_to_package()` chunk hook is active for each code chunk.  This involves registering a new chunk hook using the function `knitr::knit_hooks$set()` and then setting an option with the same name to `TRUE` within each chunk.

4. Deactivates an internal function of the `usethis` package, `usethis:::challenge_nested_project()`.  This was actually a difficult issue to address that involves the intersection of `usethis`, `here`, and our particular use case.  The problem is that `usethis` was not designed for our setting in which an R package is being created programmatically.  When using `litr`, the project directory will have the generating .Rmd file and when this is knit it will create an R package within this project.  However, this leads `usethis` to prompt the user with a message of the form

> "New project '[...]' is nested inside an existing project '[...]'.  This is rarely a good idea. Do you wish to create anyway?"

But since this is encountered through knitting rather than interactively, this results in an error.  [This](https://github.com/r-lib/usethis/issues/553) `usethis` issue describes this exact problem.  The solution suggested there by jennybc involving `testthat::with_mock()` is along the lines of what we want; however, that would lead to some ugly looking code in the generating .Rmd file.  The best solution I could find was to use `utils::assignInNamespace()` as described [here](https://stat.ethz.ch/pipermail/r-help/2008-August/171215.html).  This function allows us to change the internal function `usethis:::challenge_nested_project()` so that it no longer prompts the user with concerns about nested projects.

5. Changes how [chunk references](https://bookdown.org/yihui/rmarkdown-cookbook/reuse-chunks.html) are handled. In particular, consider the following code chunk:

```
a <- 2
<<my-chunk>>
a
```

The way `knitr` handles this, the code chunk would no longer look like this but it would rather have replaced the `<<my-chunk>>` line by the code that appears in the code chunk labeled "my-chunk".  We instead would like the above code chunk to appear as written and then for the code chunk labeled "my-chunk" to have its label visible to the reader of the .html file.  This gives the coder more control over when the reader learns about different parts of the code.  It also more closely resembles Donald Knuth's form of literate programming.  For convenience, we'd like `<<my-chunk>>` to be a link that navigates to the code chunk labeled "my-chunk".  To accomplish this, we modify the `document` output hook in `setup()` (and then we also add a function called `add_chunk_label_hyperlinks()` within `render()`).

6. Define a `package_doc` engine which allows users to define package-level documentation.

```{r}
#' Code for setup chunk
#' 
#' * Creates directory where package will be. (Deletes what is currently there as 
#' long as it appears to have been created by litr and does not have any 
#' subsequent manual edits.)
#' * Sets the root directory to this directory
#' * Sets up the main chunk hook `litr::send_to_package()` that sends code to the 
#' R package directory.
#' * In the case that `minimal_eval=TRUE`, sets up an options hook for `eval` so
#'   chunks are only evaluated if there is a `usethis` or `litr::document()`
#'   command
#' * Deactivates an internal function of the `usethis` package
#' * Redefines the document output hook to handle chunk references differently  
#' * Sets up a [custom language engine](https://bookdown.org/yihui/rmarkdown-cookbook/custom-engine.html) called
#' `package_doc` that creates a package documentation file and then inserts
#' whatever the user puts in the chunk.
#' 
#' Returns the original state of the knitr objects that have been modified in 
#' setup.  This allows us to return things to the previous state after we are
#' finished.  This is relevant in the case where litr-knitting occurs in the 
#' current session and we don't want to leave things in a permanently modified
#' state.
#' 
#' @param package_dir Directory where R package will be created
<<param-minimal_eval>>
#' @keywords internal
setup <- function(package_dir, minimal_eval) {
  if (file.exists(package_dir)) {
    unedited <- tryCatch(check_unedited(package_dir),
                         error = function(e) {
                           # contents of package_dir does not resemble
                           # a litr package
                           return(FALSE)
                         })
    if (!unedited) {
      stop(make_noticeable(paste(
        stringr::str_glue("The directory {normalizePath(package_dir)}"),
        "already exists and either was not created by litr or may have manual",
        "edits. In either case, please rename that directory (or delete it)", 
        "and then try again.", 
        sep = "\n")))
    }
    unlink(package_dir, recursive = TRUE)
  }
  fs::dir_create(package_dir)
  usethis:::proj_set_(usethis:::proj_path_prep(package_dir))

  # let's keep a version of the knitr objects before modifying them:
  original_knitr <- list(opts_knit = knitr::opts_knit$get(),
                         knit_hooks = knitr::knit_hooks$get(),
                         opts_chunk = knitr::opts_chunk$get(),
                         opts_hooks = knitr::opts_hooks$get(),
                         knit_engines = knitr::knit_engines$get()
                         )
  
  knitr::opts_knit$set(root.dir = package_dir) # sets wd of future chunks
  knitr::knit_hooks$set(send_to_package = send_to_package)
  knitr::opts_chunk$set(send_to_package = TRUE)
  if (minimal_eval) {
    # only evaluate chunks that appear to include usethis commands or 
    # a call to litr::document() but if someone has specifically set eval=FALSE
    # in a particular chunk, do honor that
    usethis_exports <- getNamespaceExports("usethis")
    patterns <- paste(c("usethis::", usethis_exports, "litr::document\\("), collapse = "|")
    knitr::opts_hooks$set(eval = function(options) {
      if (options$eval)
        options$eval <- any(stringr::str_detect(options$code, patterns))
      return(options)
    })
  }
  
  
  # change usethis:::challenge_nested_project so that it will not complain
  # about creating a nested project (e.g. if this is called within a git 
  # subdirectory)
  utils::assignInNamespace("challenge_nested_project", function(...) NULL, ns = "usethis")
  # change usethis:::use_src_example_script so that it will not cause an error
  utils::assignInNamespace("use_src_example_script", 
                           function(...) {
                             usethis::use_template("code.cpp",
                                                   fs::path("src", "code.cpp"))
                           }, ns = "usethis")
  
  # define document hook to handle chunk references:
  knitr::knit_hooks$set(document = function(x) {
    # get the indices of x corresponding to code chunks
    chunk_start <- "^(\n```+[a-zA-Z0-9_]+\n)"
    idx_block <- stringr::str_which(x, chunk_start)
    original_code <- knitr::knit_code$get()
    # We first get indices of skipped chunks in original_code list
    skipped_chunks <- which(sapply(original_code, function(x){
      return(isFALSE(attr(x, "chunk_opts")$echo) || isFALSE(attr(x, "chunk_opts")$include))
    }))

    # Next we remove the indices of skipped chunks
    original_code_idx_fixed <- setdiff(seq(length(original_code)), skipped_chunks)
    
    labels <- names(original_code)
    # replace each x[i] that has code in it with the original code
    for (i in seq_along(idx_block)) {
      # break code into multiple lines:
      chunk <- strsplit(x[idx_block[i]], "\n")[[1]]
      # get the fence used (in case it's more than three ticks):
      i_start <- stringr::str_which(chunk, "^```+[a-zA-Z0-9_]+")
      fence <- stringr::str_replace(chunk[i_start[1]],
                                    "^(```+)[a-zA-Z0-9_]+", "\\1")
      i_fences <- stringr::str_which(chunk, paste0("^", fence))
      # there can be multiple code and output chunks strung together 
      # within a single x[i] if results are not held to end
      i_all_code <- c()
      for (j in seq_along(i_start)) {
        # get the elements corresponding the j-th code chunk within chunk
        i_code_end <- i_fences[which(i_fences == i_start[j]) + 1]
        i_all_code <- c(i_all_code, i_start[j]:i_code_end)
      }
      i_all_code <- setdiff(i_all_code, i_start[1])
      chunk_no_code <- chunk[-i_all_code]
      chunk <- c(chunk_no_code[1:i_start[1]],
                 original_code[original_code_idx_fixed[i]][[1]],
                 # insert the original version, accounting for skipped chunks
                 fence)
      if (i_start[1] < length(chunk_no_code))
        chunk <- c(chunk, chunk_no_code[(i_start[1] + 1):length(chunk_no_code)])
        x[idx_block[i]] <- paste(chunk, collapse = "\n")
    }
    
    # replace code chunks with the original code
    # (so we'll still have <<label>> chunk references)
    refs <- c() # labels that get referred to
    for (label in labels) {
      refs <- c(refs, find_labels(original_code[[label]])$chunk_ids)
    }
    refs <- unique(refs)
    adj_labels <- labels[!labels %in% names(skipped_chunks)]
    ref_id <- match(refs, adj_labels)
    to_insert <- paste0('###"', adj_labels[ref_id], '"###\n')
    x[idx_block[ref_id]] <- stringr::str_replace(x[idx_block[ref_id]],
                                                 chunk_start,
                                                 paste0("\\1", to_insert))
    x
  })
  
  # setup package_doc engine
  knitr::knit_engines$set(package_doc = function(options) {
    # create package_doc
    usethis::use_package_doc(open = FALSE)
    
    # insert the contents of the code chunk into the package_doc
    pkgdoc <- file.path("R", paste0(fs::path_file(package_dir), "-package.R"))
    add_text_to_file(options$code, filename = pkgdoc, location = 1)
    
    # now treat this as if it were standard R code with eval=FALSE
    r_engine <- knitr::knit_engines$get("R")
    options[["eval"]] <- FALSE
    return(r_engine(options))
  })
  return(original_knitr)
}
```

In our new `document` output hook defined above, we call a function `find_labels()`.  It takes a block of code and returns both a logical vector of which lines contained chunk labels and another vector containing the labels of those referenced chunks.  We define it here:

```{r}
#' Find a .Rmd chunk label in a code chunk
#' 
#' @param chunk_code Character vector of code from a .Rmd code chunk. Each element is a line of the code chunk.
#' @return List where chunk_idx is a logical vector for each line of the chunk corresponding to whether a chunk label of the form `<<label>>` was found and chunk_ids is a character vector of chunk label was found in that chunk.
#' @keywords internal
find_labels <- function(chunk_code) {
  rc <- knitr::all_patterns$md$ref.chunk
  chunk_idx <- any(idx = grepl(rc, chunk_code))
  chunk_ids <- stringr::str_trim(sub(rc, "\\1", chunk_code[grepl(rc, chunk_code)]))
  return(list(chunk_idx = chunk_idx, chunk_ids = chunk_ids))
}
```


The `setup()` function also uses a small function, `make_noticeable()`, which we define here:

```{r}
#' Make error messages noticeable
#' 
#' Since litr error messages are amid a lot of output from knitting, we'd like 
#' the litr ones to be eye-catching.
#' 
#' @param msg Error message
#' @keywords internal
make_noticeable <- function(msg) {
  paste("",
        "======",
        "Please read your friendly litr error message here:",
        paste("> ", msg),
        "======",
        sep = "\n")
}
```

The code in this section used the `fs` and `knitr` packages, so we import those:

```{r}
usethis::use_package("fs")
usethis::use_package("knitr")
```


### Not overwriting a manually edited R package {#hash}

As described in the previous section, the function `setup()` will only overwrite a directory if it is the unedited output from using `litr`.  The basic idea is that the function `litr::render()` when creating a new package finishes by adding a hash to the DESCRIPTION file.  (And likewise when `rmarkdown::render()` is used with a `litr` output format, as described [here]{#output-format}.) This hash is a function of everything in the package, so if anything about the package changes (any file is modified, added, or removed) then the function `check_unedited()` will be able to detect that by recomputing the hash and seeing that it doesn't match the hash in the DESCRIPTION file.

Let's start by defining the function `hash_package_directory()` that does the hashing.  The hash is a function of everything in the outputted package *except for that special line in the DESCRIPTION file with the hash*.  We use `tools::md5sum()` and `digest::digest()` to do the hashing.

```{r}
#' Hash package directory
#' 
#' Gets an identifier that can be used to uniquely (whp) identify the current 
#' state of the package. This is formed by ignoring the `LitrId` field of the
#' DESCRIPTION file, which is the location where the output of this function is 
#' stored when `litr::render` generates the package.
#' 
#' @param package_dir Path to package
#' @keywords internal
hash_package_directory <- function(package_dir) {
  pkg_files <- fs::dir_ls(package_dir, recurse = TRUE, all = TRUE, type = "file")
  pkg_files <- stringr::str_subset(pkg_files, ".DS_Store$", negate = TRUE)
  pkg_files <- normalizePath(pkg_files)
  descr_file <- normalizePath(file.path(package_dir, "DESCRIPTION"))
  i_descr <- which(pkg_files == descr_file)
  if (length(i_descr) == 0) stop("Cannot find DESCRIPTION file.")
  txt_descr <- readLines(pkg_files[i_descr])
  txt_descr_mod <- stringr::str_subset(
    txt_descr, 
    stringr::str_glue("{description_litr_hash_field_name()}: .+$"),
    negate = TRUE)
  hashes <- as.character(tools::md5sum(pkg_files[-i_descr]))
  digest::digest(c(hashes, list(txt_descr_mod)))
}
```

We used `digest`, so let's import it:

```{r}
usethis::use_package("digest")
```

We will store this hash in a special field within the DESCRIPTION file.  Let's call this field `LitrId`.  However, in case we ever decide to change the name of this field, it's better that we only define it in one place.  So we do this with the following function:

```{r}
#' Generate litr hash field name for DESCRIPTION file
#' @keywords internal
description_litr_hash_field_name <- function() return("LitrId")
```

Ok, now let's write the function that `litr::render()` will call that will take the generated R package and add a line that puts the hash in the DESCRIPTION file under that special `litr` field:

```{r}
#' Write the hash of the package to the DESCRIPTION file
#' 
#' @param package_dir Path to package
#' @keywords internal
write_hash_to_description <- function(package_dir) {
  desc_file <- file.path(package_dir, "DESCRIPTION")
  if (!file.exists(desc_file)) file.create(desc_file)
  hash <- hash_package_directory(package_dir)
  desc::desc_set(description_litr_hash_field_name(), hash, file = desc_file)
}
```

Let's include the `desc` package, which helps us manipulate DESCRIPTION files.

```{r}
usethis::use_package("desc")
```

And of course we'll need a function that can read the value of that field as well:

```{r}
#' Get the hash of the package from the DESCRIPTION file
#' 
#' @param package_dir Path to package
#' @keywords internal
read_hash_from_description <- function(package_dir) {
  descr <- file.path(package_dir, "DESCRIPTION")
  if (!file.exists(descr)) stop("Cannot find DESCRIPTION file.")
  txt <- stringr::str_subset(
    readLines(descr), 
    stringr::str_glue("{description_litr_hash_field_name()}: .+$"))
  if (length(txt) > 1) stop("More than one hash found in DESCRIPTION.")
  if (length(txt) == 0) stop("No hash found in DESCRIPTION.")
  stringr::str_extract(txt, "\\S+$")
}
```

With all this hash functionality in place, the function `check_unedited()` is actually quite simple to define:

```{r}
#' Check if package directory is the unedited output of litr::render()
#' 
#' Uses hash stored in a special `litr` field of DESCRIPTION file to check that 
#' the current state of the R package directory is identical to its state at the
#' time that it was created by `litr::render()`.
#' 
#' @param package_dir Path to package
#' @keywords internal
check_unedited <- function(package_dir) {
  hash <- hash_package_directory(package_dir)
  hash == read_hash_from_description(package_dir)
}
```

It simply computes the hash of the current package and checks whether that hash is the same as what was originally written to the DESCRIPTION file by `litr::render()`.

### Keeping track of what version of `litr` was used to create package

For the sake of reproducibility, it will be useful to record the version of `litr` used to create a package.  We will do this by adding a field to the DESCRIPTION file.

```{r}
#' Generate litr version field name for DESCRIPTION file
#' @keywords internal
description_litr_version_field_name <- function() return("LitrVersionUsed")
```

```{r}
#' Write the version of litr used to the DESCRIPTION file
#' 
#' @param package_dir Path to package
#' @keywords internal
write_version_to_description <- function(package_dir) {
  ver <- as.character(utils::packageVersion("litr"))
  add_text_to_file(
    txt = stringr::str_glue("{description_litr_version_field_name()}: {ver}"),
    filename = file.path(package_dir, "DESCRIPTION"),
    req_exist = TRUE
    )
}
```


### Wrapper to `devtools::document()` {#document}

This function is nearly identical to `devtools::document()` except that it changes the roxygen2 message that says "Please edit documentation in R/[...].R" to instead mention the generating .Rmd file.

```{r}
#' Use roxygen to document a package
#' 
#' This is a wrapper for the `devtools::document()` function, which in turn is a
#' wrapper for the `roxygen2::roxygenize()` function.  The purpose for `litr` 
#' having this wrapper is to make one modification.  In particular, the line
#' in the outputted `Rd` files should not say "Please edit documentation in 
#' R/file.R" but instead should refer to the Rmd file that generates everything. 
#' 
#' @param ... Arguments to be passed to `devtools::document()`
#' @export
document <- function(...) {
  devtools::document(...)
  # remove the line of the following form in each man/*.Rd file:
  pattern <- "% Please edit documentation in .*$"
  msg <- do_not_edit_message(knitr::current_input(), type = "man")
  for (fname in fs::dir_ls("man")) {
    txt <- stringr::str_replace(readLines(fname), pattern, msg)
    cat(paste(txt, collapse = "\n"), file = fname)
  }
}
```

We used `devtools`, so let's import it:

```{r}
usethis::use_package("devtools")
```

### Altering the rendering process {#rendering}

The focus here is to make it so that all the special `litr` functionality will be active when the .Rmd is rendered.  In particular, we need to make sure that `setup()` has been called before knitting occurs (so that, for example, `send_to_package()` will be active).  We also need to make sure that after knitting certain things occur, such as the litr-hash being written to the package and, in some cases, hyperlinks are added for easier navigation.

We implement two ways for the above to occur, which we describe in the next two subsections:

1. The first approach is by defining [custom litr output formats](#output-format).  When `rmarkdown::render()` (or `bookdown::render_book()`) is called with one of these `litr` output formats, the `litr`-specific operations occur before and after knitting.

2. The second way is through the function `litr::render()`.  If a user calls `litr::render()` with a non-`litr` output format, e.g. `rmarkdown::html_document()`, then it adds the necessary `litr`-specific operations before/after `rmarkdown::render()` is called.  Another thing of note about `litr::render()` is that it renders the document in a fresh environment, which ensures identical behavior to when a user presses "Knit" in RStudio.

Although these are presented as two separate approaches, we have written `litr::render()` so that if a user passes one of the `litr` output formats to `litr::render()`, it will still work.

We encourage users to use `litr::render()`^[For example, we include the line `knit: litr::render` in the yaml of the templates for this reason.] rather than `rmarkdown::render()` since in `litr::render()` we're able to wrap the call to `rmarkdown::render()` in the function `with_cleanup()`.  This ensures that, if an error occurs during the knitting process, the special `litr` hash will still be created.  This is desirable since it means that the next time we try to litr-knit, we will not get an error about overwriting a manually edited package directory.

When coding an R package with `litr`, sometimes there are code chunks that can take a while to evaluate (e.g., tests), which slows down the coding process.  We therefore provide an argument (to both `litr::render()` and the various litr output formats) that allows for "minimal eval" to occur.  The goal is to allow the R package to be updated completely but without any of the code chunks being evaluated, except those whose involving usethis or a call to `litr::document()`, since these commands lead to changes in the R package itself.  Here is the documentation associated with the `minimal_eval` parameter, which is an argument to a number of functions in this section:

```{r param-minimal_eval}
#' @param minimal_eval If `TRUE`, then only chunks with `litr::document()` or 
#' `usethis` commands will be evaluated.  This can be convenient in coding when 
#' you just want to quickly update the R package without having to wait for long
#' evaluations to occur.
```


#### Defining `litr` output formats {#output-format}

The function `rmarkdown::render()` allows for customizable behavior through the use of custom [output formats](https://bookdown.org/yihui/rmarkdown/new-formats.html).

Given a preexisting output format (e.g. `rmarkdown::html_document`), we would like to modify it to have `litr`-behavior -- i.e., to create a package as it is being rendered.  This next function takes a preexisting output format and "`litr`-ifies" it by making three changes:

1. It modifies the `pre_knit()` function.

2. It modifies the `post_processor()` function.

3. It adds a marker (`litr_format <- TRUE`) that will help `litr::render()` know when a `litr` output format is being passed to it.

We present the function and then describe the details of the new `pre_knit()` and `post_processor()` functions below.

```{r}
#' Modify an existing output format to have `litr` behavior
#' 
#' This function modifies the `pre_knit()` and `post_processor()` functions of a
#' preexisting output format so that it will have the `litr` behavior (meaning that an R package will be created when `rmarkdown::render()` is called).
#' 
#' @param base_format a preexisting, non-litr output format such as `rmarkdown::html_document`
<<param-minimal_eval>>
#' @export
litrify_output_format <- function(base_format = rmarkdown::html_document,
                                  minimal_eval = FALSE) {
  force(base_format) # I think using force here is advisable?
  force(minimal_eval) # https://adv-r.hadley.nz/function-factories.html
  function(...) {
    old <- base_format(...)
    new <- old
    new$original_knitr_objects <- list()
    new$pre_knit <- function(...) {
      args <- list(...)
      input <- args$input
      params <- knitr::knit_params(readLines(input))
      package_dir <- get_package_directory(
        params$package_parent_dir$value,
        params$package_name$value,
        input)
      new$original_knitr_objects <<- litr:::setup(package_dir, minimal_eval)
      if (!is.null(old$pre_knit)) old$pre_knit(...)
    }

    new$post_processor <- function(metadata, input_file, output_file, ...) {
      # typically the post_processor function returns the output file path
      # if old$post_processor is NULL, as in the case of pdf_document,
      # then R will throw an error when trying to call old$post_processor
      # if we only add a check for non null old$post_processor and otherwise
      # set out <- NULL then R will throw an error later in rmarkdown::render
      # since output_file is set to the output of the post_processor if 
      # output_format$post_processor is not null (See line 478 in rmarkdown::render)
      # Therefore, our solution is to set out to the output_file path if old$post_process is null.
      if (!is.null(old$post_processor)){
        out <- old$post_processor(metadata, input_file, output_file, ...)  
      } else {
        out <- output_file 
      }
      package_dir <- get_package_directory(
        metadata$params$package_parent_dir,
        metadata$params$package_name,
        input_file
      )
      # remove .Rproj and .gitignore if usethis::create_package() added these
      remove_rstudio_extras(package_dir)

      # add to DESCRIPTION file the version of litr used to create package:
      write_version_to_description(package_dir)

      # add litr hash so we can tell later if package files were manually edited:
      write_hash_to_description(package_dir)
      
      out
    }
    
    new$on_exit <- function() {
      old$on_exit()
      
      # restore knitr to its original state
      restore_knitr_objects(new$original_knitr_objects)
    }
    
    # mark this as a litr_format
    new$litr_format <- TRUE
    
    # litr formats have minimal_eval as an option
    new$minimal_eval <- minimal_eval

    new
  }
}
```

1. The `pre_knit()` function is modified so that `setup()` is called before the preexisting output format's `pre_knit()` function is called.  As the name suggests, this is a function that gets called before knitting.  The purpose of the call to `setup()` is to create the R package directory and make it so that when we knit the file using `rmarkdown::render()`, a lot of special things will happen, such as code being sent to the R package directory. The function `setup()` returns the state of the `knitr` settings before any changes were made.  This previous state of the knitr settings will be restored at the end of the rendering process in `on_exit()`.

2. The `post_processor()` function is modified so that the DESCRIPTION file gets marked with the version of `litr` used and with the `litr` hash (as already described [here](#hash)).  Some special care is taken for the case that the original output format doesn't have a post processor (e.g., this is the case for the `pdf_document` output format).  The particulars of this are given in a comment in the code chunk above.

3. The `on_exit()` function is modified so that it restores the state of all the knitr settings to how it was when render was first called.

We use the above function to create some `litr` versions of common output formats, as seen in the next few subsections.

Before proceeding, we did make use of a small function for getting the package directory based on the input file's location and the parameters that are being used in the rendering process.  We define it here:

```{r}
#' Get package directory
#' 
#' @param package_parent_dir The directory of where the package should go (relative to the input directory)
#' @param package_name The name of the package
#' @param input The file name of the input
#' @keywords internal
get_package_directory <- function(package_parent_dir, package_name, input) {
  if (package_parent_dir == ".")
    return(file.path(dirname(input), package_name))
  file.path(dirname(input), package_parent_dir, package_name)
}
```

Let's write some tests to make sure it's behaving as expected:

```{r}
testthat::test_that("get_package_directory() works", {
  input <- file.path("inputdir", "input.Rmd")
  testthat::expect_equal(
    get_package_directory(".", "mypkg", input),
    file.path("inputdir", "mypkg") # inputdir/mypkg
  )
  testthat::expect_equal(
    get_package_directory("..", "mypkg", input),
    file.path("inputdir", "..", "mypkg") # inputdir/../mypkg
  )
})
```


##### .pdf output format {#pdf-output-format}

We want our .pdf documents to accurately display the "logging" output from functions in packages such as `devtools` that use special [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) for displaying information in the terminal. Unfortunately, these codes use escape characters which cause problems when creating .pdf versions of our documents. While it is relatively straightforward to map ANSI escape codes to HTML tags, as we will see in the [.html output format section](#html-output-format), converting these escape codes to Latex commands is more complicated. As a result, we define a `post_knit` function in our `litr_pdf_document` format to avoid this issue by stripping out all escape codes in the file before it is converted into a .tex file and then compiled into a .pdf document.

Specifically, the `post_knit` function modifies the intermediate .knit.md file, which contains both the .Rmd file, as well as the output of each code chunk. Thus, we can inspect the output text of each code chunk and remove any ANSI escape codes before the .knit.md is converted to a .tex file and then a .pdf document. We rely upon two internal functions from the `fansi` R package to remove all possible escape codes and return a clean character vector.

```{r}
#' litr version of `rmarkdown::pdf_document()`
#' 
#' This behaves exactly like `rmarkdown::pdf_document()` except it creates an 
#' R package.
#' 
<<param-minimal_eval>>
#' @param ... Parameters to be passed to `rmarkdown::pdf_document()` 
#' @export
litr_pdf_document <- function(minimal_eval = FALSE, ...) {
  litr_pdf_document_ <- litrify_output_format(rmarkdown::pdf_document,
                                              minimal_eval = minimal_eval)
  old <- litr_pdf_document_(...)
  new <- old

  # post_knit
  new$post_knit = function(...){
    args = list(...)
    input_filename <- args[[2]]
    knitted_filename <- fs::path_ext_set(input_filename, ".knit.md")
    knitted_output <- readLines(knitted_filename)
    cleaned_output <- sapply(1:length(knitted_output), function(i){
      test_str <- knitted_output[i]
      fansi:::VAL_IN_ENV(x=test_str, ctl="all", warn=TRUE, warn.mask=fansi:::get_warn_mangled())
      .Call(fansi:::FANSI_strip_csi, test_str, CTL.INT, WARN.INT)
    })
    writeLines(cleaned_output, knitted_filename)
  }
  new
}
```

Since the above section uses the `fansi` package for handling ANSI escape sequences, we include it in our package:

```{r}
usethis::use_package("fansi")
```


##### .html output format {#html-output-format}

For .html documents, we'd like to add a bit more in the postprocessing step.  In particular, we include some special function and chunk hyperlinking behavior described below.  The function `add_function_hyperlinks()` processes the outputted .html file(s), making it so that one can easily navigate to function definitions.  (This function is described lower in this section.)  We likewise call a function `add_chunk_label_hyperlinks()`, which makes chunk references into clickable links.  In particular, the chunk reference `<<my-chunk>>` within a code chunk would link to a chunk named "my-chunk" that begins with `###"my-chunk"###`.  The `###"my-chunk"###` line is added by a document hook defined in `setup()`.  Finally, we replace ANSI sequences with HTML tag equivalents (the need for this is explained in the [section on the .pdf output format](#pdf-output-format)).

```{r}
#' litr version of `rmarkdown::html_document()`
#' 
#' This behaves like `rmarkdown::html_document()` with a few differences:
#' - It creates an R package.
#' - It adds hyperlinks to function definitions whenever a function is used
#' elsewhere in the document.
#' - It does "Knuth-style" chunk referencing with hyperlinks.
#' 
<<param-minimal_eval>>
#' @param ... Parameters to be passed to `rmarkdown::pdf_document()` 
#' @export
litr_html_document <- function(minimal_eval = FALSE, ...) {
  litr_html_document_ <- litrify_output_format(rmarkdown::html_document,
                                               minimal_eval = minimal_eval)
  old <- litr_html_document_(...)
  new <- old
  # modify post_processor
  new$post_processor = function(metadata, input_file, output_file, ...) {
    out <- old$post_processor(metadata, input_file, output_file, ...)
    html_files <- fs::dir_ls(fs::path_dir(out), regexp = ".html$")
    # add hyperlinks within html output to make it easier to navigate:
    add_function_hyperlinks(html_files, metadata$params$package_name)
    add_chunk_label_hyperlinks(html_files)
    # replace ANSI sequences with HTML tag equivalents
    replace_ansi_sequences(html_files)
    out
  }
  new
}
```

We describe these two `add_*_hyperlinks()` functions next.

The function `add_function_hyperlinks()` looks for `foo` followed by `<- function(` and then wraps `foo` in a `span` tag with `id="foo"`; whenever `foo` is found elsewhere in the document, it calls the `insert_hrefs()` function to wrap a `a href="file.html#foo"` tag (where `file.html` is the file where `foo` is defined), so that it will be a hyperlink to `foo`'s definition.

```{r}
#' Add hyperlinks to function definitions
#' 
#' Finds functions that are defined in the html file(s) by looking for text of the 
#' form `foo <- function(` and then wraps `foo` in a `span` tag with `id="foo"` 
#' and then whenever `foo` is found it wraps a `a href="file.html#foo"` tag so 
#' that it will be a hyperlink to `foo`'s definition.
#' 
#' @param html_files Character vector of file names of html files that were created
#' from Rmd files
#' @param pkg_name Name of the package created by litr. Taken from YAML front matter
#' @keywords internal
add_function_hyperlinks <- function(html_files, pkg_name) {
  find_function_defs <- function(html_file) {
    txt <- readLines(html_file)
    start_line <- which(txt == "<body>")
    pattern1 <- '([a-zA-Z0-9_.]+)(\\s*&lt;-\\s*function)'
    pattern2 <- stringr::str_replace(pattern1,
                                     '&lt;-',
                                     '<span class="ot">&lt;-</span>')
    pattern2 <- stringr::str_replace(pattern2,
                                     'function',
                                     '<span class="cf">function</span>')
    # find functions that are defined in this file:
    function_names <- character(0)
    for (pattern in c(pattern1, pattern2)) {
      for (i in seq(start_line + 1, length(txt))) {
        fn_name <- stringr::str_match(txt[i], pattern)[, 2]
        if(is.na(fn_name)) next
        # a function was defined in this line, so put a span around it
        txt[i] <- stringr::str_replace(
          txt[i],
          pattern,
          stringr::str_glue("<span id='{fn_name}'>\\1</span>\\2")
        )
        # and keep track of it for later:
        function_names <- c(function_names, fn_name)
      }
    }
    list(function_names = function_names, txt = txt)
  }
  fdefs <- lapply(html_files, find_function_defs)
  all_function_names <- unlist(lapply(fdefs, function(lst) lst$function_names))
  # if a function is defined multiple times, then it's ambiguous where to link to
  # so let's not try linking to it (this can occur when a function is defined 
  # within a function, such as `new$post_processor()`)
  repeated <- names(which(table(all_function_names) > 1))
  all_function_names <- setdiff(all_function_names, repeated)
  if (length(all_function_names) == 0) {
    # no functions defined in package, so nothing more to be done here
    return()
  }
  num_per_file <- unlist(lapply(fdefs, 
                                function(lst) {
                                  length(setdiff(lst$function_names, repeated))
                                }))
  where_defined <- rep(fs::path_file(html_files), times = num_per_file)
  defined_functions_pattern <- paste0("(::)?",all_function_names, "\\(", collapse = "|")
  # There's also this case: <span class="fu">myfunction</span>
  defined_functions_pattern2 <- paste0(
    '<span class="fu">', all_function_names, '</span>\\(',
    collapse = "|")
  
  for (i in seq_along(html_files)) {
    # whenever one of the defined functions is named, link to its definition
    # using the format `file_where_foo_is_defined.html#foo`
    modified_txt <- insert_hrefs(fdefs[[i]]$txt, defined_functions_pattern,
                                 where_defined, all_function_names, pkg_name)
    modified_txt <- insert_hrefs(modified_txt, defined_functions_pattern2,
                                 where_defined, all_function_names, pkg_name, remove_span=TRUE)
    writeLines(modified_txt, con = html_files[i])
  }
}
```

We define next the helper function `insert_hrefs()`, which was called in the previous function.  If the function `foo()` is defined in the .Rmd file that defines a package named `pkg`, then whenever `foo()` or `pkg::foo()` appears in the .Rmd, a link will be added; however, if `other_pkg::foo()` appears, then no link will be added.

```{r}
#' Replace a function's name with a link to its definition
#' 
#' A helper function for `add_function_hyperlinks` that wraps references to a 
#' function in an anchor tag with a link to the function's definition.
#' 
#' @param txt Character vector where each element is a row of the knitted HTML file.
#' @param function_pattern Regular Expression passed from `add_function_hyperlinks` that contains all referenced functions in the document.
#' @param where_defined Character vector that contains the name of the file in which a function was defined.
#' @param all_function_names Character vector of all referenced functions in the document.
#' @param pkg_name Name of the package created by litr. Taken from YAML front matter.
#' @param remove_span Boolean argument for removing span tags. Used for minimizing code duplication.
#' @keywords internal
insert_hrefs <- function(txt, function_pattern, where_defined,
                         all_function_names, pkg_name, remove_span=FALSE){
  # filter down matches of defined_functions_pattern
  has_fn_name <- which(stringr::str_detect(txt, function_pattern))
  has_colon_prefix <- which(stringr::str_detect(txt, paste0("::", all_function_names, "\\(", collapse = "|")))
  has_only_fn_name <- setdiff(has_fn_name, has_colon_prefix)
  has_pkg_colon_prefix <- which(stringr::str_detect(txt, paste0(stringr::str_glue("{pkg_name}::"))))
  
  # define different replacement functions for colon prefix cases and regular cases
  colon_pref_replace_fn <- function(x){
    if(remove_span){
      fn_name <- stringr::str_remove(x, "</span>\\(")
      fn_name <- stringr::str_remove(fn_name, '<span class="fu">')
    } else{
      fn_name <- stringr::str_remove(x, "\\(")
    }
    fn_name <- stringr::str_remove(fn_name, stringr::str_glue('{pkg_name}::'))
    # implicitly assuming that a function is not redefined in another file
    def_file <- where_defined[all_function_names == fn_name]
    return(stringr::str_glue("{pkg_name}::<a href='{def_file}#{fn_name}'>{fn_name}</a>("))
    
  }
  regular_replace_fn <- function(x){
    if(remove_span){
      fn_name <- stringr::str_remove(x, '</span>\\(')
      fn_name <- stringr::str_remove(fn_name, '<span class="fu">')  
    } else {
      fn_name <- stringr::str_remove(x, "\\(")
    }
    # implicitly assuming that a function is not redefined in another file
    def_file <- where_defined[all_function_names == fn_name]
    stringr::str_glue("<a href='{def_file}#{fn_name}'>{fn_name}</a>(")
  }  
  
  colon_prefix_function_pattern <- paste0(stringr::str_glue("{pkg_name}::"),all_function_names, "\\(", collapse = "|")
  colon_prefix_refs <- stringr::str_replace_all(
    txt[has_pkg_colon_prefix],
    colon_prefix_function_pattern,
    colon_pref_replace_fn
  )
  
  regular_refs <- stringr::str_replace_all(
    txt[has_only_fn_name],
    function_pattern,
    regular_replace_fn
  )
  # now put back in the changed lines
  txt[has_pkg_colon_prefix] <- colon_prefix_refs
  txt[has_only_fn_name] <- regular_refs
  txt
}
```


In addition to adding hyperlinks to function definitions, we also want to add hyperlinks for chunk references of the form `<<chunk-name>>` by wrapping comments of the form `###"chunk-name"###` in a `span` tag with `id="chunk-name"`.

```{r}
#' Add hyperlinks to embedded chunks
#' 
#' Finds chunks that are referenced in the html file(s) by looking for comments
#' of the form `###"foo"###` and then wraps `foo` in a `span` tag with `id="foo"` 
#' and then whenever the chunk label `<<foo>>` is found it wraps it in a 
#' `a href="file.html#foo"` tag so that it will be a hyperlink to `foo`'s 
#' definition.
#' 
#' @param html_files Character vector of file names of html files that were created
#' from Rmd files
#' @param reference_start The delimiter used to indicate the start of a chunk label 
#' @param reference_end The delimiter used to indicate the end of a chunk label 
#' @keywords internal
add_chunk_label_hyperlinks <- function(html_files,
                                       reference_start = "&lt;&lt;",
                                       reference_end = "&gt;&gt;"){
  find_chunk_defs <- function(html_file) {
    txt <- readLines(html_file)
    start_line <- which(txt == "<body>")
    pattern <- '###&quot;([a-zA-Z0-9-_.]+)&quot;###'
    # find chunks that are defined in this file:
    chunk_names <- character(0)
    for (i in seq(start_line + 1, length(txt))) {
      chunk_name <- stringr::str_match(txt[i], pattern)[, 2]
      if(is.na(chunk_name)) next
      # a chunk was defined in this line, so put a span around it
      txt[i] <- stringr::str_replace(
        txt[i],
        pattern,
        stringr::str_glue("<span id='{chunk_name}'>###&quot;\\1&quot;###</span>")
      )
      # and keep track of it for later:
      chunk_names <- c(chunk_names, chunk_name)
    }
    list(chunk_names = chunk_names, txt = txt)
  }
  
  cdefs <- lapply(html_files, find_chunk_defs)
  all_chunk_names <- unlist(lapply(cdefs, function(lst) lst$chunk_names))
  num_per_file <- unlist(lapply(cdefs, function(lst) length(lst$chunk_names)))
  where_defined <- rep(fs::path_file(html_files), times = num_per_file)
  
  defined_chunks_pattern <- paste0(reference_start, all_chunk_names, reference_end, 
                                   collapse = "|")
  ref_start <- '<span class="sc">&lt;</span><span class="er">&lt;</span>'
  ref_start_alt <- '<span class=\"er\">&lt;&lt;</span>'
  ref_end <- '<span class="sc">&gt;</span><span class="er">&gt;</span>'
  hyphen_with_extras <- '<span class="sc">-</span>'
  all_chunk_names2 <- stringr::str_replace_all(all_chunk_names, "-", hyphen_with_extras)
  defined_chunks_pattern2 <- paste0(
    ref_start, all_chunk_names2, ref_end, collapse = "|"
    )
  defined_chunks_pattern2_alt <- paste0(
    ref_start_alt, all_chunk_names2, ref_end, collapse = "|"
    )
  defined_chunks_pattern2 <- paste(
    defined_chunks_pattern2, defined_chunks_pattern2_alt, sep = "|"
    )

  for (i in seq_along(html_files)) {
    # whenever one of these named chunks is referenced, link to its definition
    # using the format `file_where_chunk_is_defined.html#chunkname`
    txt <- stringr::str_replace_all(
      cdefs[[i]]$txt,
      defined_chunks_pattern,
      function(x) {
        cname <- stringr::str_remove_all(
          x,
          paste(reference_start, reference_end, sep = "|")
        )
        def_file <- where_defined[all_chunk_names == cname]
        stringr::str_glue(
          "<a href='{def_file}#{cname}'>{reference_start}{cname}{reference_end}</a>"
          )
      }
    )
    txt <- stringr::str_replace_all(
      txt,
      defined_chunks_pattern2,
      function(x) {
        cname <- stringr::str_remove_all(
          x,
          paste(ref_start, ref_start_alt, ref_end, sep = "|")
        )
        def_file <- where_defined[all_chunk_names2 == cname]
        cname <- stringr::str_replace_all(cname, hyphen_with_extras, "-")
        stringr::str_glue(
          "<a href='{def_file}#{cname}'>{reference_start}{cname}{reference_end}</a>"
          )
      }
    )
    
    parsed_html <- xml2::read_html(paste(txt,collapse="\n"))
    span_nodes <- xml2::xml_find_all(parsed_html, ".//span[contains(., '###')]")
    for(j in seq_along(span_nodes)){
      span_node <- span_nodes[[j]]
      span_id <- xml2::xml_attr(span_node, "id")
      span_node_path <- stringr::str_split(xml2::xml_path(span_node),"/")
      pre_path <- paste(span_node_path[[1]][1:(length(span_node_path[[1]])-2)],collapse="/")
      pre_parent <- xml2::xml_find_first(parsed_html, pre_path)
      # add parent nodes to pre_parent
      xml2::xml_add_parent(pre_parent,xml2::read_xml('<div class="custom-field"> </div>'))
      outer_div <- xml2::xml_parent(pre_parent)
      xml2::xml_add_child(outer_div, xml2::read_xml(stringr::str_glue('<h1><span id="{span_id}">{span_id}</span></h1>')),.where = 0)
      xml2::xml_add_parent(pre_parent,xml2::read_xml('<div> </div>'))
      # remove span with id in comment form last
      xml2::xml_remove(span_node)
      # remove the extra line break that is left over from removing the span
      code_node <- xml2::xml_child(pre_parent)
      changed_txt <- stringr::str_remove(paste(as.character(xml2::xml_contents(code_node)),collapse=""), "\n")
      xml2::xml_replace(code_node, xml2::read_xml(stringr::str_glue('<code>{changed_txt}</code>')))
    }
    
    # last thing is to insert an additional style node in the head with our CSS
    css_string <- ".custom-field {border: 4px solid;border-top: none;padding: 8px; padding-bottom: 0px; margin-bottom: 10px; margin-top: 10px}
.custom-field h1 {font: 16px normal;margin: -16px -8px 0;font-family:inherit;font-weight:500;line-height:1.1;color:inherit}
.custom-field h1 span {float: left;}
.custom-field h1:before {border-top: 4px solid;content: ' ';float: left;margin: 8px 2px 0 -1px;width: 12px;}
.custom-field h1:after {border-top: 4px solid;content: ' ';display: block;height: 24px;left: 2px;margin: 0 1px 0 0;overflow: hidden;position: relative;top: 8px;}"
    head_node <- xml2::xml_find_first(parsed_html, ".//head")
    xml2::xml_add_child(head_node, xml2::read_xml(stringr::str_glue("<style type='text/css'>{css_string}</style>")))
    txt <- xml2::write_html(parsed_html, html_files[i])
  }
}
```

Since we rely on the `xml2` package to add in the extra label formatting, let's  import it:
```{r}
usethis::use_package("xml2")
```



Finally, we want to replace the ANSI escape sequences used by packages such as `testthat` and `devtools` with their HTML equivalents so the output matches what we see in the terminal.

```{r}
#' Replace ANSI escape sequences with their HTML equivalents
#' 
#' Finds ANSI escape sequences and replaces them with HTML tags using the `fansi` package
#' 
#' @param html_files Character vector of file names of html files that were created
#' from Rmd files
#' @keywords internal
replace_ansi_sequences <- function(html_files) {
  for (i in seq_along(html_files)) {
    file_lines <- readLines(html_files[i])
    # look for lines with escape sequences for URLs and remove the URL
    # escape sequences before we convert to HTML
    url_code_regex <- "\\033]8;;.*\\a(.*?)\\033]8;;\\a"
    url_seq_idx <- which(stringr::str_detect(file_lines, url_code_regex))
    file_lines[url_seq_idx] <- sapply(url_seq_idx, function(idx){
      line <- file_lines[idx]
      stringr::str_replace(line, url_code_regex, stringr::str_glue("\\1"))  
    })
    
    txt <-
      fansi::sgr_to_html(x = file_lines,
                         warn = FALSE,
                         term.cap = "256")
    writeLines(txt, con = html_files[i])
  }
}
```


##### bookdown output format

It turns out that our modification to the `bookdown::gitbook()` format's postprocessor is identical to the above.  This suggests that we should probably reuse code more effectively.  But for now I will leave it how it is:

```{r}
#' litr version of `bookdown::gitbook()`
#' 
#' This behaves like `bookdown::gitbook()` with a few differences:
#' - It creates an R package.
#' - It adds hyperlinks to function definitions whenever a function is used
#' elsewhere in the document.
#' - It does "Knuth-style" chunk referencing with hyperlinks.
#' 
<<param-minimal_eval>>
#' @param ... Parameters to be passed to `bookdown::gitbook()` 
#' @export
litr_gitbook <- function(minimal_eval = FALSE, ...) {
  litr_gitbook_ <- litrify_output_format(bookdown::gitbook,
                                         minimal_eval = minimal_eval)
  old <- litr_gitbook_(...)
  new <- old
  # modify post_processor
  new$post_processor = function(metadata, input_file, output_file, ...) {
    out <- old$post_processor(metadata, input_file, output_file, ...)
    html_files <- fs::dir_ls(fs::path_dir(out), regexp = ".html$")
    # add hyperlinks within html output to make it easier to navigate:
    add_function_hyperlinks(html_files, metadata$params$package_name)
    add_chunk_label_hyperlinks(html_files)
    # replace ANSI sequences with HTML tag equivalents
    replace_ansi_sequences(html_files)
    out
  }
  new
}
```

To use this output format, one would use `bookdown::render_book()` instead of `rmarkdown::render()`.  In particular:

```{r, eval = FALSE}
bookdown::render_book(output_format = litr::litr_gitbook())
```

The preamble in `index.Rmd` would look something like this:

```
---
title: "A `litr` Book"
author: "Your Name"
site: bookdown::bookdown_site
params:
  package_name: "frombookdown" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
documentclass: book
---
```

Or one can add to the preamble the lines

```
knit: litr::render
output: litr::litr_gitbook
```

This first line makes it so that in RStudio when you press "Knit", it calls `litr::render()`, and the second line makes it so that it will use the special litr bookdown output format.

Since the above function uses `bookdown`, we include it in our package:

```{r}
usethis::use_package("bookdown")
```


#### Defining `litr::render()` {#render}

There are two primary use cases for this function:

1. To render a .Rmd with a non-`litr` output format (e.g., `rmarkdown::html_document`) in such a way that it will generate an R package (and include the special litr-hyperlinking if .html files were created).

2. To render a .Rmd with a `litr` output format (including the `litr_gitbook()` format).

The second use case might seem unnecessary in that

```{r, eval=FALSE}
rmarkdown::render("create-pkg.Rmd", output_format = litr::litr_html_document())
```

or

```{r, eval = FALSE}
bookdown::render_book("index.Rmd", output_format = litr::litr_gitbook())
```

would do what we want.  However, a reason to still prefer `litr::render()` is that this function ensures the identical behavior to when one clicks the "Knit" in RStudio.  It does this by opening a fresh R session in which `rmarkdown::render()` (or `bookdown::render_book()`) is called.  This is based on [the description in the Rmarkdown Cookbook](https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-render.html).  Another reason to prefer `litr::render()` is that if there is an error in the rendering process, the special [litr hash](#hash) will still be written to the DESCRIPTION file.  This means that after fixing that error when one calls `litr::render()`, one will not get the error telling the user to delete the partially generated package directory.  We accomplish this with the function `with_cleanup()` defined below.

In the first use case, `litr::render()` is responsible for ensuring all the special `litr` things happen (like `setup()` being called before knitting, the litr-hash being written afterwards, and hyperlinking occurs).  The details of what it does is very similar to what is described in the [output formats](#output-format) section, especially the one on the [html output format](#html-output-format).

One thing that is different is that we need a function `get_params_used()`, defined at the end of this section, that gets the actual parameters that are used so that the location of the outputted package can be found.


```{r}
#' Render R markdown file
#' 
#' Wrapper to `rmarkdown::render()` that produces an R package as output in addition to the standard output document.  It does some post-processing on the 
#' html file when that is the output.  In particular, when an html file is among
#' the outputs, it adds hyperlinks to functions defined within the file to make 
#' it easier for someone reading the code to see where different functions are
#' defined.
#' 
#' @param input The input file to be rendered (see `rmarkdown::render`)
<<param-minimal_eval>>
#' @param ... Additional parameters to pass to `rmarkdown::render`
#' @export
render <- function(input, minimal_eval, ...) {
  # call rmarkdown::render in a new environment so it behaves the same as 
  # pressing the knit button in RStudio:
  # https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-render.html
  args <- list(...)

  # let's determine if the output format being used is a litr format.
  # If it is, then we'll simply want to call rmarkdown::render() since the 
  # special litr behavior will be attained through the output format.
  litr_format <- FALSE
  bookdown_format <- FALSE
  output_format_arg <- FALSE
  if ("output_format" %in% names(args)) {
    output_format_arg <- TRUE
    if ("litr_format" %in% names(args$output_format)) {
      litr_format <- TRUE
    }
    if ("bookdown_output_format" %in% names(args$output_format)) {
      bookdown_format <- TRUE
    }
  } else {
    frontmatter <- rmarkdown::yaml_front_matter(input)
    if ("output" %in% names(frontmatter)) {
      formats <- ifelse(is.list(frontmatter$output),
                        names(frontmatter$output),
                        frontmatter$output)
      if (any(stringr::str_detect(formats, "litr::"))) {
        litr_format <- TRUE
      }
      if (any(stringr::str_detect(formats, "litr::litr_gitbook"))) {
        bookdown_format <- TRUE
      }
    }
  }

  # get package_directory
  params <- get_params_used(input, args$params)
  package_dir <- get_package_directory(
    params$package_parent_dir,
    params$package_name,
    input
    )
  
  # if minimal_eval was passed to render, add this to the output_options
  # argument that will be passed to rmarkdown::render
  if (is.null(args$output_options)) args$output_options <- list()
  if (!missing(minimal_eval)) args$output_options$minimal_eval <- minimal_eval
  
  if (litr_format) {
    # this uses a litr output format, so we don't need to do anything litr-specific
    # here because it will happen through the output format
    
    if (output_format_arg & !missing(minimal_eval)) {
      # the output format was passed through the output_format argument rather 
      # than through the metadata
      if (minimal_eval) {
        stop(make_noticeable(paste(
          "When passing a litr output format using the output_format argument,",
          "you should not pass minimal_eval = TRUE directly to render.",
          "Instead, pass it to the litr output format function.  For example,",
          "litr::litr_html_document(minimal_eval = TRUE).",
          collapse = " "
          )))
      }
    }
    
    if (bookdown_format) {
      if (fs::is_file(input)) input <- fs::path_dir(input)
      return(invisible(xfun::Rscript_call(with_cleanup(bookdown::render_book,
                                                       package_dir),
                                          c(input = input, args))))
    }
    else
      return(invisible(xfun::Rscript_call(with_cleanup(rmarkdown::render,
                                                       package_dir),
                                          c(input = input, args))))
  }
  
  # the output format being used is not a litr-specific one, so we need to make
  # sure that all the special litr things happen
  args$package_dir <- package_dir

  render_ <- function(input, package_dir, minimal_eval, ...) {
    knitr_objects <- litr:::setup(package_dir, minimal_eval)
    out <- rmarkdown::render(input, ...)
    restore_knitr_objects(knitr_objects)
    # remove .Rproj and .gitignore if usethis::create_package() added these
    remove_rstudio_extras(package_dir)
    return(out)
  }

  if (missing(minimal_eval)) minimal_eval <- FALSE
  out <- xfun::Rscript_call(with_cleanup(render_, package_dir),
                            c(input = input, minimal_eval = minimal_eval, args))


  # add hyperlinks within html output to make it easier to navigate:
  if (any(stringr::str_detect(out, "html$"))) {
    html_file <- stringr::str_subset(out, "html$")
    add_function_hyperlinks(html_file, params$package_name)
    add_chunk_label_hyperlinks(html_file)
  }
  
  # add to DESCRIPTION file the version of litr used to create package:
  write_version_to_description(package_dir)
  
  # add litr hash so we can tell later if package files were manually edited:
  write_hash_to_description(package_dir)
}
```

We used the package `xfun`, so let's import it:

```{r}
usethis::use_package("xfun")
```

When `litr::render()` encounters an error, it can leave the output directory partially modified.  We want to make sure the `litr` hash still gets written to the DESCRIPTION file.  Otherwise, the next time one calls `litr::render()` it does not allow this directory to be overwritten.  We do this by using `withCallingHandlers()`.  This function, explained [here](http://adv-r.had.co.nz/Exceptions-Debugging.html), is similar to `tryCatch()`, but with the advantage that it lets the function to continue to run normally, meaning that we will still get the error message as it would appear if we hadn't done the condition handling.

```{r}
#' Add litr hash to DESCRIPTION file if error encountered
#' 
#' This creates a function that calls the passed function within the context of
#' a try-catch.  If an error is encountered, the litr hash is still added to
#' the DESCRIPTION file so that future calls to `litr::render()` will recognize
#' that it can safely overwrite the package directory (i.e., no manual editing
#' occurred).
#' 
#' @param fun function being called
#' @param package_dir directory where package is being written to
#' @param ... arguments to be passed to `fun`
#' @keywords internal
with_cleanup <- function(fun, package_dir) {
  return(function(...) {
    withCallingHandlers(
      fun(...),
      error = function(e) {
        # add litr hash so we can tell later if package files were manually edited:
        write_hash_to_description(package_dir)
      })
  })
}
```

In `setup()`, we modified the knitr objects (e.g., adding hooks, engines, etc.).  We call the function `restore_knitr_objects()` after we're done, to put things back how they were:

```{r}
#' Return the knitr objects to their original state
#' 
#' @param original_knitr_objects As returned by `setup()`
#' @keywords internal
restore_knitr_objects <- function(original_knitr_objects) {
  knitr::opts_knit$restore(original_knitr_objects$opts_knit)
  knitr::knit_hooks$restore(original_knitr_objects$knit_hooks)
  knitr::opts_chunk$restore(original_knitr_objects$opts_chunk)
  knitr::opts_hooks$restore(original_knitr_objects$opts_hooks)
  knitr::knit_engines$restore(original_knitr_objects$knit_engines)
}
```

Another thing we want to do at the end of the rendering process is to remove two files that might have been created by usethis: .Rproj and .gitignore.  These are created by `usethis::create_package()` when `rstudio = TRUE`.  We don't want these files created since this would suggest to a user that the R package should be worked on from within it rather than from the generating .Rmd file.

```{r}
#' Remove extra files added by usethis
#' 
#' Remove .Rproj and .gitignore files if they are in the package directory.
#' 
#' @param package_dir Path to package
#' @keywords internal
remove_rstudio_extras <- function(package_dir) {
  extras <- fs::dir_ls(package_dir,
                       all = TRUE,
                       regexp = "[.]Rproj$|[.]gitignore$")
  rbuildignore <- file.path(package_dir, ".Rbuildignore")
  txt <- readLines(rbuildignore)
  txt <- stringr::str_subset(txt, "^.*Rproj.*$", negate = TRUE)
  writeLines(txt, con = rbuildignore)
  for (extra in extras) fs::file_delete(extra)
}
```



As described earlier, the function `get_params_used()` combines the parameters from the YAML but allows for those values to be overridden through arguments passed to `render()`.

```{r}
#' Get parameter values used in rendering
#' 
#' When the `params` argument of `rmarkdown::render()` is explicitly used, this
#' overrides the default that appears in `input`.
#' @param input The input file to be rendered (see `rmarkdown::render`)
#' @param passed_params The list of parameters that were passed to `render`.
#' @keywords internal
get_params_used <- function(input, passed_params) {
  params <- rmarkdown::yaml_front_matter(input)$params
  for (param in names(passed_params)) {
    params[[param]] <- passed_params[[param]]
  }
  params
}
```

We used the package `rmarkdown`, so let's import it:

```{r}
usethis::use_package("rmarkdown")
```

### Functionality to facilitate workflow

When someone is writing an R package with devtools, it is common to use `devtools::load_all()` to quickly try out the functions of an R package in the console.  We'd like to allow for a similar workflow using litr.  We define a litr function called `load_all()`, which will do the following:

1. Litr-knit the .Rmd file with `minimal_eval=TRUE` to some temporary location (since the idea of `load_all()` is to leave the .html file alone) and then delete the .html file.

2. Run `devtools::load_all()` on the output.

```{r}
#' Load complete package
#' 
#' This is a litr wrapper to `devtools::load_all()`.  It first calls
#' `litr::render()` with `minimal_eval=TRUE`, then it calls
#' `devtools::load_all()` on the generated package.
#' 
#' @param input The input file to be rendered (see `rmarkdown::render`)
#' @param output_dir By default (and in typical usage) this is NULL, meaning
#' that no .html/bookdown/.pdf will result.  However, when a directory is given,
#' the result of the litr-knitting will be saved to this location.
#' @param ... Additional parameters to be passed to `devtools::load_all()`
#' @export
load_all <- function(input, output_dir = NULL, ...) {
  no_output <- is.null(output_dir)
  if (no_output) {
    output_dir <- tempfile()
    if (fs::file_exists(output_dir)) fs::file_delete(output_dir)
    fs::dir_create(output_dir)
  }
  
  # let's copy over everything from input directory to output directory
  fs::dir_copy(fs::path_dir(input), output_dir, overwrite = TRUE)
  input_path <- fs::path_split(input)[[1]]
  moved_input <- file.path(output_dir, fs::path_file(input))
  
  # get package directory
  params <- get_params_used(moved_input, list())
  package_dir <- get_package_directory(
    params$package_parent_dir,
    params$package_name,
    moved_input
  )
  
  # but if a package directory was copied here, let's remove it before
  # calling render to avoid a potential error
  if (fs::dir_exists(package_dir)) fs::dir_delete(package_dir)
  
  litr::render(moved_input, minimal_eval = TRUE, output_dir = output_dir,
               quiet = TRUE)
  
  new_package_dir <- file.path(fs::path_dir(input), params$package_name)
  fs::dir_copy(package_dir, new_package_dir, overwrite = TRUE)
  if (no_output) fs::dir_delete(output_dir)
  
  devtools::load_all(new_package_dir)
}
```

Let's test that this works.  In particular, we'll call `load_all()` and then try to use one of the functions from the package.

```{r, eval=FALSE}
testthat::test_that('load_all() works', {
  # setup files for tests:
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  rmd_file <- file.path(dir, 'create-pkg.Rmd')
  fs::file_copy(testthat::test_path("create-pkg.Rmd"), rmd_file)
  html_file <- file.path(dir, "create-pkg.html")

  load_all(rmd_file)
  testthat::expect_equal(say_hello("Jacob"), "Hello Jacob!")
  
  fs::dir_delete(dir)
})
```


### Adding extras to an R package

When writing an R package, there are some additional items one typically wants to include, such as a README file, one or more vignettes, and a `pkgdown` site.  In this section, we define some helper functions that will be make it easy to add these "extras" to a package.

While a user could choose to generate all these items within the generating .Rmd file, for all but the simplest examples, it will probably be preferred to have these as separate source files.  These source files can live in the same directory as the generating .Rmd file or in their own directory (e.g., `source-files` lives in the same directory as `create-litr.Rmd`, which is called `litr-project`).

#### Adding a README

We define a helper function that takes an externally defined README.Rmd and puts it into the package, creates a README.md, and makes sure that these will be added to the .Rbuildignore.

```{r}
#' Add README to package
#' 
#' This function takes a README.Rmd file, copies it into the package, and then
#' renders it to a README.md file.  It also adds these two files to the
#' .Rbuildignore.
#' 
#' @param rmd_file The path to a .Rmd file.
#' @export
add_readme <- function(rmd_file) {
  usethis::use_readme_rmd(open = FALSE)
  fs::file_copy(rmd_file, new_path = "README.Rmd", overwrite = TRUE)
  out <- xfun::Rscript_call(
    rmarkdown::render,
    args = list(
      input = "README.Rmd",
      output_options = list(html_preview = "false")
    )
  )
}
```

#### Adding a hex sticker

We define a helper function that takes an externally defined hex sticker (.png file) and puts it into the package under `man/figures`.  The suggestion for storing it in this directory came from [here](https://pkgdown.r-lib.org/reference/build_home.html#images-and-figures).

```{r}
#' Add a hex sticker to package
#' 
#' In addition to calling this function, you should add to your README.Rmd something like this:
#' 
#' `# your-title <img src="man/figures/logo.png" align="right" height="139" />`
#' 
#' See [here](https://pkgdown.r-lib.org/reference/build_home.html#package-logo) 
#' for more.
#' 
#' @param hex_png_file The .png file with your package's hex sticker
#' @export
add_hex_sticker <- function(hex_png_file) {
  figures_dir <- file.path("man", "figures")
  fs::dir_create(figures_dir)
  fs::file_copy(path = hex_png_file, 
                new_path = file.path(figures_dir, "logo.png"), 
                overwrite = TRUE)
}
```

#### Adding vignettes

We next define a helper function for adding vignettes to the package.  This mimics `usethis::use_vignette()`.  We couldn't directly use that function because we want the project file to live outside of the package directory, which confuses `usethis`.

```{r}
#' Add one or more vignettes to package
#' 
#' @param rmd_files A character vector of .Rmd files, each corresponding to 
#' a vignette
#' @export
add_vignettes <- function(rmd_files) {
  fs::dir_create("vignettes")
  for (fn in rmd_files) fs::file_copy(fn, "vignettes")
  
  # update DESCRIPTION file:
  deps <- desc::desc_get_deps()$package
  if (!("knitr" %in% deps))
    desc::desc_set_dep("knitr", type = "Suggests")
  if (!("rmarkdown" %in% deps))
    desc::desc_set_dep("rmarkdown", type = "Suggests")
  out <- desc::desc_set("VignetteBuilder", "knitr")
}
```

#### Add a pkgdown site

We define a function based on `usethis::use_pkgdown()`, but with a few differences:

1. Avoid the parts to do with looking for projects
2. Allow one to use a custom `_pkgdown.yml` that is stored outside of package

```{r}
#' Add a pkgdown site
#' 
#' This function creates a website for your package.  You can see it locally by
#' opening `docs/index.html` in your package.  To get it online you can copy the
#' `docs` directory to your website's server.
#' 
#' Be sure that in the generating .Rmd file this is called *after*
#' `litr::document()` has been called.  To customize the site, you may pass a
#' customized `_pkgdown.yml` file as described in [this `pkgdown` vignette](https://pkgdown.r-lib.org/articles/customise.html).
#' 
#' @param config_path The _pkgdown.yml file that lives somewhere outside of your package.  If NULL, then a basic default will be used.
#' @export
add_pkgdown <- function(config_path = NULL) {
  config_file <- "_pkgdown.yml"
  destdir <- "docs"
  usethis::use_build_ignore(c(config_file, destdir, "pkgdown"))
  if (is.null(config_path)) {
    # create a new config file (note it lives outside of package)
    config <- usethis:::pkgdown_config(destdir)
    usethis::write_over(config_file, yaml::as.yaml(config))
  } else {
    # copy the one that already exists:
    fs::file_copy(config_path, config_file)  
  }
  pkgdown::build_site()
}
```

After this step, you can locally see the site by opening `docs/index.html` in the browser.  You can then copy the `docs` directory to your website's server and you're done.

Since the above function uses `pkgdown` and `yaml`, we include these in our package:

```{r}
usethis::use_package("pkgdown")
usethis::use_package("yaml")
```


### Combining .R files

**This section should eventually be removed but for now I'm doing this to convince myself that the package generated by this .Rmd file really matches the initial version created without the package.**

```{r}
library(magrittr)
library(purrr)
rfiles <- fs::dir_ls("R")
code <- rfiles %>% 
  map(readLines) %>% 
  set_names(
    rfiles %>% stringr::str_remove("^.*/") %>% stringr::str_remove(".R$")
    )
hash_functions <- c("hash_package_directory",
                    "description_litr_hash_field_name",
                    "write_hash_to_description",
                    "read_hash_from_description",
                    "check_unedited")
render_functions <- c("render",
                      "with_cleanup",
                      "litrify_output_format",
                      "litr_pdf_document",
                      "litr_html_document",
                      "litr_gitbook",
                      "replace_ansi_sequences",
                      "add_function_hyperlinks",
                      "insert_hrefs",
                      "add_chunk_label_hyperlinks",
                      "restore_knitr_objects",
                      "remove_rstudio_extras",
                      "get_params_used",
                      "get_package_directory",
                      "do_not_edit_message",
                      "description_litr_version_field_name",
                      "write_version_to_description",
                      "document",
                      "load_all")
setup_functions <- c("setup",
                     "make_noticeable",
                     "send_to_package",
                     "add_text_to_file",
                     "find_labels")
extras_functions <- c("add_readme",
                      "add_hex_sticker",
                      "add_vignettes",
                      "add_pkgdown")
remove_initial_lines <- function(code_list) {
  # drop first line of each list element except for the first list element
  c(code_list[1], map(code_list[-1], ~ .x[-1]))
}
fs::file_delete(setdiff(rfiles, "R/litr-package.R"))
writeLines(unlist(remove_initial_lines(code[hash_functions])), "R/hash.R")
writeLines(unlist(remove_initial_lines(code[render_functions])), "R/render.R")
writeLines(unlist(remove_initial_lines(code[setup_functions])), "R/setup.R")
writeLines(unlist(remove_initial_lines(code[extras_functions])), "R/extras.R")
```


## Including templates

We now add the .Rmd templates to the package.  We have the `skeleton.Rmd` defined in `source-files`.  Note that paths are relative to the outputted package's location.

The first template is the simplest imaginable package with a single function:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package",
  template_dir = "make-an-r-package",
  template_description = "Template for an Rmd file for writing an R package using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "source-files", "make-an-r-package", "skeleton.Rmd"
    ), 
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package", "skeleton"
    ), 
  overwrite = TRUE
)
```

The second template shows how to create a package with a dataset:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package With a Dataset",
  template_dir = "make-an-r-package-with-data",
  template_description = "Template for an Rmd file for writing an R package with a dataset using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "source-files", "make-an-r-package-with-data", "skeleton.Rmd"
    ), 
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-data", "skeleton"
    ), 
  overwrite = TRUE
)
```

The third template shows how to create a package that uses `Rcpp`:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package With Rcpp",
  template_dir = "make-an-r-package-with-rcpp",
  template_description = "Template for an Rmd file for writing an R package that makes use of Rcpp while using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "source-files", "make-an-r-package-with-rcpp", "skeleton.Rmd"
    ),
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-rcpp", "skeleton"
    ),
  overwrite = TRUE
)
```

The fourth template shows how to create a package with "extras" such as a README, a vignette, and a pkgdown site:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package With a README, Vignette, and Pkgdown Site",
  template_dir = "make-an-r-package-with-extras",
  template_description = "Template for an Rmd file for writing an R package that has a README, vignette, and pkgdown site while using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "source-files", "make-an-r-package-with-extras", "skeleton.Rmd"
    ),
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-extras", "skeleton"
    ),
  overwrite = TRUE
)
fs::dir_copy(
  path = file.path(
    "..", "source-files", "make-an-r-package-with-extras", "source-files"
    ),
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-extras", "skeleton",
    "source-files"
    ),
  overwrite = TRUE
)
```

The fifth template shows how to create a package from a bookdown site, i.e. instead of having just a single `create-pkg.Rmd`, we can have a series of .Rmd files that together create a bookdown:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package From a Bookdown",
  template_dir = "make-an-r-package-from-bookdown",
  template_description = "Template for a bookdown that defines an R package using literate programming.",
  template_create_dir = TRUE
)
fs::dir_copy(
  path = file.path("..", "source-files", "make-an-r-package-from-bookdown"),
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-from-bookdown", "skeleton"
    ),
  overwrite = TRUE
)
```

## Defining some tests {#tests}

When using `litr` to create packages that are not `litr`, one should be able to run tests along the way as we did above in testing the function `add_text_to_file()`.  However, creating `litr` is a special case so we need to do something different for the tests that involve creating a .Rmd from template and then calling `litr::render()` on them (such as the tests in this section).  In particular, we use `eval=FALSE` for these code blocks and then at the end of this document we will install the newly created version of `litr` and then call `devtools::test()`.  Doing it this way is important for ensuring that the version of `litr` we are testing is the newest version, i.e. the version defined in this document.

To understand the reason we are doing it this way, imagine what would happen if instead we left `eval=TRUE` in the test in the [next section](#test-check-unedited).  When we use `rmarkdown::draft()` to create a .Rmd file from template, the file it will give us will be an old version (namely the installed version of `litr`'s template) rather than the latest version.^[If this were the only problem, we could get around this by using `pkgload::package_file()` to get the proper file; however, the next problem discussed was something that seemed quite hard to resolve.] Furthermore, consider what happens when we call `render()` in the test below.  This will start the knitting process on `my-package.Rmd`.  However, inside `my-package.Rmd`, we have `litr::setup()` and `litr::document()`.  When these are called in the knitting process, it will be the versions of the functions from the currently installed `litr` rather than the versions defined in this document.

Once we are done testing the new version of the package, we'd like to restore the state of `litr` to what it was previously.  If we don't do this, then this can lead to inadvertent circularity in which the next time we call `litr::render("create-litr.Rmd")`, we are using the version currently under development, which is bad because ultimately we need this version to be rendered by the previous version of `litr`.  The following function implements this approach to testing `litr`: 

```{r}
#' Run tests for `litr` itself
#' 
#' Special function for testing `litr`.  The trick is to temporarily install
#' the new version of `litr`, run the test, and then put things back how it was
#' before.
#' 
#' Typical values for `install_old` could be
#' - `function() devtools::install("[location of old version]")`
#' - `function() remotes::install_github("jacobbien/litr-project@*release", subdir = "litr")`.
#' 
#' @param install_old A function that when run will install the old version
#' @param location_of_new Path to the new package directory
#' @keywords internal
test_litr <- function(install_old, location_of_new) {
  devtools::unload(params$package_name)
  devtools::install(location_of_new)
  out <- devtools::test(location_of_new)
  install_old()
  return(out)
}
```

Note: The call to `devtools::unload()` is to address an issue discussed [here](https://github.com/jacobbien/litr-project/issues/30).

### Testing `check_unedited()` {#test-check-unedited}

For our tests, we create a temporary directory (which we delete at the end).  In this directory, we create a generating .Rmd file from one of the templates.  We make repeated modifications to the package and each time verify that `check_unedited()` is `FALSE` with the modification and returns to `TRUE` when we put things back how they were.  The modifications we try are the following:

- Adding a file

- Removing a file

- Making a change to a file (in particular, adding a comment to an R file)

- Changing something in the DESCRIPTION file (but not on the special `litr` line)

- Changing the `litr` hash line itself

```{r, eval=FALSE}
testthat::test_that("check_unedited works", {
  # Including this next line seems to be necessary for R CMD check on the cmd line:
  #Sys.setenv(RSTUDIO_PANDOC = "/Applications/RStudio.app/Contents/MacOS/pandoc")
  dir <- tempfile()
  fs::dir_create(dir)
  rmd_file <- file.path(dir, "my-package.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package",
                   package = "litr",
                   edit = FALSE)
  # create R package (named "rhello") from the Rmd template:
  render(rmd_file)
  package_path <- file.path(dir, "rhello")
  testthat::expect_true(check_unedited(package_path))

  # what if a file has been added?
  added_file <- file.path(package_path, "R", "say_hello2.R")
  writeLines("# Added something here.", added_file)
  testthat::expect_false(check_unedited(package_path))

  # what if we now remove it?
  fs::file_delete(added_file)
  testthat::expect_true(check_unedited(package_path))

  # what if a file is removed from package?
  rfile <- file.path(package_path, "R", "say_hello.R")
  fs::file_move(rfile, dir)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  fs::file_move(file.path(dir, "say_hello.R"), file.path(package_path, "R"))
  testthat::expect_true(check_unedited(package_path))

  # what if something is changed in a file?
  txt <- readLines(rfile)
  txt_mod <- txt
  txt_mod[3] <- paste0(txt[3], " # added a comment!!")
  writeLines(txt_mod, rfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, rfile)
  testthat::expect_true(check_unedited(package_path))

  # what if something is changed in the DESCRIPTION file?
  descfile <- file.path(package_path, "DESCRIPTION")
  txt <- readLines(descfile)
  txt_mod <- txt
  txt_mod[1] <- "Package: newname"
  writeLines(txt_mod, descfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, descfile)
  testthat::expect_true(check_unedited(package_path))

  # what if the special litr hash field is changed in the DESCRIPTION file?
  txt <- readLines(descfile)
  i_litr <- stringr::str_which(txt, description_litr_hash_field_name())
  txt_mod <- txt
  txt_mod[i_litr] <- paste0(txt_mod[i_litr], "a")
  writeLines(txt_mod, descfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, descfile)
  testthat::expect_true(check_unedited(package_path))

  fs::dir_delete(dir)
})
```

### Testing `get_params_used()`

Let's now test the `get_params_used()` function, making sure it behaves how we expect it to:

```{r, eval=FALSE}
testthat::test_that("get_params_used works", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  rmd_file <- file.path(dir, "my-package.Rmd")
  rmarkdown::draft(rmd_file, template = "make-an-r-package", package = "litr",
                   edit = FALSE)
  default_params <- get_params_used(rmd_file, passed_params = list())
  testthat::expect_equal(
    default_params,
    rmarkdown::yaml_front_matter(rmd_file)$params
  )
  params1 <- default_params
  params1$package_parent_dir <- "dir"
  testthat::expect_equal(
    get_params_used(rmd_file, passed_params = list(package_parent_dir = "dir")),
    params1
  )
  params2 <- default_params
  params2$package_name <- "pkg"
  params2$package_parent_dir <- "dir"
  testthat::expect_equal(
    get_params_used(rmd_file,
                    passed_params = list(package_parent_dir = "dir",
                                         package_name = "pkg")),
    params2
  )
  fs::dir_delete(dir)
})
```

### Testing chunk referencing

Here we test the handling of chunk references (as implemented in the document output hook set within `setup()`).  In particular, we use a .Rmd that uses chunk references in several different ways.  Within the .Rmd itself, we have tests that ensure that the code can still be run as expected.

```{r}
fs::file_copy(
  path = file.path(
    "..", "source-files", "test-example-files", "create-rknuth.Rmd"
    ), 
  new_path = file.path("tests", "testthat"), 
  overwrite = TRUE
)
```


```{r, eval=FALSE}
testthat::test_that('Knuth-style references work', {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  rmd_file <- file.path(dir, 'create-rknuth.Rmd')
  fs::file_copy(path = testthat::test_path("create-rknuth.Rmd"), new_path = rmd_file)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, 'create-rknuth.html')))
  fs::dir_delete(dir)
})
```

### Testing different ways of rendering

The mechanism by which rendering occurs depends on several factors:

a) Whether `litr::render()` or `rmarkdown::render()` is being called.

b) Whether there is a litr output format specified in the preamble of the .Rmd.

c) Whether there is a litr output format being passed an argument to the render function.

In this section, we will test that one gets the same result regardless of how rendering was invoked.^[Note: When we call `rmarkdown::render()`, we call it in a fresh, non-interactive R session.]  We will use variations on a base .Rmd file whose preamble is simply the following:

```{r, eval=FALSE}
---
title: 'A Test'
params:
  package_name: 'pkg' # <-- change this to your package name
  package_parent_dir: '.' # <-- relative to this file location
---
```

```{r}
fs::file_copy(
  path = file.path(
    "..", "source-files", "test-example-files", "create-pkg.Rmd"
    ), 
  new_path = file.path("tests", "testthat"), 
  overwrite = TRUE
)
```

There are 7 cases to consider ($2^3-1$, since we exclude the case where `rmarkdown::render()` is called and no argument or preamble would indicate that this should be a litr-knit).

```{r, eval=FALSE}
testthat::test_that('Rendering in all possible ways works', {
  
  # setup files for tests:
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  # .Rmd without output format in preamble
  rmd_file1 <- file.path(dir, 'create-pkg1.Rmd')
  fs::file_copy(testthat::test_path("create-pkg.Rmd"), rmd_file1)
  # .Rmd without output format in preamble
  rmd_file2 <- file.path(dir, 'create-pkg2.Rmd')
  fs::file_copy(rmd_file1, rmd_file2)
  litr:::add_text_to_file("output: litr::litr_html_document", rmd_file2, 3)
  # files names
  rmd_file <- file.path(dir, "create-pkg.Rmd")  
  html_file <- file.path(dir, "create-pkg.html")
  html_file_a <- file.path(dir, "a","create-pkg.html")
  pkg <- file.path(dir, "pkg")
  pkg_a <- file.path(dir, "a", "pkg")
  check_outputs_are_same <- function() {
    # html files should be the same:
    testthat::expect_equal(readLines(html_file_a), readLines(html_file))
    # packages should be the same (relying here on litr-hash in DESCRIPTION):
    testthat::expect_equal(readLines(file.path(pkg, "DESCRIPTION")),
                           readLines(file.path(pkg_a, "DESCRIPTION")))
  }

  ## Now test that all the cases give the same outputs:
  
  # Case 1: no preamble + litr::render()
  fs::file_copy(rmd_file1, rmd_file, overwrite = TRUE)
  render(rmd_file, output_file = html_file)
  if (fs::file_exists(file.path(dir, "a"))) fs::file_delete(file.path(dir, "a"))
  fs::dir_create(file.path(dir, "a"))
  fs::dir_copy(pkg, pkg_a)
  fs::dir_delete(pkg)
  fs::file_move(html_file, html_file_a)

  # Case 2: with preamble + litr::render()
  fs::file_copy(rmd_file2, rmd_file, overwrite = TRUE)
  render(rmd_file, output_file = html_file)
  check_outputs_are_same()
  
  # Case 3: no preamble + litr::render() with output format argument
  fs::file_copy(rmd_file1, rmd_file, overwrite = TRUE)
  render(rmd_file, output_format = litr::litr_html_document(),
         output_file = html_file)
  check_outputs_are_same()
  
  # Case 4: with preamble + litr::render() with output format argument
  fs::file_copy(rmd_file2, rmd_file, overwrite = TRUE)
  render(rmd_file, output_format = litr::litr_html_document(),
         output_file = html_file)
  check_outputs_are_same()

  # Case 5: with preamble + rmarkdown::render()
  fs::file_copy(rmd_file2, rmd_file, overwrite = TRUE)
  xfun::Rscript_call(rmarkdown::render,
                     list(input = rmd_file, output_file = html_file)
                     )
  check_outputs_are_same()

  # Case 6: no preamble + rmarkdown::render() with output format argument
  fs::file_copy(rmd_file1, rmd_file, overwrite = TRUE)
  xfun::Rscript_call(rmarkdown::render,
                     list(input = rmd_file,
                          output_format = litr::litr_html_document(),
                          output_file = html_file)
                     )
  check_outputs_are_same()

  # Case 7: with preamble + rmarkdown::render() with output format argument
  fs::file_copy(rmd_file2, rmd_file, overwrite = TRUE)
  xfun::Rscript_call(rmarkdown::render,
                     list(input = rmd_file,
                          output_format = litr::litr_html_document(),
                          output_file = html_file)
                     )
  check_outputs_are_same()
  
  fs::dir_delete(dir)
})
```

Let's also make sure that we get the same R package output when using `minimal_eval=TRUE` as `minimal_eval=TRUE`.

```{r, eval=FALSE}
testthat::test_that('Rendering with minimal_eval=TRUE works', {
  
  # setup files for tests:
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  rmd_file <- file.path(dir, 'create-pkg.Rmd')
  fs::file_copy(testthat::test_path("create-pkg.Rmd"), rmd_file)
  # .Rmd without output format in preamble
  html_file <- file.path(dir, "create-pkg.html")
  html_file_a <- file.path(dir, "a","create-pkg.html")
  pkg <- file.path(dir, "pkg")
  pkg_a <- file.path(dir, "a", "pkg")

  ## Now test that all the cases give the same outputs:
  
  # Case 1: minimal_eval = FALSE
  render(rmd_file, output_file = html_file, minimal_eval = FALSE)
  if (fs::file_exists(file.path(dir, "a"))) fs::file_delete(file.path(dir, "a"))
  fs::dir_create(file.path(dir, "a"))
  fs::dir_copy(pkg, pkg_a)
  fs::dir_delete(pkg)

  # Case 2: minimal_eval = TRUE passed to render
  render(rmd_file, output_file = html_file, minimal_eval = TRUE)
  testthat::expect_equal(readLines(file.path(pkg, "DESCRIPTION")),
                         readLines(file.path(pkg_a, "DESCRIPTION")))

  # Case 3: minimal_eval = TRUE passed to output format
  render(rmd_file,
         output_file = html_file,
         output_format = litr::litr_html_document(minimal_eval = TRUE)
         )
  testthat::expect_equal(readLines(file.path(pkg, "DESCRIPTION")),
                         readLines(file.path(pkg_a, "DESCRIPTION")))

  fs::dir_delete(dir)
})
```


### Testing other templates

Let's now make sure that each template can be knit without error.

```{r, eval=FALSE}
testthat::test_that("templates can be knit", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  
  rmd_file <- file.path(dir, "create-rhello.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-rhello.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "rhello")))

  rmd_file <- file.path(dir, "create-rhasdata.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package-with-data",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-rhasdata.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "rhasdata")))

  rmd_file <- file.path(dir, "create-withrcpp.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package-with-rcpp",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-withrcpp.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "withrcpp")))
  
  rmd_file <- file.path(dir, "create-withpkgdown.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package-with-extras",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-withpkgdown.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "withpkgdown")))

  rmd_file <- file.path(dir, "create-frombookdown.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package-from-bookdown",
                   package = "litr",
                   edit = FALSE)
  prev_dir <- getwd()
  setwd(file.path(dir, "create-frombookdown"))
  fs::file_delete("create-frombookdown.Rmd")
  render("index.Rmd")
  setwd(prev_dir)
  testthat::expect_true(
    fs::file_exists(file.path(dir, "create-frombookdown", "_book", "index.html"))
    )
  testthat::expect_true(
    fs::file_exists(file.path(dir, "create-frombookdown", "frombookdown"))
    )

  fs::dir_delete(dir)
 })
```

Even though `litr` doesn't directly use `Rcpp`, we'll add it as a "Suggests" package since it would be required for running the above test.

```{r}
usethis::use_package("Rcpp", type = "Suggests")
```


## Documenting the package and testing

We finish by running commands that will document and test `litr`.

**The formatting of the test output does not print out very neatly.**

We download the latest release:

```{r}
litr::document()
install_old <- function() {
  remotes::install_github("jacobbien/litr-project@*release", subdir = "litr")
}
xfun::Rscript_call(test_litr,
                   list(install_old = install_old, location_of_new = "."))
```

## Add examples folder with the output of knitting each example

In this section, we will litr-knit each template and put the outputs in an examples directory that lives outside of the `litr` R package.  These examples are linked to in `README.Rmd`.

```{r}
build_all_templates <- function(install_old, location_of_new) {
  devtools::install(location_of_new)

  example_dir <- file.path("..", "examples")
  if (fs::dir_exists(example_dir)) fs::dir_delete(example_dir)
  fs::dir_create(example_dir)
  
  templates <- fs::path_file(fs::dir_ls("inst/rmarkdown/templates"))
  templates_bookdown <- stringr::str_subset(templates, "bookdown")
  templates_nonbookdown <- setdiff(templates, templates_bookdown)
  for (template in templates_nonbookdown) {
    tmp_file <- file.path(example_dir, "temp.Rmd")
    rmarkdown::draft(tmp_file, template, package = "litr", edit = FALSE)
    pkg_name <- rmarkdown::yaml_front_matter(tmp_file)$params$package_name
    rmd_file <- file.path(example_dir, paste0("create-", pkg_name, ".Rmd"))
    fs::file_move(tmp_file, rmd_file)
    render(rmd_file)
    # move to a template-specific directory:
    template_dir <- file.path(example_dir, template)
    fs::dir_create(template_dir)
    fs::file_move(fs::dir_ls(example_dir, regexp = pkg_name), template_dir)
    # move the source-files directory
    if (fs::dir_exists(file.path(example_dir, "source-files"))) {
      fs::dir_create(file.path(example_dir, template, "source-files"))
      fs::dir_copy(file.path(example_dir, "source-files"),
                   file.path(example_dir, template))
      fs::dir_delete(file.path(example_dir, "source-files"))
    }
    # move the docs directory (when pkgdown creates one)
    if (fs::dir_exists(file.path(example_dir, "docs"))) {
      fs::dir_create(file.path(example_dir, template, "docs"))
      fs::dir_copy(file.path(example_dir, "docs"),
                   file.path(example_dir, template))
      fs::dir_delete(file.path(example_dir, "docs"))
    }
  }

  for (template in templates_bookdown) {
    tmp_dir <- file.path(example_dir, "temp")
    rmarkdown::draft(file.path(example_dir, "temp.Rmd"),
                     template,
                     package = "litr",
                     edit = FALSE)
    prev_dir <- getwd()
    setwd(tmp_dir)
    fs::file_delete("temp.Rmd")
    render("index.Rmd")
    # move to a template-specific directory:
    setwd(prev_dir)
    fs::dir_copy(tmp_dir, file.path(example_dir, template))
    fs::dir_delete(tmp_dir)
  }

  install_old()
}
```

```{r}
xfun::Rscript_call(build_all_templates,
                   list(install_old = install_old, location_of_new = "."))
```


## Including extras `litr`

### README with hex sticker

We include a `README.Rmd` and then generate the `README.md` based on it:

```{r}
add_readme(file.path("..", "source-files", "README.Rmd"))
```

Let's add the `litr` hex sticker too (which is referred to in the README).

```{r}
add_hex_sticker(file.path("..", "source-files", "litr-hex.png"))
```

Let's also add a figure we include in the README.

```{r}
fs::file_copy(file.path("..", "source-files", "diagram3.png"),
              file.path("man", "figures"))
```

### Vignettes

```{r}
add_vignettes(c(file.path("..", "source-files", "package-templates.Rmd"),
                file.path("..", "source-files", "packages-in-the-wild.Rmd"),
                file.path("..", "source-files", "faqs.Rmd"),
                file.path("..", "source-files", "basic-example.Rmd")))
```

The templates vignette uses `dplyr` and `stringr`, so we add them as "Suggests" in the DESCRIPTION file:

```{r}
usethis::use_package("dplyr", type = "Suggests")
usethis::use_package("stringr", type = "Suggests")
```



### A pkgdown site

We'll first add the github url to the DESCRIPTION file.

```{r}
usethis:::use_description_field(
  "URL",
  "https://github.com/jacobbien/litr-project/tree/main/litr"
)
```

Next, we create the pkgdown site.  The customizations come from the source file `source-files/_pkgdown.yml`.


```{r}
pkgdown_yml <- file.path("..", "source-files", "_pkgdown.yml")
add_pkgdown(pkgdown_yml)
```

We follow [this `pkgdown` vignette](https://pkgdown.r-lib.org/articles/customise.html) in our customizations.  Here is the contents of the `_pkgdown.yml` that was used:

```{r comment=''}
cat(readLines("../source-files/_pkgdown.yml"), sep = '\n')
```

After this step, you can locally see the site by opening `docs/index.html` in the browser.  You can then copy the `docs` directory to your website's server and you're done.
