---
title: "Create the ``r params$package_name`` R package"
author: "Jacob Bien"
date: "May 27, 2022"
knit: litr::render
params:
  package_name: "litr"
  package_parent_dir: "." # <-- relative to this file's location
---

*[This file was litr-knitted using `litr` version `r utils::packageVersion("litr")`]*

The `litr` package allows one to define an R package by writing an R markdown file.  The package consists of (a) document templates that users can use as the basis for creating an R package, (b) code needed so that when such a R markdown file is knitted, it will generate not just an .html but also an R package.   The code has the following components:

1. [Functionality for generating the R package when the .Rmd file is knitted.](#generating-package)  In particular, we define a `knitr` [chunk hook](https://bookdown.org/yihui/rmarkdown-cookbook/chunk-hooks.html), which we call `send_to_package()` that identifies code chunks in the .Rmd file that should be included in the package.  To make it so that this chunk hook will be active, we also have a function called `setup()` that is called at the start of `litr::render()` right before `rmarkdown::render()` is called.  The `setup()` function makes it so that when the .Rmd file is knitted, the chunk hook `send_to_package()` will be invoked on each code chunk.  It is also responsible for other preliminaries, such as defining a new `knitr` language engine that can interpret package-level documentation.

2. [Functionality for making sure the R package outputted will not overwrite a manually edited R package.](#hash)  Our approach here is to use a hash that will make it clear whether something has been modified.

3. [Wrappers to `devtools::document()` and `rmarkdown::render()`.](#wrappers)  The reason we write wrappers is because we want a few extra things to happen.  For example, `devtools::document()` reminds the reader to edit the roxygen in the `R/` files, whereas in our case, we want to make sure they edit the original .Rmd file, not the `R/` files.  Likewise, `litr::render()` sets up all the special functionality of sending code chunks to the R package before calling `rmarkdown::render()` and also adds hyperlinks to the .html file that make it easy to navigate to function definitions.

## Package setup

We start by specifying the information needed in the DESCRIPTION file of the R package.

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.4",
    Title = "Literate Programming for Writing R Packages",
    Description = "Allows one to fully create an R package in a single .Rmd 
    file.  Includes functionality and .Rmd templates for a literate programming
    approach to R package development.",
    `Authors@R` = person(
      given = "Jacob",
      family = "Bien",
      email = "jbien@usc.edu",
      role = c("aut", "cre")
      )
   )
 )

usethis::use_mit_license(copyright_holder = "J. Bien")
```

Let's add some package-level documentation.  This is what will show up when someone types `package?litr` in the console.

```{package_doc}
#' Literate Programming for Writing R Packages
#'
#' Allows one to fully create an R package in a single .Rmd file.  Includes
#' functionality and .Rmd templates for a literate programming approach to R
#' package development.
#' 
#' @examples
#' # Make a file create-rhello.Rmd based on a template
#' \dontrun{
#' rmarkdown::draft("create-rhello.Rmd", 
#'                  template = "make-an-r-package",
#'                  package = "litr",
#'                  edit = FALSE)
#' # Now call litr::render (or press Knit if in RStudio) to generate not just
#' # create-rhello.html, but also an R package called `rhello`.
#' litr::render("create-rhello.Rmd")
#' }
#' @docType package
#' @seealso \code{\link{render}}
```

## A note on circularity

Keeping track of the version of `litr` used is particularly important when using `litr` to develop `litr`.  There is a tendency to want to use the new functionality that we are creating in `create-litr.Rmd` itself as soon as we have defined it.  However, this is circular and thus must be avoided.  To see why we need to be careful, let's consider an actual example that arose when working on `litr` version `0.0.3`.  After release `v0.0.2`, one of the new features we added is a new language engine called `package_doc` that allows us to have a special kind of code block defining the package documentation.  In trying out this feature and making sure it works on `skeleton.Rmd`, we would most likely install version `0.0.3`.  Now that version `0.0.3` is installed, there will be a tendency to want to add a `package_doc` block to `create-litr.Rmd`, and it will appear to work.  However, this is circular, because we have used version `0.0.3` to create version `0.0.3`!  In particular, if we remove `litr` and re-install it from github, we will get version `0.0.2` so that when we attempt to create the package using `litr::render("create-litr.Rmd")`, we will get an error telling us that it doesn't have a language engine named `package_doc`.

The code chunk in this section is for preventing this from happening.

For more on circularity, see the section on [testing litr](#tests).

```{r}
install_version_of_litr <- utils::packageVersion("litr")
remote <- remotes::github_remote(
  repo = "jacobbien/litr-project@*release",
  subdir = "litr",
  auth_token = gitcreds::gitcreds_get(use_cache=FALSE)$password
  )
version_of_latest_release <- stringr::str_remove(remote$ref, "v")
if (install_version_of_litr != version_of_latest_release)
  stop(stringr::str_glue(
    "You should be using the version of litr from the latest release (version",
    " {version_of_latest_release}),\n but you are using version",
    " {install_version_of_litr}."
  ))
# version <- desc::desc_get_version(package_dir)
# if (install_version_of_litr == version)
#   stop(stringr::str_glue(
#     "You are attempting to create litr version {version} using itself."
#     ))
```

## Now to the package itself

### Generating the R package {#generating-package}

#### Sending code chunks to the package

We start by defining a [chunk hook](https://bookdown.org/yihui/rmarkdown-cookbook/chunk-hooks.html), which is a function that runs both before and after each code chunk is run in the knitting process.  In this case, the function (called `send_to_package`) is responsible for determining whether the code chunk looks like something that should be exported to the R package.  We don't want all code sent off to our R package.  For example, sometimes we'll want to demonstrate in the Rmd file how a certain function we've just created is used by running it on an example or making a plot.  That bit of example code would not be included in the package.

We start by making sure that code is only sent to the R package once (arbitrarily we have code outputted to the package *before* and not after the chunk is run).

The function then checks if this code chunk is code that should be put into the package.  There are three specific cases it considers:

1. Is it a piece of code to be sent to the `R/` directory?  In particular, it checks to see if the code chunk begins with the characteristic [roxygen2](https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html) characters `#'`.  If it does, then the name of the object being documented is identified (could be a function, a dataset, an S4 object, etc.) and then we write the code chunk to the file `R/<objectname>.R`.

2. If the code chunk does not start with `#'`, then we check if it has any line starting with `test_that(` or `testthat::test_that(`.  If so, then this whole code chunk is appended to `tests/testthat/tests.R` (and this file is created the first time a test chunk is sent to the package).

3. Next, it checks if the language engine is `Rcpp`.  This occurs when the code chunk starts with `{Rcpp`, rather than the usual `{r` (or alternatively when the `engine="Rcpp"` option is used).  We then invoke `usesthis::use_rcpp()` to set things up appropriately for the use of `Rcpp` within the package.  Finally, we write the code chunk to `src/code.cpp`.  There is a common header used,

```Rcpp
#include <Rcpp.h>
using namespace Rcpp;
```

and we only want this to appear once in `code.cpp`, so we do a bit of work to remove that if it appears in the code chunk.


```{r}
#' A knitr chunk hook for writing R code and tests
#' 
#' This chunk hook detects whether a chunk is defining a function or dataset
#' to be included in the R package (looks for the Roxygen2 comment format `#' `).
#' If so, then it is written to the `R/` directory.  It also looks for chunks 
#' that have one or more lines that start with `test_that(` or 
#' `testthat::test_that(` (potentially with some leading whitespace).  These 
#' chunks are then written to the `tests` directory of the R package.
#' 
#' @param before Indicates whether this is being called before or after the 
#' chunk code is executed
#' @param options Has information from the chunk
#' @param envir Environment
#' @export
send_to_package <- function(before, options, envir) {
  msg <- do_not_edit_message(knitr::current_input(), type = "R")
  if (before == FALSE) {
    # Don't do anything after the code chunk has been executed.
    return()
  }
  if (stringr::str_detect(options$code[1], "^#' ")) {
    # starts with roxygen2, so let's assume this chunk is defining an R function
    # or dataset that belongs in the package
    non_comment <- stringr::str_subset(options$code, "^#", negate = TRUE)
    if (length(non_comment) > 0) {
      if (stringr::str_detect(non_comment[1], "<-")) {
        # a function is being defined
        objname <- stringr::str_match(non_comment[1], "^(.*)\\s*<-\\s*function")[, 2]
        objname <- stringr::str_trim(objname)
      } else if (stringr::str_detect(non_comment[1], '^".+"$')) {
        # a dataset is being documented
        objname <- stringr::str_sub(non_comment[1], start = 2, end = -2)
      } else {
        # Roxygen2 comment wasn't followed by anything recognized, so do not 
        # send this to package
        return()
      }
      file <- file.path(envir$package_dir, "R", stringr::str_glue("{objname}.R"))
      cat(paste(c(msg, "", options$code, ""), collapse = "\n"), file = file)
    }
  }
  else if (any(stringr::str_detect(options$code,
                                   "^\\s*(testthat::)?test_that\\("))) {
    # This chunk is inferred to be a test
    test_dir <- file.path(envir$package_dir, "tests", "testthat")
    test_file <- file.path(test_dir, "tests.R")
    if (!file.exists(test_file)) {
      # It's the first chunk with tests
      if (!dir.exists(test_dir)) usethis::use_testthat()
      cat(c(msg, ""), collapse = "\n", file = test_file)
    }
    cat(
      paste(c(options$code, "", ""), collapse = "\n"),
      file = test_file,
      append = TRUE
    )
  } else if (options$engine == "Rcpp") {
    # To add Rcpp code, we need the package documentation file to exist 
    if (!file.exists(file.path(
      envir$package_dir,
      "R",
      paste0(envir$package_name, "-package.R"))
      )) {
      usethis::use_package_doc(open = FALSE)
    }
    cpp_file <- file.path(envir$package_dir, "src", "code.cpp")
    if (!file.exists(cpp_file)) {
      # set up package for Rcpp
      usethis::use_rcpp(name = "code")
      msg <- do_not_edit_message(knitr::current_input(), type = "c")
      cat(msg, file = cpp_file, append = TRUE)
    }
    # append code to code.cpp, but remove lines that are `#include <Rcpp.h>`
    # or `using namespace Rcpp;` since this already appears at top of file
    cat(paste(c(
      "",
      stringr::str_subset(
        options$code,
        r"(^#include <Rcpp.h>$|^using namespace Rcpp;$)",
        negate = TRUE),
      ""), collapse = "\n"), 
        file = cpp_file,
        append = TRUE)
  }
  return()
}
```

The above code makes use of a number of functions from the `stringr` and `usethis` packages, so we'll need to add those packages to the `Imports` section of the `DESCRIPTION` file:

```{r}
usethis::use_package("stringr")
usethis::use_package("usethis")
```

The code also calls the function `do_not_edit_message()`, which adds a line at the top of the files sent to the R package reminding the user that these are not source files to be edited but rather output of the generating .Rmd file.  There are two variations on this message.

```{r}
#' Generate do-not-edit message to put at top of file
#' 
#' @param rmd_file Name of the Rmd file to mention
#' @param type Whether this is a R/ file, man/ file, or a c file
do_not_edit_message <- function(rmd_file, type = c("R", "man", "c")) {
  # remove _TMP from the file name in the message
  rmd_file <- stringr::str_replace(rmd_file, "_TMP.Rmd", ".Rmd")
  if (type[1] == "R")
    return(stringr::str_glue("# Generated from {rmd_file}: do not edit by hand"))
  else if (type[1] == "man")
    return(stringr::str_glue("% Please edit documentation in {rmd_file}."))
  else if (type[1] == "c")
    return(stringr::str_glue("// Generated from {rmd_file}: do not edit by hand"))
  else
    stop("type must be either 'R', 'man', or 'c'.")
}
```

This function will also be used with `type = "man"` by `litr::document()`.

The above also makes use of a simple helper function that inserts text into a specified location of a file (or creates that file if it doesn't exist). **Actually currently it doesn't, but we can replace `cat()` in the above with calls to `add_text_to_file()`.**

```{r}
#' Add Some Text to a File
#' 
#' The text will be added to the file at a particular line specified by
#' `location`.  The first line of `txt` will be on line `location` of the
#' modified file.  If `location` is NULL, then text is added to end of file.
#' If file does not exist, it is created and `location` is ignored (unless 
#' `req_exist` is `TRUE`, in which case an error is thrown).
#' 
#' @param txt Character vector to add to file
#' @param filename Name of file
#' @param location Specifies where text should be added. See description for more.
#' @param req_exist If TRUE, then 
#' @export
add_text_to_file <- function(txt, filename, location = NULL, req_exist = FALSE) {
  if (!file.exists(filename)) {
    if (req_exist) stop(stringr::str_glue("Cannot find file {filename}."))
    writeLines(txt, con = filename)
    return()
  }
  filetxt <- readLines(filename)
  if (is.null(location) || location == length(filetxt) + 1) {
    filetxt <- c(filetxt, txt)
  }
  else if (location > length(filetxt) + 1 | location < 1) 
    stop("Invalid location")
  else if (location == 1) {
    filetxt <- c(txt, filetxt)
  } else {
    # location is somewhere in middle
    filetxt <- c(filetxt[1:(location - 1)],
                 txt,
                 filetxt[location:length(filetxt)])
  }
  writeLines(filetxt, con = filename)
}
```

```{r}
testthat::test_that("add_text_to_file() works", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  
  # should throw error when file does not exist and req_exist is TRUE:
  myfile <- file.path(dir, "file.txt")
  sometxt <- c("hello", "there")
  testthat::expect_error(add_text_to_file(sometxt, myfile, req_exist = TRUE))

  # should create a new file where one does not exist:
  myfile <- file.path(dir, "file.txt")
  sometxt <- c("hello", "there")
  add_text_to_file(sometxt, myfile)
  testthat::expect_true(fs::file_exists(myfile))
  testthat::expect_equal(sometxt, readLines(myfile))
  
  # should append to end of file by default
  moretxt <- "world"
  add_text_to_file(moretxt, myfile)
  testthat::expect_equal(c(sometxt, moretxt), readLines(myfile))
   
  # should throw error for invalid locations:
  testthat::expect_error(add_text_to_file(sometxt, myfile, 0))
  testthat::expect_error(add_text_to_file(sometxt, myfile, -1))
  testthat::expect_error(add_text_to_file(sometxt, myfile, 5))

  # should add to specified line:
  moretxt2 <- "hi"
  add_text_to_file(moretxt2, myfile, 1)
  testthat::expect_equal(c(moretxt2, sometxt, moretxt), readLines(myfile))

  # should add to specified line:
  moretxt3 <- "hi2"
  add_text_to_file(moretxt3, myfile, 2)
  testthat::expect_equal(c(moretxt2, moretxt3, sometxt, moretxt),
                         readLines(myfile))

  # should add to specified line:
  moretxt4 <- "hi3"
  add_text_to_file(moretxt4, myfile, 6)
  testthat::expect_equal(c(moretxt2, moretxt3, sometxt, moretxt, moretxt4),
                         readLines(myfile))
  fs::dir_delete(dir)
})
```


#### Setting up the R package creation

When the user calls `litr::render()` (either in the console or by pressing "Knit" in RStudio), one of the firs things that function does is to call the function `litr::setup()`, which does several things:

1. Creates a new empty directory at the specified location while first making sure that it won't overwrite something it shouldn't.  In particular, we guard against the case that the package was generated by `litr::render()` but then someone went in manually and made some changes.  Even though users should never manually edit the package that was generated by `litr::render()`, we don't want to have them inadvertantly lose their work by doing so.  Thus, we only overwrite an R package if we can tell that it is the unedited output of a call to `litr::render()`.  The function `check_unedited()` is responsible for checking this, and is a pretty interesting function which we will describe in [the next section](#hash).  This part of the code also makes use of a function `litr::make_noticeable()`, which is simply a way of making error messages produced by `litr` more easy to see amid a lot of `knitr` output.

2. Adjusts the root directory from the generating .Rmd file's location to the R package's location. **Note: This behavior might not actually be desirable now that additional files will be loaded in.  It might be awkward for a user writing the generating .Rmd file to have to make everything relative to the package.  It might be convenient to provide a `litr::add_file(from, to)` function, where `from` is the path relative to the .Rmd file and `to` is the path relative to the package's location.**

3. Makes it so that the `send_to_package()` chunk hook is active for each code chunk.  This involves registering a new chunk hook using the function `knitr::knit_hooks$set()` and then setting an option with the same name to `TRUE` within each chunk.

4. Deactivates an internal function of the `usethis` package, `usethis:::challenge_nested_project()`.  This was actually a difficult issue to address that involves the intersection of `usethis`, `here`, and our particular use case.  The problem is that `usethis` was not designed for our setting in which an R package is being created programmatically.  When using `litr`, the project directory will have the generating .Rmd file and when this is knit it will create an R package within this project.  However, this leads `usethis` to prompt the user with a message of the form

> "New project '[...]' is nested inside an existing project '[...]'.  This is rarely a good idea. Do you wish to create anyway?"

But since this is encountered through knitting rather than interactively, this results in an error.  [This](https://github.com/r-lib/usethis/issues/553) `usethis` issue describes this exact problem.  The solution suggested there by jennybc involving `testthat::with_mock()` is along the lines of what we want; however, that would lead to some ugly looking code in the generating .Rmd file.  The best solution I could find was to use `utils::assignInNamespace()` as described [here](https://stat.ethz.ch/pipermail/r-help/2008-August/171215.html).  This function allows us to change the internal function `usethis:::challenge_nested_project()` so that it no longer prompts the user with concerns about nested projects.

```{r}
#' Code for setup chunk
#' 
#' * Creates directory where package will be. (Deletes what is currently there as 
#' long as it appears to have been created by litr and does not have any 
#' subsequent manual edits.)
#' * Sets the root directory to this directory
#' * Sets up the main chunk hook `litr::send_to_package()` that sends code to the 
#' R package directory.
#' * Sets up a [custom language engine](https://bookdown.org/yihui/rmarkdown-cookbook/custom-engine.html) called
#' `package_doc` that creates a package documentation file and then inserts
#' whatever the user puts in the chunk.
#' 
#' @param package_dir Directory where R package will be created
#' @export
setup <- function(package_dir) {
  if (file.exists(package_dir)) {
    unedited <- tryCatch(check_unedited(package_dir),
                         error = function(e) {
                           # contents of package_dir does not resemble
                           # a litr package
                           return(FALSE)
                         })
    if (!unedited) {
      stop(make_noticeable(paste(
        stringr::str_glue("The directory {normalizePath(package_dir)}"),
        "already exists and either was not created by litr or may have manual",
        "edits. In either case, please rename that directory (or delete it)", 
        "and then try again.", 
        sep = "\n")))
    }
    unlink(package_dir, recursive = TRUE)
  }
  fs::dir_create(package_dir)
  knitr::opts_knit$set(root.dir = package_dir) # sets wd of future chunks
  knitr::knit_hooks$set(send_to_package = send_to_package)
  knitr::opts_chunk$set(send_to_package = TRUE)
  
  # change usethis:::challenge_nested_project so that it will not complain
  # about creating a nested project (e.g. if this is called within a git 
  # subdirectory)
  utils::assignInNamespace("challenge_nested_project", function(...) NULL, ns = "usethis")
  # change usethis:::use_src_example_script so that it will not cause an error
  utils::assignInNamespace("use_src_example_script", 
                           function(...) {
                             usethis::use_template("code.cpp",
                                                   fs::path("src", "code.cpp"))
                           }, ns = "usethis")
  
  # setup package_doc engine
  knitr::knit_engines$set(package_doc = function(options) {
    # create package_doc
    usethis::use_package_doc(open = FALSE)
    
    # insert the contents of the code chunk into the package_doc
    pkgdoc <- file.path("R", paste0(fs::path_file(package_dir), "-package.R"))
    add_text_to_file(options$code, filename = pkgdoc, location = 1)
    
    # now treat this as if it were standard R code with eval=FALSE
    r_engine <- knitr::knit_engines$get("R")
    options[["eval"]] <- FALSE
    return(r_engine(options))
  })
}
```

The previous function made use of a small function, `make_noticeable()`, which we define here:

```{r}
#' Make error messages noticeable
#' 
#' Since litr error messages are amid a lot of output from knitting, we'd like 
#' the litr ones to be eye-catching.
#' 
#' @param msg Error message
make_noticeable <- function(msg) {
  paste("",
        "======",
        "Please read your friendly litr error message here:",
        paste("> ", msg),
        "======",
        sep = "\n")
}
```

The code in this section used the `fs` and `knitr` packages, so we import those:

```{r}
usethis::use_package("fs")
usethis::use_package("knitr")
```


### Not overwriting a manually edited R package {#hash}

As described in the previous section, the function `setup()` will only overwrite a directory if it is the unedited output of a call to `litr::render()`.  The basic idea is that the function `litr::render()` when creating a new package finishes by adding a hash to the DESCRIPTION file.  This hash is a function of everything in the package, so if anything about the package changes (any file is modified, added, or removed) then the function `check_unedited()` will be able to detect that by recomputing the hash and seeing that it doesn't match the hash in the DESCRIPTION file.

Let's start by defining the function `hash_package_directory()` that does the hashing.  The hash is a function of everything in the outputted package *except for that special line in the DESCRIPTION file with the hash*.  We use `tools::md5sum()` and `digest::digest()` to do the hashing.

```{r}
#' Hash package directory
#' 
#' Gets an identifier that can be used to uniquely (whp) identify the current 
#' state of the package. This is formed by ignoring the `LitrId` field of the
#' DESCRIPTION file, which is the location where the output of this function is 
#' stored when `litr::render` generates the package.
#' 
#' @param package_dir Path to package
hash_package_directory <- function(package_dir) {
  pkg_files <- fs::dir_ls(package_dir, recurse = TRUE, all = TRUE, type = "file")
  pkg_files <- stringr::str_subset(pkg_files, ".DS_Store$", negate = TRUE)
  pkg_files <- normalizePath(pkg_files)
  descr_file <- normalizePath(file.path(package_dir, "DESCRIPTION"))
  i_descr <- which(pkg_files == descr_file)
  if (length(i_descr) == 0) stop("Cannot find DESCRIPTION file.")
  txt_descr <- readLines(pkg_files[i_descr])
  txt_descr_mod <- stringr::str_subset(
    txt_descr, 
    stringr::str_glue("{description_litr_hash_field_name()}: .+$"),
    negate = TRUE)
  hashes <- as.character(tools::md5sum(pkg_files[-i_descr]))
  digest::digest(c(hashes, list(txt_descr_mod)))
}
```

We used `digest`, so let's import it:

```{r}
usethis::use_package("digest")
```

We will store this hash in a special field within the DESCRIPTION file.  Let's call this field `LitrId`.  However, in case we ever decide to change the name of this field, it's better that we only define it in one place.  So we do this with the following function:

```{r}
#' Generate litr hash field name for DESCRIPTION file
description_litr_hash_field_name <- function() return("LitrId")
```

Ok, now let's write the function that `litr::render()` will call that will take the generated R package and add a line that puts the hash in the DESCRIPTION file under that special `litr` field:

```{r}
#' Write the hash of the package to the DESCRIPTION file
#' 
#' @param package_dir Path to package
write_hash_to_description <- function(package_dir) {
  hash <- hash_package_directory(package_dir)
  add_text_to_file(
    txt = stringr::str_glue("{description_litr_hash_field_name()}: {hash}"),
    filename = file.path(package_dir, "DESCRIPTION"),
    req_exist = TRUE
    )
}
```

And of course we'll need a way a function that can read the value of that field as well:

```{r}
#' Get the hash of the package from the DESCRIPTION file
#' 
#' @param package_dir Path to package
read_hash_from_description <- function(package_dir) {
  descr <- file.path(package_dir, "DESCRIPTION")
  if (!file.exists(descr)) stop("Cannot find DESCRIPTION file.")
  txt <- stringr::str_subset(
    readLines(descr), 
    stringr::str_glue("{description_litr_hash_field_name()}: .+$"))
  if (length(txt) > 1) stop("More than one hash found in DESCRIPTION.")
  if (length(txt) == 0) stop("No hash found in DESCRIPTION.")
  stringr::str_extract(txt, "\\S+$")
}
```

With all this hash functionality in place, the function `check_unedited()` is actually quite simple to define:

```{r}
#' Check if package directory is the unedited output of litr::render
#' 
#' Uses hash stored in a special `litr` field of DESCRIPTION file to check that 
#' the current state of the R package directory is identical to its state at the
#' time that it was created by `litr::render()`.
#' 
#' @param package_dir Path to package
#' @export
check_unedited <- function(package_dir) {
  hash <- hash_package_directory(package_dir)
  hash == read_hash_from_description(package_dir)
}
```

It simply computes the hash of the current package and checks whether that hash is the same as what was originally written to the DESCRIPTION file by `litr::render()`.

### Keeping track of what version of `litr` was used to create package

For the sake of reproducibility, it will be useful to record the version of `litr` used to create a package.  We will do this by adding a field to the DESCRIPTION file.

```{r}
#' Generate litr version field name for DESCRIPTION file
description_litr_version_field_name <- function() return("LitrVersionUsed")
```

```{r}
#' Write the version of litr used to the DESCRIPTION file
#' 
#' @param package_dir Path to package
write_version_to_description <- function(package_dir) {
  ver <- as.character(utils::packageVersion("litr"))
  add_text_to_file(
    txt = stringr::str_glue("{description_litr_version_field_name()}: {ver}"),
    filename = file.path(package_dir, "DESCRIPTION"),
    req_exist = TRUE
    )
}
```


### Wrappers to `devtools::document()` and `rmarkdown::render()` {#wrappers}

#### Defining `litr::document()`

This function is nearly identical to `devtools::document()` except that it changes the roxygen2 message that says "Please edit documentation in R/[...].R" to instead mention the generating .Rmd file.

```{r}
#' Use roxygen to document a package
#' 
#' This is a wrapper for the `devtools::document()` function, which in turn is a
#' wrapper for the `roxygen2::roxygenize()` function.  The purpose for `litr` 
#' having this wrapper is to make one modification.  In particular, the line
#' in the outputted `Rd` files should not say "Please edit documentation in 
#' R/file.R" but instead should refer to the Rmd file that generates everything. 
#' 
#' @param ... Arguments to be passed to `devtools::document()`
#' @export
document <- function(...) {
  devtools::document(...)
  # remove the line of the following form in each man/*.Rd file:
  pattern <- "% Please edit documentation in .*$"
  msg <- do_not_edit_message(knitr::current_input(), type = "man")
  for (fname in fs::dir_ls("man")) {
    txt <- stringr::str_replace(readLines(fname), pattern, msg)
    cat(paste(txt, collapse = "\n"), file = fname)
  }
}
```

We used `devtools`, so let's import it:

```{r}
usethis::use_package("devtools")
```


#### Defining `litr::render()`

This function does a number of things:

1. Calls `setup()`, which creates the R package directory and makes it so that when we knit the file using `rmarkdown::render()`, a lot of special things will happen, such as code being sent to the R package directory.

2. Calls `rmarkdown::render()`.  This is done in a very particular way [as described in the Rmarkdown Cookbook](https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-render.html) that ensures the identical behavior to when one clicks the "Knit" in RStudio.  In particular, we have a fresh R session opened in which first `setup()` and then `rmarkdown::render()` are called.

3. If a .html file was created by the previous call, we call the functions `add_function_hyperlinks()` and `add_chunk_label_hyperlinks()` that process this .html file, making it so that one can easily navigate to function definitions and code chunk references within the .html file.  (These functions are described in the [post-knit processing section](#post-knit).)

4. Adds a field to the DESCRIPTION file giving the version of `litr` used to generate this package.  This will be useful for reproducibility.

5. Writes the special `litr` hash (as already described [here](#hash)).  Before we can write the hash, we need to determine the location of the outputted package.  The location of the package is specified as parameters in the YAML header of the generating .Rmd file; however, these parameter values can be overridden within a call to `render` if one passes any of these parameters as arguments. The function `get_params_used()`, defined at the end of this section, gets the actual parameters that are used so that the location of the outputted package can be found.

```{r}
#' Render R markdown file
#' 
#' Wrapper to `rmarkdown::render` that does some post-processing on the html 
#' file when that is the output.  In particular, when an html file is among the 
#' outputs, it adds hyperlinks to functions defined within the file to make it 
#' easier for someone reading the code to see where different functions are
#' defined.
#' 
#' @param input The input file to be rendered (see `rmarkdown::render`)
#' @param ... Additional parameters to pass to `rmarkdown::render`
#' @export
render <- function(input, ...) {
  # Pre-knit steps start
  # need to specify output file and directory to be the directory of the input
  output_file <- paste0(fs::path_ext_remove(input), ".html")
  input_dir <- fs::path_dir(input)
    
  rmd_file <- readLines(input)
  preprocessed_rmd <- preprocess_chunk_labels(rmd_file)
  # write this to a temp file in the same directory as the input file
  temp_file <- paste0(fs::path_ext_remove(input),"_TMP.", fs::path_ext(input))
  modified_input <- file.path(input_dir, fs::path_file(temp_file))
  writeLines(preprocessed_rmd, modified_input)
  # Pre-knit steps end
  
  # call rmarkdown::render in a new environment so it behaves the same as 
  # pressing the knit button in RStudio:
  # https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-render.html

  args <- list(...)
  # only change the output file name if output_file is not passed by the user
  args[["output_file"]] <- ifelse(is.null(args[["output_file"]]), output_file, args[["output_file"]])
  params <- get_params_used(modified_input, args$params)
  package_dir <- ifelse(
    params$package_parent_dir == ".",
    file.path(dirname(input), params$package_name),
    file.path(dirname(input), params$package_parent_dir, params$package_name)
  )
  args$package_dir <- package_dir

  render_ <- function(input, package_dir, ...) {
    litr::setup(package_dir)
    rmarkdown::render(input, ...)
  }

  out <- xfun::Rscript_call(render_, c(input = modified_input, args))
  
  # add hyperlinks within html output to make it easier to navigate:
  if (any(stringr::str_detect(out, "html$"))) {
    html_file <- stringr::str_subset(out, "html$")
    add_function_hyperlinks(html_file)
    add_chunk_label_hyperlinks(html_file)
  }
  
  # add to DESCRIPTION file the version of litr used to create package:
  write_version_to_description(package_dir)
  
  # add litr hash so we can tell later if package files were manually edited:
  write_hash_to_description(package_dir)
  
  # now that we've finished using the temporary file, let's clean up after our selves
  fs::file_delete(modified_input)
}
```

**Note: When `litr::render()` encounters an error, it can leave the output directory partially modified but without an updated hash.  As a result, the next time one calls `litr::render()` it does not allow this directory to be overwritten.  This behavior should be fixed by wrapping the `xfun::Rscript_call` in a tryCatch and then if there's an error either (a) deleting everything that had been partially created or (b) writing the hash based on the current state.  Of course, if the DESCRIPTION file doesn't exist then this wouldn't work.**

We used `xfun`, so let's import it:

```{r}
usethis::use_package("xfun")
```

As described earlier, the function `get_params_used()` combines the parameters from the YAML but allows for those values to be overridden through arguments passed to `render()`.

```{r}
#' Get parameter values used in rendering
#' 
#' When the `params` argument of `rmarkdown::render()` is explicitly used, this
#' overrides the default that appears in `input`.
#' @param input The input file to be rendered (see `rmarkdown::render`)
#' @param passed_params The list of parameters that were passed to `render`.
get_params_used <- function(input, passed_params) {
  params <- rmarkdown::yaml_front_matter(input)$params
  for (param in names(passed_params)) {
    params[[param]] <- passed_params[[param]]
  }
  params
}
```

We used the package `rmarkdown`, so let's import it:

```{r}
usethis::use_package("rmarkdown")
```


##### Displaying chunks embedded within a chunk

`knitr` allows code chunks to be nested within each other, as explained [here](https://bookdown.org/yihui/rmarkdown-cookbook/reuse-chunks.html). However, when the file is knitted, the output one sees does not show the label of the code chunk but instead replaces it with the actual code. Compare this to how literate programming output is displayed in [Knuth's literate programming paper](http://www.literateprogramming.com/knuthweb.pdf). In the context of `litr`, it seems we'd like to see the label of the inner code chunk rather than the code of the inner code chunk. If a .Rmd file has nested code chunks, we'd like the following behavior:

1. The actual code that is run should still behave exactly as it does normally in knitr.
2. If a code chunk has something of the form `<<inner-chunk>>` within it, we should see `<<inner-chunk>>` with a hyperlink. The hyperlink would take you to the code chunk with label `"inner-chunk"`. The code chunk that is linked to should have its label visible in a way that it is not mistaken for the code itself).

###### Pre-knit processing {#pre-knit}

To implement this feature we need to create a "pre-knit" function that takes the .Rmd file, finds the chunks with embedded chunks, makes a copy of that chunk with a modified label delimiter to avoid `knitr` replacing the chunk labels with the referenced code, and finally adds an option to the original chunk so that it will be run but not included in the knitted document. The steps of the pre-knit function are the following:

1. Find the chunks that contain chunk labels.
2. For each of the chunks with chunk labels, insert a copy of that chunk into the document.
3. Change the embedded chunk delimiter to prevent `knitr` from replacing the chunk labels.
4. Change the options of the duplicated chunk to prevent it from being run by `knitr`.
5. Change the options of the original chunk so that it is run but not displayed in the document.
6. Make a vector of the unique labels of chunks that are referenced and add a comment to those chunks with their chunk label.
7. Write this modified .Rmd file to a temporary file in the same directory as the original .Rmd file.
8. Call `rmarkdown::render()` on the modified .Rmd file.

With these steps outlined, we will show this process in action on the following minimal Rmarkdown file:

```{r, include=FALSE}
rmd <- unlist(strsplit("---\ntitle: `pre_process_chunk_labels` Example\noutput: html_document\n---\n\n# Content\n\n\n```{r c2f}\nC2F <- function(x){\n    <<check-arg>>\n    <<convert-c2f>>\n}\n```\n\n```{r}\nF2C <- function(x){\n    <<check-arg>>\n    <<convert-f2c>>\n}\n```\n\n```{r check-arg, eval=F}\n    if(!is.numeric(x)) stop('blah')\n```\n\n```{r convert-f2c, eval=F}\n    (x-32) * 5/9\n```\n\n```{r convert-c2f, eval=F}\n    (x * 9/5) + 32\n```\n\n ```{r}\nF2C(90)\n```\n", "\n"), recursive = F)
```

```{r, include=FALSE}
# This is a helper function which pretty prints example Rmd code within an Rmd file. To be displayed properly, the chunk containing the `print_rmd` function call must have the chunk argument results='asis'.
print_rmd <- function(rmd_vector){
  rmd <- rmd_vector
  # add the ````markdown at the beginning and ```` at the end
  rmd <- c("````markdown", rmd, "````")
  # return the formatted string
  cat(stringr::str_flatten(rmd, collapse = "\n"))
}
```

```{r echo=FALSE, results='asis'}
print_rmd(rmd)
```


In the example above, we'd like to create reference links in the `C2F` and `F2C` functions since they reference the chunk labels for `check-arg` and `convert-*`.  We want to keep these labels but also have `knitr` fill in the labels and execute the code. This is where the `preprocess_chunk_labels()` and `extract_rmd_code_chunks()` functions come in. The `extract_rmd_code_chunks()` function takes a .Rmd file as input and finds the chunks with chunk labels. Then `preprocess_chunk_labels()` loops through each of these chunks, making a copy of the chunk with a modified label delimiter (changing `<<label>>` to `@@@label@@@`), and changing the option of the original copy of the chunk to be run, but not included in the knitted document.

```{r}
#' Find an Rmd chunk label in a code chunk and modify the chunk reference delimiter before knitting
#' 
#' @param rmd_file A character vector of an Rmd file lines
#' @export 
preprocess_chunk_labels <- function(rmd_file){
    code_chunks <- extract_rmd_code_chunks(rmd_file)
    # handle edge case of no code chunks
    if(length(code_chunks) > 0){
      # loop over the code_chunk list 
      offset = 0
      for(i in 1:length(code_chunks)){
        # check if we found a referenced label for this element
        code_chunk <- code_chunks[[i]]
        if(code_chunk$contains_labels$chunk_idx){
          chunk_start <- code_chunk$start_idx+offset
          chunk_end <- code_chunk$end_idx+offset
          orig_chunk <- rmd_file[chunk_start:chunk_end]
          dup_chunk <- orig_chunk
          # we need to add eval=F to the original chunk and change the ref brackets so that knitr doesn't fill in the labels
          # add eval=F at the end of the chunk options which we assume to be the first line of the chunk
          # TO-DO: check if it is possible to have multi-line chunk options?
          orig_chunk[1] <- stringr::str_replace(orig_chunk[1], "\\}", stringr::str_glue(", eval=FALSE\\}"))
          orig_chunk <- sapply(orig_chunk, replace_label_delimiter, USE.NAMES = FALSE)
          
          # we need to hide this chunk but still have it evaluated (include=FALSE)
          # knitr should still fill in the labels
          dup_chunk[1] <- stringr::str_replace(dup_chunk[1], "\\}", stringr::str_glue(", include=FALSE\\}"))
          dup_chunk[1] <- modify_chunk_label(dup_chunk[1])
          
          # now replace the original chunk and fill in the duplicate chunk
          # and increase the offset by the size of the duplicate chunk
          rmd_file[chunk_start:chunk_end] <- orig_chunk
          rmd_file <- append(rmd_file, dup_chunk, after=chunk_end)
          offset <- offset + length(dup_chunk)
        }
      }
      
      unique_referenced_chunks <- code_chunks |> {\(x) purrr::map(x,function(y){
          if(length(y$contains_labels$chunk_ids) > 0){
              return(y$contains_labels$chunk_ids)
          }
      })}()
      unique_referenced_chunks <- unique_referenced_chunks[!sapply(unique_referenced_chunks,is.null)] |> unlist() |> unique()
      
      all_chunk_names <- purrr::map_chr(code_chunks, "chunk_label")
      # check that the referenced chunk names exist in the file, otherwise throw error
      refs_not_in_file <- setdiff(unique_referenced_chunks,all_chunk_names)
      if(length(refs_not_in_file) > 0){
        stop(stringr::str_glue("Unable to find the following chunk reference(s) in this Rmarkdown file: {toString(refs_not_in_file)}."))
      }
      
      changed_code_chunks <- extract_rmd_code_chunks(rmd_file)
      offset = 0
      for(i in 1:length(changed_code_chunks)){
        code_chunk <- changed_code_chunks[[i]]
        chunk_start <- code_chunk$start_idx + offset
        chunk_end <- code_chunk$end_idx + offset
        orig_chunk <- rmd_file[chunk_start:chunk_end]
        chunk_label <- code_chunk$chunk_label
        if( (chunk_label != "") & chunk_label %in% unique_referenced_chunks){
          chunk_comment = stringr::str_glue('###"{chunk_label}"###')
          rmd_file <- append(rmd_file, chunk_comment, after = chunk_start)
          offset <- offset + 1
        }
      }
    }
    
    
    rmd_file
}
```

We used `purrr`, so let's import it:

```{r}
usethis::use_package("purrr")
```


```{r}
#' Get a list of code chunks from an Rmd file in vector form
#' 
#' @param rmd_vector A character vector of an Rmd file that has been split by new lines
#' @return A list containing information about each code chunk including the code, whether it contains references to other code chunks, and the start and end line numbers of the code chunk in the Rmd file.
extract_rmd_code_chunks <- function(rmd_vector){
  chunk_start <- which(grepl(rmd_vector, pattern = knitr::all_patterns$md$chunk.begin))
  # handle the case where no code chunks found
  if(length(chunk_start) > 0){
    chunk_end <- sapply(chunk_start, function(x){
    # starting from the chunk start, find the first triple backticks location
    num_after_start <- which(grepl(rmd_vector[-(1:x)], pattern = knitr::all_patterns$md$chunk.end, perl = T))[1]
    return(x + num_after_start)
  })
  code_extract <- function(rmd_vector, start, end){
    return(rmd_vector[(start+1):(end-1)])
  }
  # create a list of code chunks by looping over the chunk_start and chunk_end vectors
  code_chunk_list <- lapply(1:length(chunk_start), function(i){
    start <- chunk_start[i]
    end <- chunk_end[i]
    code <- code_extract(rmd_vector, start, end)
    # include the name of the current chunk here
    chunk_label <- extract_label(rmd_vector[start])
    # add an element of the list with information on whether another code chunk is referenced in this code chunk
    contains_labels <- find_labels(code)
    list(code = code, chunk_label = chunk_label, contains_labels = contains_labels, start_idx = start, end_idx = end)
  })
  } else{
    code_chunk_list <- list()
  }
  
  code_chunk_list
}
```


The `find_labels()` function is a small helper function within `extract_rmd_code_chunks()` which determines whether a code chunk contains a chunk label by making use of the regular expression for reference chunks in the `knitr` package.

```{r}
#' Find an Rmd chunk label in a code chunk
#' 
#' @param chunk_code Character vector of code from an Rmd code chunk. Each element is a line of the code chunk.
#' @return List where chunk_idx is a logical vector for each line of the chunk corresponding to whether a chunk label of the form <<label>> was found and chunk_ids is a character vector of chunk label was found in that chunk.
find_labels <- function(chunk_code){
    rc <- knitr::all_patterns$md$ref.chunk
    chunk_idx <- any(idx = grepl(rc, chunk_code))
    chunk_ids <- stringr::str_trim(sub(rc, "\\1", chunk_code[grepl(rc, chunk_code)]))
    return(list(chunk_idx = chunk_idx, chunk_ids = chunk_ids))
}
```


As mentioned earlier in step 3, we need a function for replacing chunk label delimiters to avoid `knitr` filling the function in when knitting the document. The `replace_label_delimiter()` function does this for us by using a temporary label delimiter (`@@@`) that will be replaced with `<< >>` during the post-knit processing.

```{r}
#' Replace the delimiter of Rmd chunk label in a code chunk
#' 
#' @param chunk_code Character vector of code from an Rmd code chunk. Each element is a line of the code chunk.
#' @param label_delim Delimiter to replace the chunk label delimiter recognized by `knitr`. Default label delimiter is "@@@"
#' @return Character vector with replaced chunk label delimiter.
replace_label_delimiter <- function(chunk_code, label_delim="@@@"){
    # modified version of knitr:::all_patterns$md$ref.chunk
    rc <- "^(\\s*)(<<(.+)>>)(\\s*)$"
    idx <- grepl(rc, chunk_code)
    # we want to keep the original indentation so we insert the indentation to the left and right of the label
    sub(rc, "\\1@@@\\3@@@\\4", chunk_code)
}
```

We also need a small helper function for modifying chunk names when we create a duplicate chunk. If we are unable to find a chunk name, we just return the original line and let `knitr` name unnamed chunks for us later on. The regular expression in this function is a slightly modified version of  `knitr::all_patterns$md$chunk.begin` with additional capture groups.
```{r}
#' Modify a chunk name and add "-dup" as a suffix.
#' This function assumes that we are passed a chunk option line that contains a chunk label since this function is called in the context of creating a duplicate version of a referenced chunk.
#' @param chunk_option Character vector of the first line of a chunk, i.e. ```{r chunk-name, ...}
#' @return Character vector of the chunk option with "-dup" appended to the chunk label. i.e., ```{r chunk-name-dup, ...}
modify_chunk_label <- function(chunk_option){
  # look for a name in the chunk option, if there isn't a name then the fourth element will be NA
  regex_matches <- stringr::str_match(chunk_option,"^[\t >]*(```+\\s*\\{)([a-zA-Z0-9_]+)( *[ ,][a-zA-Z0-9_-]+)?(.*\\}\\s*)$")
  if(!is.na(regex_matches[,4])){
    return(stringr::str_glue("{regex_matches[,2]}{regex_matches[,3]} {stringr::str_trim(regex_matches[,4])}-dup{regex_matches[,5]}"))
  } else{
    return(stringr::str_glue("{regex_matches[,2]}{regex_matches[,3]}{regex_matches[,5]}"))
  }
}
```

Finally we add a helper function that is similar to `modify_chunk_label()` except here we extract the label instead of modifying it in-place.
```{r}
#' Extract chunk label from the first line of an Rmd chunk.
#' 
#' @param chunk_option Character vector of the first line of a chunk, i.e. ```{r chunk-name, ...}
#' @return Character vector of the chunk label if it exists, empty string "" otherwise
extract_label <- function(chunk_option){
  label <- stringr::str_trim(gsub("^[\t >]*(```+\\s*\\{)([a-zA-Z0-9_]+)( *[ ,][a-zA-Z0-9_-]+)?(.*\\}\\s*)$", '\\3', chunk_option))
  # this regular expression returns an empty string if the chunk does not have a label so just return the label
  return(label)
}
```
###### Testing `preprocess_chunk_labels()` `extract_rmd_code_chunks()`

The purpose of these tests is to make sure that the `preprocess_chunk_labels()` function handles the following types of Rmd files properly:

* Rmd files with no code chunks
* Rmd files with no code chunk references
* Rmd files with code chunk references
* Rmd files referencing a chunk that does not exist within the file
* Rmd files with chunks that are not labeled

```{r}
no_chunks <- unlist(strsplit("---\ntitle: `pre_process_chunk_labels` Example\nauthor: Me\ndate: 2022-05-27\noutput: html_document\n---\n", "\n"), recursive = FALSE)

no_reference <- unlist(strsplit("---\ntitle: `pre_process_chunk_labels` Example\nauthor: Me\ndate: 2022-05-27\noutput: html_document\n---\n\n# Setup\n\n```{r setup, include = FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n```{r check-arg, eval=F}\n    if(!is.numeric(x)) stop('blah')\n```\n", "\n"), recursive = FALSE)

one_reference <- unlist(strsplit("```{r c2f}\nC2F <- function(x){\n    <<check-arg>>\n}\n```\n\n```{r check-arg, eval=F}\n    if(!is.numeric(x)) stop('blah')\n```\n", "\n"), recursive = FALSE)

missing_ref_chunk <- unlist(strsplit("```{r c2f}\nC2F <- function(x){\n    <<check-arg>>\n    <<convert-c2f>>\n}\n```\n\n```{r check-arg, eval=F}\n    if(!is.numeric(x)) stop('blah')\n```\n", "\n"), recursive = F)

chunk_with_no_label <- unlist(strsplit("---\ntitle: `pre_process_chunk_labels` Example\nauthor: Me\ndate: 2022-05-27\noutput: html_document\n---\n\n```{r}\n    1+2\n```\n", "\n"), recursive = FALSE)

testthat::test_that("preprocess_chunk_labels works as expected", {
  # handle the case where we are given a document with no codes chunks and when we do not have any chunk references
  # for both cases preprocess_chunk_labels should return the original rmd vector
  testthat::expect_equal(preprocess_chunk_labels(no_chunks), no_chunks)
  testthat::expect_equal(preprocess_chunk_labels(no_reference), no_reference)
  
  # check that when there is a chunk reference, we correctly change the delimiter, create a duplicate chunk and add a comment to referenced chunk
  testthat::expect_equal(preprocess_chunk_labels(one_reference), unlist(strsplit("```{r c2f, eval=FALSE}\nC2F <- function(x){\n    @@@check-arg@@@\n}\n```\n```{r c2f-dup, include=FALSE}\nC2F <- function(x){\n    <<check-arg>>\n}\n```\n\n```{r check-arg, eval=F}\n###\"check-arg\"###\n    if(!is.numeric(x)) stop('blah')\n```", "\n"), recursive = FALSE))
  
  # throw error if we can't find a referenced chunk in the file
  testthat::expect_error(preprocess_chunk_labels(missing_ref_chunk), "Unable to find the following chunk reference(s) in this Rmarkdown file: convert-c2f.", fixed=TRUE)
})
```


Here we test `extract_rmd_code_chunks()` using some of the examples from the previous section as well as a combined mini example file.

```{r}
rmd_mini_example <- unlist(strsplit("---\ntitle: `pre_process_chunk_labels` Example\nauthor: Me\ndate: 2022-05-27\noutput: html_document\n---\n\n# Setup\n\n```{r setup, include = FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n# Content\n\n\n```{r c2f}\nC2F <- function(x){\n    <<check-arg>>\n    <<convert-c2f>>\n}\n```\n\n```{r check-arg, eval=F}\n    if(!is.numeric(x)) stop('blah')\n```\n", "\n"), recursive = FALSE)

testthat::test_that("extract_rmd_code_chunks works as expected", {
  # handle the case where we are given a document with no codes chunks
  # in the case of extract_rmd_code_chunks we should just return an empty list
  testthat::expect_equal(extract_rmd_code_chunks(no_chunks), list())
  # handle the case where we do have code chunks but no references
  # we expect that chunk_idx should be FALSE and no chunk_ids (thus length is 0)
  no_reference_chunks <- extract_rmd_code_chunks(no_reference)
  no_reference_chunk_idx <- sapply(no_reference_chunks, function(x){x$contains_labels$chunk_idx})
  no_reference_chunk_ids <- sapply(no_reference_chunks, function(x){length(x$contains_labels$chunk_ids)})
  testthat::expect_equal(no_reference_chunk_idx, c(FALSE, FALSE))
  testthat::expect_equal(no_reference_chunk_ids, c(0, 0))
  # we should pull all chunks from an Rmd file
  mini_example_chunks <- extract_rmd_code_chunks(rmd_mini_example)
  
  mini_example_chunk_idx <- sapply(mini_example_chunks, function(x){x$contains_labels$chunk_idx})
  mini_example_chunk_ids <- sapply(mini_example_chunks, function(x){length(x$contains_labels$chunk_ids)})
  mini_example_chunk_labels <- sapply(mini_example_chunks, function(x){x$chunk_label})
  
  testthat::expect_equal(mini_example_chunk_idx, c(FALSE, TRUE, FALSE))
  testthat::expect_equal(mini_example_chunk_ids, c(0, 2, 0))
  testthat::expect_equal(mini_example_chunk_labels, c("setup", "c2f", "check-arg"))
})
```


Now that we've introduced the `preprocess_chunk_labels()` and its helper functions, let's see how it works on our minimal example from earlier.

```{r}
preprocessed_rmd <- preprocess_chunk_labels(rmd)
```


```{r, results='asis'}
print_rmd(preprocessed_rmd)
```

From the printed structure we see that after running `preprocess_chunk_labels` we have two copies of the chunks that contain chunk labels.  We see that the delimiters in the first copy have been changed to avoid them being replaced by `knitr`, and we've changed the chunk options so that the original chunk is not evaluated while the duplicate chunk is evaluated but not shown in the knitted document.

This pre-processing method allows us to satisfy our first requirement for the embedded chunks, however we still need to do some "post-knit" processing to satisfy our second requirement.

###### Post-knit processing {#post-knit}

Once the document has been knitted, we would like to add links to allow users to easily refer back to function definitions and referenced chunks. We next introduce two functions for adding this functionality to the knitted .html file, `add_function_hyperlinks()` and `add_chunk_label_hyperlinks()`.

The function `add_function_hyperlinks()` looks for text of the form `foo <- function(` and then wraps `foo` in a `span` tag with `id="foo"` and then whenever `foo` is found it wraps a `a href="#foo"` tag so that it will be a hyperlink to `foo`'s definition.

```{r}
#' Add hyperlinks to function definitions
#' 
#' Finds functions that are defined in the html file by looking for text of the 
#' form `foo <- function(` and then wraps `foo` in a `span` tag with `id="foo"` 
#' and then whenever `foo` is found it wraps a `a href="#foo"` tag so that it be
#' a hyperlink to `foo`'s definition.
#' 
#' @param html_file File name of html file that was created from Rmd file
#' @param output_file File name to output to. Default: `html_file`
#' @export
add_function_hyperlinks <- function(html_file, output_file = html_file) {
  txt <- readLines(html_file)
  start_line <- which(txt == "<body>")
  pattern <- "([a-zA-Z0-9_.]+)(\\s*&lt;-\\s*function)"
  # find functions that are defined in this file:
  function_names <- character(0)
  for (i in seq(start_line + 1, length(txt))) {
    fn_name <- stringr::str_match(txt[i], pattern)[, 2]
    if(is.na(fn_name)) next
    # a function was defined in this line, so put a span around it
    txt[i] <- stringr::str_replace(
      txt[i],
      pattern,
      stringr::str_glue("<span id='{fn_name}'>\\1</span>\\2")
    )
    # and keep track of it for later:
    function_names <- c(function_names, fn_name)
  }
  
  # whenever one of these named functions is named, link to its definition
  txt <- stringr::str_replace_all(
    txt,
    paste0(function_names, "\\(", collapse = "|"),
    function(x) {
      fn_name <- stringr::str_remove(x, "\\(")
      stringr::str_glue("<a href='#{fn_name}'>{fn_name}</a>(")
    }
  )
  writeLines(txt, con = output_file)
}
```


The `add_chunk_label_hyperlinks()` function is similar to the `add_function_hyperlinks()` function except that it looks for comments within code chunks of the form `###"foo"###` and then whenever the chunk label `@@@foo@@@` is found it wraps a `a href="#foo"` tag so that it will be a hyperlink to `foo`'s definition.
```{r}
#' Add hyperlinks to embedded chunks
#' 
#' Finds chunks that are referenced in the html file by looking for comments
#' of the form `###"foo"###` and then wraps `foo` in a `span` tag with `id="foo"` 
#' and then whenever the chunk label `@@@foo@@@` is found it wraps a `a href="#foo"` tag so that it be
#' a hyperlink to `foo`'s definition.
#' 
#' @param html_file File name of html file that was created from Rmd file
#' @param output_file File name to output to. Default: `html_file`
#' @export
add_chunk_label_hyperlinks <- function(html_file, output_file=html_file, reference_delim="@@@"){
    txt <- readLines(html_file)
    start_line <- which(txt == "<body>")
    pattern <- '###&quot;([a-zA-Z0-9-_.]+)&quot;###'
    # find chunks that are defined in this file:
    chunk_names <- character(0)
    for (i in seq(start_line + 1, length(txt))) {
    chunk_name <- stringr::str_match(txt[i], pattern)[, 2]
    if(is.na(chunk_name)) next
    # a function was defined in this line, so put a span around it
    txt[i] <- stringr::str_replace(
      txt[i],
      pattern,
      stringr::str_glue("<span id='{chunk_name}'>###&quot;\\1&quot;###</span>")
    )
    # and keep track of it for later:
    chunk_names <- c(chunk_names, chunk_name)
    }
    
    # whenever one of these named chunks is referenced, link to its definition
    txt <- stringr::str_replace_all(
    txt,
    paste0(reference_delim, chunk_names, reference_delim, collapse = "|"),
    function(chunk_name) {
      chunk_name <- stringr::str_remove_all(chunk_name, reference_delim)
      stringr::str_glue("<a href='#{chunk_name}'>&lt&lt{chunk_name}&gt&gt</a>")
    }
    )
    writeLines(txt, con = output_file)
}
```




### Combining .R files

**This section should eventually be removed but for now I'm doing this to convince myself that the package generated by this .Rmd file really matches the initial version created without the package.**

```{r}
library(magrittr)
library(purrr)
rfiles <- fs::dir_ls("R")
code <- rfiles %>%
  map(readLines) %>%
  set_names(
    rfiles %>% stringr::str_remove("^.*/") %>% stringr::str_remove(".R$")
    )
hash_functions <- c("hash_package_directory",
                    "description_litr_hash_field_name",
                    "write_hash_to_description",
                    "read_hash_from_description",
                    "check_unedited")
render_functions <- c("render",
                      "add_function_hyperlinks",
                      "add_chunk_label_hyperlinks",
                      "find_labels",
                      "replace_label_delimiter",
                      "preprocess_chunk_labels",
                      "extract_rmd_code_chunks",
                      "extract_label",
                      "modify_chunk_label",
                      "get_params_used",
                      "do_not_edit_message",
                      "description_litr_version_field_name",
                      "write_version_to_description",
                      "document")
setup_functions <- c("setup",
                     "make_noticeable",
                     "send_to_package",
                     "add_text_to_file")
remove_initial_lines <- function(code_list) {
  # drop first line of each list element except for the first list element
  c(code_list[1], map(code_list[-1], ~ .x[-1]))
}
fs::file_delete(setdiff(rfiles, "R/litr-package.R"))
writeLines(unlist(remove_initial_lines(code[hash_functions])), "R/hash.R")
writeLines(unlist(remove_initial_lines(code[render_functions])), "R/render.R")
writeLines(unlist(remove_initial_lines(code[setup_functions])), "R/setup.R")
```


## Including templates

We now add the .Rmd templates to the package.  We have the `skeleton.Rmd` defined in `litr-source-files`.  Note that paths are relative to the outputted package's location.

The first template is the simplest imaginable package with a single function:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package",
  template_dir = "make-an-r-package",
  template_description = "Template for an Rmd file for writing an R package using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "litr-source-files", "make-an-r-package", "skeleton.Rmd"
    ), 
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package", "skeleton"
    ), 
  overwrite = TRUE
)
```

The second template shows how to create a package with a dataset:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package With a Dataset",
  template_dir = "make-an-r-package-with-data",
  template_description = "Template for an Rmd file for writing an R package with a dataset using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "litr-source-files", "make-an-r-package-with-data", "skeleton.Rmd"
    ), 
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-data", "skeleton"
    ), 
  overwrite = TRUE
)
```

The third template shows how to create a package that uses `Rcpp`:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package With Rcpp",
  template_dir = "make-an-r-package-with-rcpp",
  template_description = "Template for an Rmd file for writing an R package that makes use of Rcpp while using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "litr-source-files", "make-an-r-package-with-rcpp", "skeleton.Rmd"
    ),
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-rcpp", "skeleton"
    ),
  overwrite = TRUE
)
```

The fourth template shows how to create a package that uses chunk references to help explain a function works:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package With Chunk References",
  template_dir = "make-an-r-package-with-chunk-references",
  template_description = "Template for an Rmd file for writing an R package that makes use of chunk references for explaining a function in the style of literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "litr-source-files", "make-an-r-package-with-chunk-references", "skeleton.Rmd"
    ),
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-chunk-references", "skeleton"
    ),
  overwrite = TRUE
)
```

## Including README

We include a `README.Rmd` and then generate the `README.md` based on it:

```{r}
usethis::use_readme_rmd(open = FALSE)
fs::file_copy(
  path = file.path("..", "litr-source-files", "README.Rmd"), 
  new_path = "README.Rmd", 
  overwrite = TRUE
)
xfun::Rscript_call(
  rmarkdown::render,
  args = list(
    input = "README.Rmd",
    output_options = list(html_preview = "false")
    )
  )
```


## Defining some tests {#tests}

When using `litr` to create packages that are not `litr`, one should be able to run tests along the way as we did above in testing the function `add_text_to_file()`.  However, creating `litr` is a special case so we need to do something different for the tests that involve creating a .Rmd from template and then calling `litr::render()` on them (such as the tests in this section).  In particular, we use `eval=FALSE` for these code blocks and then at the end of this document we will install the newly created version of `litr` and then call `devtools::test()`.  Doing it this way is important for ensuring that the version of `litr` we are testing is the newest version, i.e. the version defined in this document.

To understand the reason we are doing it this way, imagine what would happen if instead we left `eval=TRUE` in the test in the [next section](#test-check-unedited).  When we use `rmarkdown::draft()` to create a .Rmd file from template, the file it will give us will be an old version (namely the installed version of `litr`'s template) rather than the latest version.^[If this were the only problem, we could get around this by using `pkgload::package_file()` to get the proper file; however, the next problem discussed was something that seemed quite hard to resolve.] Furthermore, consider what happens when we call `render()` in the test below.  This will start the knitting process on `my-package.Rmd`.  However, inside `my-package.Rmd`, we have `litr::setup()` and `litr::document()`.  When these are called in the knitting process, it will be the versions of the functions from the currently installed `litr` rather than the versions defined in this document.

Once we are done testing the new version of the package, we'd like to restore the state of `litr` to what it was previously.  If we don't do this, then this can lead to inadvertent circularity in which the next time we call `litr::render("create-litr.Rmd")`, we are using the version currently under development, which is bad because ultimately we need this version to be rendered by the previous version of `litr`.  The following function implements this approach to testing `litr`: 

```{r}
#' Run tests for `litr` itself
#' 
#' Special function for testing `litr`.  The trick is to temporarily install
#' the new version of `litr`, run the test, and then put things back how it was
#' before.
#' 
#' Typical values for `install_old` could be
#' - `function() devtools::install("[location of old version]")`
#' - `function() remotes::install_github("jacobbien/litr-project@*release", subdir = "litr")`.
#' 
#' @param install_old A function that when run will install the old version
#' @param location_of_new Path to the new package directory
#' @export
test_litr <- function(install_old, location_of_new) {
  devtools::install(location_of_new)
  out <- devtools::test(location_of_new)
  install_old()
  return(out)
}
```

### Testing `check_unedited()` {#test-check-unedited}

For our tests, we create a temporary directory (which we delete at the end).  In this directory, we create a generating .Rmd file from one of the templates.  We make repeated modifications to the package and each time verify that `check_unedited()` is `FALSE` with the modification and returns to `TRUE` when we put things back how they were.  The modifications we try are the following:

- Adding a file

- Removing a file

- Making a change to a file (in particular, adding a comment to an R file)

- Changing something in the DESCRIPTION file (but not on the special `litr` line)

- Changing the `litr` hash line itself

```{r, eval=FALSE}
testthat::test_that("check_unedited works", {
  # Including this next line seems to be necessary for R CMD check on the cmd line:
  #Sys.setenv(RSTUDIO_PANDOC = "/Applications/RStudio.app/Contents/MacOS/pandoc")
  dir <- tempfile()
  fs::dir_create(dir)
  rmd_file <- file.path(dir, "my-package.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package",
                   package = "litr",
                   edit = FALSE)
  # create R package (named "rhello") from the Rmd template:
  render(rmd_file)
  package_path <- file.path(dir, "rhello")
  testthat::expect_true(check_unedited(package_path))

  # what if a file has been added?
  added_file <- file.path(package_path, "R", "say_hello2.R")
  writeLines("# Added something here.", added_file)
  testthat::expect_false(check_unedited(package_path))

  # what if we now remove it?
  fs::file_delete(added_file)
  testthat::expect_true(check_unedited(package_path))

  # what if a file is removed from package?
  rfile <- file.path(package_path, "R", "say_hello.R")
  fs::file_move(rfile, dir)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  fs::file_move(file.path(dir, "say_hello.R"), file.path(package_path, "R"))
  testthat::expect_true(check_unedited(package_path))

  # what if something is changed in a file?
  txt <- readLines(rfile)
  txt_mod <- txt
  txt_mod[3] <- paste0(txt[3], " # added a comment!!")
  writeLines(txt_mod, rfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, rfile)
  testthat::expect_true(check_unedited(package_path))

  # what if something is changed in the DESCRIPTION file?
  descfile <- file.path(package_path, "DESCRIPTION")
  txt <- readLines(descfile)
  txt_mod <- txt
  txt_mod[1] <- "Package: newname"
  writeLines(txt_mod, descfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, descfile)
  testthat::expect_true(check_unedited(package_path))

  # what if the special litr hash field is changed in the DESCRIPTION file?
  txt <- readLines(descfile)
  i_litr <- stringr::str_which(txt, description_litr_hash_field_name())
  txt_mod <- txt
  txt_mod[i_litr] <- paste0(txt_mod[i_litr], "a")
  writeLines(txt_mod, descfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, descfile)
  testthat::expect_true(check_unedited(package_path))

  fs::dir_delete(dir)
})
```

### Testing `get_params_used()`

Let's now test the `get_params_used()` function, making sure it behaves how we expect it to:

```{r, eval=FALSE}
testthat::test_that("get_params_used works", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  rmd_file <- file.path(dir, "my-package.Rmd")
  rmarkdown::draft(rmd_file, template = "make-an-r-package", package = "litr",
                   edit = FALSE)
  default_params <- get_params_used(rmd_file, passed_params = list())
  testthat::expect_equal(
    default_params,
    rmarkdown::yaml_front_matter(rmd_file)$params
  )
  params1 <- default_params
  params1$package_parent_dir <- "dir"
  testthat::expect_equal(
    get_params_used(rmd_file, passed_params = list(package_parent_dir = "dir")),
    params1
  )
  params2 <- default_params
  params2$package_name <- "pkg"
  params2$package_parent_dir <- "dir"
  testthat::expect_equal(
    get_params_used(rmd_file,
                    passed_params = list(package_parent_dir = "dir",
                                         package_name = "pkg")),
    params2
  )
  fs::dir_delete(dir)
})
```

### Testing other templates

Let's now make sure that each template can be knit without error.

```{r, eval=FALSE}
testthat::test_that("templates can be knit", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  
  rmd_file <- file.path(dir, "create-rhello.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-rhello.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "rhello")))

  rmd_file <- file.path(dir, "create-rhasdata.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package-with-data",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-rhasdata.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "rhasdata")))

  rmd_file <- file.path(dir, "create-withrcpp.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package-with-rcpp",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-withrcpp.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "withrcpp")))
  
  fs::dir_delete(dir)
 })
```

Even though `litr` doesn't directly use `Rcpp`, we'll add it as a "Suggests" package since it would be required for running the above test.

```{r}
usethis::use_package("Rcpp", type = "Suggests")
```


## Documenting the package and testing

We finish by running commands that will document and test `litr`.

**The formatting of the test output does not print out very neatly.**


**Also, once we make the repo public, we will not need the `auth_token`.**

We download the latest release:

```{r}
rm(list = ls())
litr::document()
install_old <- function() {
  remotes::install_github("jacobbien/litr-project@*release", subdir = "litr",
                          auth_token = gitcreds::gitcreds_get(use_cache=FALSE)$password
                          )
#  devtools::install("~/Downloads/litr-project-0.0.2/litr/")
}
xfun::Rscript_call(test_litr,
                   list(install_old = install_old, location_of_new = "."))
```

## Add examples folder with the output of knitting each example

In this section, we will litr-knit each template and put the outputs in an examples directory that lives outside of the `litr` R package.  These examples are linked to in `README.Rmd`.

```{r}
build_all_templates <- function(install_old, location_of_new) {
  devtools::install(location_of_new)

  example_dir <- file.path("..", "examples")
  if (fs::dir_exists(example_dir)) fs::dir_delete(example_dir)
  fs::dir_create(example_dir)
  
  templates <- fs::path_file(fs::dir_ls("inst/rmarkdown/templates"))
  for (template in templates) {
    tmp_file <- file.path(example_dir, "temp.Rmd")
    rmarkdown::draft(tmp_file, template, package = "litr", edit = FALSE)
    pkg_name <- rmarkdown::yaml_front_matter(tmp_file)$params$package_name
    rmd_file <- file.path(example_dir, paste0("create-", pkg_name, ".Rmd"))
    fs::file_move(tmp_file, rmd_file)
    render(rmd_file)
    # move to a template-specific directory:
    template_dir <- file.path(example_dir, template)
    fs::dir_create(template_dir)
    fs::file_move(fs::dir_ls(example_dir, regexp = pkg_name), template_dir)
  }

  install_old()
}
```

```{r}
xfun::Rscript_call(build_all_templates,
                   list(install_old = install_old, location_of_new = "."))
```

