---
title: "Create the ``r params$package_name`` R package"
author: "Jacob Bien"
date: "May 27, 2022"
knit: litr::render
params:
  package_name: "litr"
  package_parent_dir: "." # <-- relative to this file's location
---

*[This file was litr-knitted using `litr` version `r utils::packageVersion("litr")`]*

The `litr` package allows one to define an R package by writing an R markdown file.  The package consists of (a) document templates that users can use as the basis for creating an R package, (b) code needed so that when such a R markdown file is knitted, it will generate not just an .html but also an R package.   The code has the following components:

1. [Functionality for generating the R package when the .Rmd file is knitted.](#generating-package)  In particular, we define a `knitr` [chunk hook](https://bookdown.org/yihui/rmarkdown-cookbook/chunk-hooks.html), which we call `send_to_package()` that identifies code chunks in the .Rmd file that should be included in the package.  To make it so that this chunk hook will be active, we also have a function called `setup()` that is called at the start of `litr::render()` right before `rmarkdown::render()` is called.  The `setup()` function makes it so that when the .Rmd file is knitted, the chunk hook `send_to_package()` will be invoked on each code chunk.  It is also responsible for other preliminaries, such as defining a new `knitr` language engine that can interpret package-level documentation.

2. [Functionality for making sure the R package outputted will not overwrite a manually edited R package.](#hash)  Our approach here is to use a hash that will make it clear whether something has been modified.

3. [Wrappers to `devtools::document()` and `rmarkdown::render()`.](#wrappers)  The reason we write wrappers is because we want a few extra things to happen.  For example, `devtools::document()` reminds the reader to edit the roxygen in the `R/` files, whereas in our case, we want to make sure they edit the original .Rmd file, not the `R/` files.  Likewise, `litr::render()` sets up all the special functionality of sending code chunks to the R package before calling `rmarkdown::render()` and also adds hyperlinks to the .html file that make it easy to navigate to function definitions.

## Package setup

We start by specifying the information needed in the DESCRIPTION file of the R package. We mostly follow [the R Packages book](https://r-pkgs.org/lifecycle.html#sec-release-version)'s description of version numbering.  Releases 0.0.1, 0.0.2, and 0.0.3 should really have been 0.1.0, 0.2.0, and 0.3.0, because these were not just patches.  Rather, each added quite substantial new functionality.  For this reason, we have gone straight from 0.0.3 to 0.4.0.   We will keep the rightmost number ("major release") at 0 until we feel like the package is complete with all the intended features.

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.4.0",
    Title = "Literate Programming for Writing R Packages",
    Description = "Allows one to fully create an R package in a single .Rmd 
    file.  Includes functionality and .Rmd templates for a literate programming
    approach to R package development.",
    `Authors@R` = person(
      given = "Jacob",
      family = "Bien",
      email = "jbien@usc.edu",
      role = c("aut", "cre")
      )
   )
 )

usethis::use_mit_license(copyright_holder = "J. Bien")
```

Let's add some package-level documentation.  This is what will show up when someone types `package?litr` in the console.

```{package_doc}
#' Literate Programming for Writing R Packages
#'
#' Allows one to fully create an R package in a single .Rmd file.  Includes
#' functionality and .Rmd templates for a literate programming approach to R
#' package development.
#' 
#' @examples
#' # Make a file create-rhello.Rmd based on a template
#' \dontrun{
#' rmarkdown::draft("create-rhello.Rmd", 
#'                  template = "make-an-r-package",
#'                  package = "litr",
#'                  edit = FALSE)
#' # Now call litr::render (or press Knit if in RStudio) to generate not just
#' # create-rhello.html, but also an R package called `rhello`.
#' litr::render("create-rhello.Rmd")
#' }
#' @docType package
#' @seealso \code{\link{render}}
```

## A note on circularity

Keeping track of the version of `litr` used is particularly important when using `litr` to develop `litr`.  There is a tendency to want to use the new functionality that we are creating in `create-litr.Rmd` itself as soon as we have defined it.  However, this is circular and thus must be avoided.  To see why we need to be careful, let's consider an actual example that arose when working on `litr` version `0.0.3`.  After release `v0.0.2`, one of the new features we added is a new language engine called `package_doc` that allows us to have a special kind of code block defining the package documentation.  In trying out this feature and making sure it works on `skeleton.Rmd`, we would most likely install version `0.0.3`.  Now that version `0.0.3` is installed, there will be a tendency to want to add a `package_doc` block to `create-litr.Rmd`, and it will appear to work.  However, this is circular, because we have used version `0.0.3` to create version `0.0.3`!  In particular, if we remove `litr` and re-install it from github, we will get version `0.0.2` so that when we attempt to create the package using `litr::render("create-litr.Rmd")`, we will get an error telling us that it doesn't have a language engine named `package_doc`.

The code chunk in this section is for preventing this from happening.

For more on circularity, see the section on [testing litr](#tests).

```{r}
install_version_of_litr <- utils::packageVersion("litr")
remote <- remotes::github_remote(
  repo = "jacobbien/litr-project@*release",
  subdir = "litr"
  )
version_of_latest_release <- stringr::str_remove(remote$ref, "v")
if (install_version_of_litr != version_of_latest_release)
  stop(stringr::str_glue(
    "You should be using the version of litr from the latest release (version",
    " {version_of_latest_release}),\n but you are using version",
    " {install_version_of_litr}."
  ))
```

## Now to the package itself

### Generating the R package {#generating-package}

#### Sending code chunks to the package

We start by defining a [chunk hook](https://bookdown.org/yihui/rmarkdown-cookbook/chunk-hooks.html), which is a function that runs both before and after each code chunk is run in the knitting process.  In this case, the function (called `send_to_package`) is responsible for determining whether the code chunk looks like something that should be exported to the R package.  We don't want all code sent off to our R package.  For example, sometimes we'll want to demonstrate in the Rmd file how a certain function we've just created is used by running it on an example or making a plot.  That bit of example code would not be included in the package.

We start by making sure that code is only sent to the R package once (arbitrarily we have code outputted to the package *before* and not after the chunk is run).

The function then checks if this code chunk is code that should be put into the package.  There are three specific cases it considers:

1. Is it a piece of code to be sent to the `R/` directory?  In particular, it checks to see if the code chunk begins with the characteristic [roxygen2](https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html) characters `#'`.  If it does, then the name of the object being documented is identified (could be a function, a dataset, an S4 object, etc.) and then we write the code chunk to the file `R/<objectname>.R`.

2. If the code chunk does not start with `#'`, then we check if it has any line starting with `test_that(` or `testthat::test_that(`.  If so, then this whole code chunk is appended to `tests/testthat/tests.R` (and this file is created the first time a test chunk is sent to the package).

3. Next, it checks if the language engine is `Rcpp`.  This occurs when the code chunk starts with `{Rcpp`, rather than the usual `{r` (or alternatively when the `engine="Rcpp"` option is used).  We then invoke `usesthis::use_rcpp()` to set things up appropriately for the use of `Rcpp` within the package.  Finally, we write the code chunk to `src/code.cpp`.  There is a common header used,

```Rcpp
#include <Rcpp.h>
using namespace Rcpp;
```

and we only want this to appear once in `code.cpp`, so we do a bit of work to remove that if it appears in the code chunk.


```{r}
#' A knitr chunk hook for writing R code and tests
#' 
#' This chunk hook detects whether a chunk is defining a function or dataset
#' to be included in the R package (looks for the Roxygen2 comment format `#' `).
#' If so, then it is written to the `R/` directory.  It also looks for chunks 
#' that have one or more lines that start with `test_that(` or 
#' `testthat::test_that(` (potentially with some leading whitespace).  These 
#' chunks are then written to the `tests` directory of the R package.
#' 
#' @param before Indicates whether this is being called before or after the 
#' chunk code is executed
#' @param options Has information from the chunk
#' @param envir Environment
#' @export
send_to_package <- function(before, options, envir) {
  msg <- do_not_edit_message(knitr::current_input(), type = "R")
  if (before == FALSE) {
    # Don't do anything after the code chunk has been executed.
    return()
  }
  if (stringr::str_detect(options$code[1], "^#' ")) {
    # starts with roxygen2, so let's assume this chunk is defining an R function
    # or dataset that belongs in the package
    non_comment <- stringr::str_subset(options$code, "^#", negate = TRUE)
    if (length(non_comment) > 0) {
      if (stringr::str_detect(non_comment[1], "<-")) {
        # a function is being defined
        objname <- stringr::str_match(non_comment[1], "^(.*)\\s*<-\\s*function")[, 2]
        objname <- stringr::str_trim(objname)
      } else if (stringr::str_detect(non_comment[1], '^".+"$')) {
        # a dataset is being documented
        objname <- stringr::str_sub(non_comment[1], start = 2, end = -2)
      } else {
        # Roxygen2 comment wasn't followed by anything recognized, so do not 
        # send this to package
        return()
      }
      file <- file.path(envir$package_dir, "R", stringr::str_glue("{objname}.R"))
      cat(paste(c(msg, "", options$code, ""), collapse = "\n"), file = file)
    }
  }
  else if (any(stringr::str_detect(options$code,
                                   "^\\s*(testthat::)?test_that\\("))) {
    # This chunk is inferred to be a test
    test_dir <- file.path(envir$package_dir, "tests", "testthat")
    test_file <- file.path(test_dir, "tests.R")
    if (!file.exists(test_file)) {
      # It's the first chunk with tests
      if (!dir.exists(test_dir)) usethis::use_testthat()
      cat(c(msg, ""), collapse = "\n", file = test_file)
    }
    cat(
      paste(c(options$code, "", ""), collapse = "\n"),
      file = test_file,
      append = TRUE
    )
  } else if (options$engine == "Rcpp") {
    # To add Rcpp code, we need the package documentation file to exist 
    if (!file.exists(file.path(
      envir$package_dir,
      "R",
      paste0(envir$package_name, "-package.R"))
      )) {
      usethis::use_package_doc(open = FALSE)
    }
    cpp_file <- file.path(envir$package_dir, "src", "code.cpp")
    if (!file.exists(cpp_file)) {
      # set up package for Rcpp
      usethis::use_rcpp(name = "code")
      msg <- do_not_edit_message(knitr::current_input(), type = "c")
      cat(msg, file = cpp_file, append = TRUE)
    }
    # append code to code.cpp, but remove lines that are `#include <Rcpp.h>`
    # or `using namespace Rcpp;` since this already appears at top of file
    cat(paste(c(
      "",
      stringr::str_subset(
        options$code,
        r"(^#include <Rcpp.h>$|^using namespace Rcpp;$)",
        negate = TRUE),
      ""), collapse = "\n"), 
        file = cpp_file,
        append = TRUE)
  }
  return()
}
```

The above code makes use of a number of functions from the `stringr` and `usethis` packages, so we'll need to add those packages to the `Imports` section of the `DESCRIPTION` file:

```{r}
usethis::use_package("stringr")
usethis::use_package("usethis")
```

The code also calls the function `do_not_edit_message()`, which adds a line at the top of the files sent to the R package reminding the user that these are not source files to be edited but rather output of the generating .Rmd file.  There are two variations on this message.

```{r}
#' Generate do-not-edit message to put at top of file
#' 
#' @param rmd_file Name of the Rmd file to mention
#' @param type Whether this is a R/ file, man/ file, or a c file
do_not_edit_message <- function(rmd_file, type = c("R", "man", "c")) {
  if (type[1] == "R")
    return(stringr::str_glue("# Generated from {rmd_file}: do not edit by hand"))
  else if (type[1] == "man")
    return(stringr::str_glue("% Please edit documentation in {rmd_file}."))
  else if (type[1] == "c")
    return(stringr::str_glue("// Generated from {rmd_file}: do not edit by hand"))
  else
    stop("type must be either 'R', 'man', or 'c'.")
}
```

This function will also be used with `type = "man"` by `litr::document()`.

The above also makes use of a simple helper function that inserts text into a specified location of a file (or creates that file if it doesn't exist). **Actually currently it doesn't, but we can replace `cat()` in the above with calls to `add_text_to_file()`.**

```{r}
#' Add Some Text to a File
#' 
#' The text will be added to the file at a particular line specified by
#' `location`.  The first line of `txt` will be on line `location` of the
#' modified file.  If `location` is NULL, then text is added to end of file.
#' If file does not exist, it is created and `location` is ignored (unless 
#' `req_exist` is `TRUE`, in which case an error is thrown).
#' 
#' @param txt Character vector to add to file
#' @param filename Name of file
#' @param location Specifies where text should be added. See description for more.
#' @param req_exist If TRUE, then 
#' @export
add_text_to_file <- function(txt, filename, location = NULL, req_exist = FALSE) {
  if (!file.exists(filename)) {
    if (req_exist) stop(stringr::str_glue("Cannot find file {filename}."))
    writeLines(txt, con = filename)
    return()
  }
  filetxt <- readLines(filename)
  if (is.null(location) || location == length(filetxt) + 1) {
    filetxt <- c(filetxt, txt)
  }
  else if (location > length(filetxt) + 1 | location < 1) 
    stop("Invalid location")
  else if (location == 1) {
    filetxt <- c(txt, filetxt)
  } else {
    # location is somewhere in middle
    filetxt <- c(filetxt[1:(location - 1)],
                 txt,
                 filetxt[location:length(filetxt)])
  }
  writeLines(filetxt, con = filename)
}
```

```{r}
testthat::test_that("add_text_to_file() works", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  
  # should throw error when file does not exist and req_exist is TRUE:
  myfile <- file.path(dir, "file.txt")
  sometxt <- c("hello", "there")
  testthat::expect_error(add_text_to_file(sometxt, myfile, req_exist = TRUE))

  # should create a new file where one does not exist:
  myfile <- file.path(dir, "file.txt")
  sometxt <- c("hello", "there")
  add_text_to_file(sometxt, myfile)
  testthat::expect_true(fs::file_exists(myfile))
  testthat::expect_equal(sometxt, readLines(myfile))
  
  # should append to end of file by default
  moretxt <- "world"
  add_text_to_file(moretxt, myfile)
  testthat::expect_equal(c(sometxt, moretxt), readLines(myfile))
   
  # should throw error for invalid locations:
  testthat::expect_error(add_text_to_file(sometxt, myfile, 0))
  testthat::expect_error(add_text_to_file(sometxt, myfile, -1))
  testthat::expect_error(add_text_to_file(sometxt, myfile, 5))

  # should add to specified line:
  moretxt2 <- "hi"
  add_text_to_file(moretxt2, myfile, 1)
  testthat::expect_equal(c(moretxt2, sometxt, moretxt), readLines(myfile))

  # should add to specified line:
  moretxt3 <- "hi2"
  add_text_to_file(moretxt3, myfile, 2)
  testthat::expect_equal(c(moretxt2, moretxt3, sometxt, moretxt),
                         readLines(myfile))

  # should add to specified line:
  moretxt4 <- "hi3"
  add_text_to_file(moretxt4, myfile, 6)
  testthat::expect_equal(c(moretxt2, moretxt3, sometxt, moretxt, moretxt4),
                         readLines(myfile))
  fs::dir_delete(dir)
})
```


#### Setting up the R package creation

When the user calls `litr::render()` (either in the console or by pressing "Knit" in RStudio), one of the first things that function does is to call the function `litr::setup()`, which does several things:

1. Creates a new empty directory at the specified location while first making sure that it won't overwrite something it shouldn't.  In particular, we guard against the case that the package was generated by `litr::render()` but then someone went in manually and made some changes.  Even though users should never manually edit the package that was generated by `litr::render()`, we don't want to have them inadvertently lose their work by doing so.  Thus, we only overwrite an R package if we can tell that it is the unedited output of a call to `litr::render()`.  The function `check_unedited()` is responsible for checking this, and is a pretty interesting function which we will describe in [the next section](#hash).  This part of the code also makes use of a function `litr::make_noticeable()`, which is simply a way of making error messages produced by `litr` more easy to see amid a lot of `knitr` output.

2. Adjusts the root directory from the generating .Rmd file's location to the R package's location. **Note: This behavior might not actually be desirable now that additional files will be loaded in.  It might be awkward for a user writing the generating .Rmd file to have to make everything relative to the package.  It might be convenient to provide a `litr::add_file(from, to)` function, where `from` is the path relative to the .Rmd file and `to` is the path relative to the package's location.**

3. Makes it so that the `send_to_package()` chunk hook is active for each code chunk.  This involves registering a new chunk hook using the function `knitr::knit_hooks$set()` and then setting an option with the same name to `TRUE` within each chunk.

4. Deactivates an internal function of the `usethis` package, `usethis:::challenge_nested_project()`.  This was actually a difficult issue to address that involves the intersection of `usethis`, `here`, and our particular use case.  The problem is that `usethis` was not designed for our setting in which an R package is being created programmatically.  When using `litr`, the project directory will have the generating .Rmd file and when this is knit it will create an R package within this project.  However, this leads `usethis` to prompt the user with a message of the form

> "New project '[...]' is nested inside an existing project '[...]'.  This is rarely a good idea. Do you wish to create anyway?"

But since this is encountered through knitting rather than interactively, this results in an error.  [This](https://github.com/r-lib/usethis/issues/553) `usethis` issue describes this exact problem.  The solution suggested there by jennybc involving `testthat::with_mock()` is along the lines of what we want; however, that would lead to some ugly looking code in the generating .Rmd file.  The best solution I could find was to use `utils::assignInNamespace()` as described [here](https://stat.ethz.ch/pipermail/r-help/2008-August/171215.html).  This function allows us to change the internal function `usethis:::challenge_nested_project()` so that it no longer prompts the user with concerns about nested projects.

5. Changes how [chunk references](https://bookdown.org/yihui/rmarkdown-cookbook/reuse-chunks.html) are handled. In particular, consider the following code chunk:

```
a <- 2
<<my-chunk>>
a
```

The way `knitr` handles this, the code chunk would no longer look like this but it would rather have replaced the `<<my-chunk>>` line by the code that appears in the code chunk labeled "my-chunk".  We instead would like the above code chunk to appear as written and then for the code chunk labeled "my-chunk" to have its label visible to the reader of the .html file.  This gives the coder more control over when the reader learns about different parts of the code.  It also more closely resembles Donald Knuth's form of literate programming.  For convenience, we'd like `<<my-chunk>>` to be a link that navigates to the code chunk labeled "my-chunk".  To accomplish this, we modify the `document` output hook in `setup()` (and then we also add a function called `add_chunk_label_hyperlinks()` within `render()`).

6. Define a `package_doc` engine which allows users to define package-level documentation.

```{r}
#' Code for setup chunk
#' 
#' * Creates directory where package will be. (Deletes what is currently there as 
#' long as it appears to have been created by litr and does not have any 
#' subsequent manual edits.)
#' * Sets the root directory to this directory
#' * Sets up the main chunk hook `litr::send_to_package()` that sends code to the 
#' R package directory.
#' * Deactivates an internal function of the `usethis` package
#' * Redefines the document output hook to handle chunk references differently  
#' * Sets up a [custom language engine](https://bookdown.org/yihui/rmarkdown-cookbook/custom-engine.html) called
#' `package_doc` that creates a package documentation file and then inserts
#' whatever the user puts in the chunk.
#' 
#' @param package_dir Directory where R package will be created
#' @export
setup <- function(package_dir) {
  if (file.exists(package_dir)) {
    unedited <- tryCatch(check_unedited(package_dir),
                         error = function(e) {
                           # contents of package_dir does not resemble
                           # a litr package
                           return(FALSE)
                         })
    if (!unedited) {
      stop(make_noticeable(paste(
        stringr::str_glue("The directory {normalizePath(package_dir)}"),
        "already exists and either was not created by litr or may have manual",
        "edits. In either case, please rename that directory (or delete it)", 
        "and then try again.", 
        sep = "\n")))
    }
    unlink(package_dir, recursive = TRUE)
  }
  fs::dir_create(package_dir)
  knitr::opts_knit$set(root.dir = package_dir) # sets wd of future chunks
  knitr::knit_hooks$set(send_to_package = send_to_package)
  knitr::opts_chunk$set(send_to_package = TRUE)
  
  # change usethis:::challenge_nested_project so that it will not complain
  # about creating a nested project (e.g. if this is called within a git 
  # subdirectory)
  utils::assignInNamespace("challenge_nested_project", function(...) NULL, ns = "usethis")
  # change usethis:::use_src_example_script so that it will not cause an error
  utils::assignInNamespace("use_src_example_script", 
                           function(...) {
                             usethis::use_template("code.cpp",
                                                   fs::path("src", "code.cpp"))
                           }, ns = "usethis")
  
  # define document hook to handle chunk references:
  knitr::knit_hooks$set(document = function(x) {
    # get the indices of x corresponding to code chunks
    chunk_start <- "^(\n```+[a-zA-Z0-9_]+\n)"
    idx_block <- stringr::str_which(x, chunk_start)
    original_code <- knitr::knit_code$get()
    labels <- names(original_code)
    # replace each x[i] that has code in it with the original code
    for (i in seq_along(idx_block)) {
      # break code into multiple lines:
      chunk <- strsplit(x[idx_block[i]], "\n")[[1]]
      # get the fence used (in case it's more than three ticks):
      i_start <- stringr::str_which(chunk, "^```+[a-zA-Z0-9_]+")
      fence <- stringr::str_replace(chunk[i_start[1]],
                                    "^(```+)[a-zA-Z0-9_]+", "\\1")
      i_fences <- stringr::str_which(chunk, paste0("^", fence))
      # there can be multiple code and output chunks strung together 
      # within a single x[i] if results are not held to end
      i_all_code <- c()
      for (j in seq_along(i_start)) {
        # get the elements corresponding the j-th code chunk within chunk
        i_code_end <- i_fences[which(i_fences == i_start[j]) + 1]
        i_all_code <- c(i_all_code, i_start[j]:i_code_end)
      }
      i_all_code <- setdiff(i_all_code, i_start[1])
      chunk_no_code <- chunk[-i_all_code]
      chunk <- c(chunk_no_code[1:i_start[1]],
                 original_code[i][[1]], # insert the original version
                 fence)
      if (i_start[1] < length(chunk_no_code))
        chunk <- c(chunk, chunk_no_code[(i_start[1] + 1):length(chunk_no_code)])
        x[idx_block[i]] <- paste(chunk, collapse = "\n")
    }
    
    # replace code chunks with the original code
    # (so we'll still have <<label>> chunk references)
    refs <- c() # labels that get referred to
    for (label in labels) {
      refs <- c(refs, find_labels(original_code[[label]])$chunk_ids)
    }
    refs <- unique(refs)
    ref_id <- match(refs, labels)
    to_insert <- paste0('###"', labels[ref_id], '"###\n')
    x[idx_block[ref_id]] <- stringr::str_replace(x[idx_block[ref_id]],
                                                 chunk_start,
                                                 paste0("\\1", to_insert))
    x
  })

  # setup package_doc engine
  knitr::knit_engines$set(package_doc = function(options) {
    # create package_doc
    usethis::use_package_doc(open = FALSE)
    
    # insert the contents of the code chunk into the package_doc
    pkgdoc <- file.path("R", paste0(fs::path_file(package_dir), "-package.R"))
    add_text_to_file(options$code, filename = pkgdoc, location = 1)
    
    # now treat this as if it were standard R code with eval=FALSE
    r_engine <- knitr::knit_engines$get("R")
    options[["eval"]] <- FALSE
    return(r_engine(options))
  })

}
```

In our new `document` output hook defined above, we call a function `find_labels()`.  It takes a block of code and returns both a logical vector of which lines contained chunk labels and another vector containing the labels of those referenced chunks.  We define it here:

```{r}
#' Find a .Rmd chunk label in a code chunk
#' 
#' @param chunk_code Character vector of code from a .Rmd code chunk. Each element is a line of the code chunk.
#' @return List where chunk_idx is a logical vector for each line of the chunk corresponding to whether a chunk label of the form `<<label>>` was found and chunk_ids is a character vector of chunk label was found in that chunk.
find_labels <- function(chunk_code) {
  rc <- knitr::all_patterns$md$ref.chunk
  chunk_idx <- any(idx = grepl(rc, chunk_code))
  chunk_ids <- stringr::str_trim(sub(rc, "\\1", chunk_code[grepl(rc, chunk_code)]))
  return(list(chunk_idx = chunk_idx, chunk_ids = chunk_ids))
}
```


The `setup()` function also uses a small function, `make_noticeable()`, which we define here:

```{r}
#' Make error messages noticeable
#' 
#' Since litr error messages are amid a lot of output from knitting, we'd like 
#' the litr ones to be eye-catching.
#' 
#' @param msg Error message
make_noticeable <- function(msg) {
  paste("",
        "======",
        "Please read your friendly litr error message here:",
        paste("> ", msg),
        "======",
        sep = "\n")
}
```

The code in this section used the `fs` and `knitr` packages, so we import those:

```{r}
usethis::use_package("fs")
usethis::use_package("knitr")
```


### Not overwriting a manually edited R package {#hash}

As described in the previous section, the function `setup()` will only overwrite a directory if it is the unedited output of a call to `litr::render()`.  The basic idea is that the function `litr::render()` when creating a new package finishes by adding a hash to the DESCRIPTION file.  This hash is a function of everything in the package, so if anything about the package changes (any file is modified, added, or removed) then the function `check_unedited()` will be able to detect that by recomputing the hash and seeing that it doesn't match the hash in the DESCRIPTION file.

Let's start by defining the function `hash_package_directory()` that does the hashing.  The hash is a function of everything in the outputted package *except for that special line in the DESCRIPTION file with the hash*.  We use `tools::md5sum()` and `digest::digest()` to do the hashing.

```{r}
#' Hash package directory
#' 
#' Gets an identifier that can be used to uniquely (whp) identify the current 
#' state of the package. This is formed by ignoring the `LitrId` field of the
#' DESCRIPTION file, which is the location where the output of this function is 
#' stored when `litr::render` generates the package.
#' 
#' @param package_dir Path to package
hash_package_directory <- function(package_dir) {
  pkg_files <- fs::dir_ls(package_dir, recurse = TRUE, all = TRUE, type = "file")
  pkg_files <- stringr::str_subset(pkg_files, ".DS_Store$", negate = TRUE)
  pkg_files <- normalizePath(pkg_files)
  descr_file <- normalizePath(file.path(package_dir, "DESCRIPTION"))
  i_descr <- which(pkg_files == descr_file)
  if (length(i_descr) == 0) stop("Cannot find DESCRIPTION file.")
  txt_descr <- readLines(pkg_files[i_descr])
  txt_descr_mod <- stringr::str_subset(
    txt_descr, 
    stringr::str_glue("{description_litr_hash_field_name()}: .+$"),
    negate = TRUE)
  hashes <- as.character(tools::md5sum(pkg_files[-i_descr]))
  digest::digest(c(hashes, list(txt_descr_mod)))
}
```

We used `digest`, so let's import it:

```{r}
usethis::use_package("digest")
```

We will store this hash in a special field within the DESCRIPTION file.  Let's call this field `LitrId`.  However, in case we ever decide to change the name of this field, it's better that we only define it in one place.  So we do this with the following function:

```{r}
#' Generate litr hash field name for DESCRIPTION file
description_litr_hash_field_name <- function() return("LitrId")
```

Ok, now let's write the function that `litr::render()` will call that will take the generated R package and add a line that puts the hash in the DESCRIPTION file under that special `litr` field:

```{r}
#' Write the hash of the package to the DESCRIPTION file
#' 
#' @param package_dir Path to package
write_hash_to_description <- function(package_dir) {
  hash <- hash_package_directory(package_dir)
  add_text_to_file(
    txt = stringr::str_glue("{description_litr_hash_field_name()}: {hash}"),
    filename = file.path(package_dir, "DESCRIPTION"),
    req_exist = TRUE
    )
}
```

And of course we'll need a way a function that can read the value of that field as well:

```{r}
#' Get the hash of the package from the DESCRIPTION file
#' 
#' @param package_dir Path to package
read_hash_from_description <- function(package_dir) {
  descr <- file.path(package_dir, "DESCRIPTION")
  if (!file.exists(descr)) stop("Cannot find DESCRIPTION file.")
  txt <- stringr::str_subset(
    readLines(descr), 
    stringr::str_glue("{description_litr_hash_field_name()}: .+$"))
  if (length(txt) > 1) stop("More than one hash found in DESCRIPTION.")
  if (length(txt) == 0) stop("No hash found in DESCRIPTION.")
  stringr::str_extract(txt, "\\S+$")
}
```

With all this hash functionality in place, the function `check_unedited()` is actually quite simple to define:

```{r}
#' Check if package directory is the unedited output of litr::render()
#' 
#' Uses hash stored in a special `litr` field of DESCRIPTION file to check that 
#' the current state of the R package directory is identical to its state at the
#' time that it was created by `litr::render()`.
#' 
#' @param package_dir Path to package
#' @export
check_unedited <- function(package_dir) {
  hash <- hash_package_directory(package_dir)
  hash == read_hash_from_description(package_dir)
}
```

It simply computes the hash of the current package and checks whether that hash is the same as what was originally written to the DESCRIPTION file by `litr::render()`.

### Keeping track of what version of `litr` was used to create package

For the sake of reproducibility, it will be useful to record the version of `litr` used to create a package.  We will do this by adding a field to the DESCRIPTION file.

```{r}
#' Generate litr version field name for DESCRIPTION file
description_litr_version_field_name <- function() return("LitrVersionUsed")
```

```{r}
#' Write the version of litr used to the DESCRIPTION file
#' 
#' @param package_dir Path to package
write_version_to_description <- function(package_dir) {
  ver <- as.character(utils::packageVersion("litr"))
  add_text_to_file(
    txt = stringr::str_glue("{description_litr_version_field_name()}: {ver}"),
    filename = file.path(package_dir, "DESCRIPTION"),
    req_exist = TRUE
    )
}
```


### Wrappers to `devtools::document()` and `rmarkdown::render()` {#wrappers}

#### Defining `litr::document()`

This function is nearly identical to `devtools::document()` except that it changes the roxygen2 message that says "Please edit documentation in R/[...].R" to instead mention the generating .Rmd file.

```{r}
#' Use roxygen to document a package
#' 
#' This is a wrapper for the `devtools::document()` function, which in turn is a
#' wrapper for the `roxygen2::roxygenize()` function.  The purpose for `litr` 
#' having this wrapper is to make one modification.  In particular, the line
#' in the outputted `Rd` files should not say "Please edit documentation in 
#' R/file.R" but instead should refer to the Rmd file that generates everything. 
#' 
#' @param ... Arguments to be passed to `devtools::document()`
#' @export
document <- function(...) {
  devtools::document(...)
  # remove the line of the following form in each man/*.Rd file:
  pattern <- "% Please edit documentation in .*$"
  msg <- do_not_edit_message(knitr::current_input(), type = "man")
  for (fname in fs::dir_ls("man")) {
    txt <- stringr::str_replace(readLines(fname), pattern, msg)
    cat(paste(txt, collapse = "\n"), file = fname)
  }
}
```

We used `devtools`, so let's import it:

```{r}
usethis::use_package("devtools")
```

#### Defining `litr::render()`

This function does a number of things:

1. Calls `setup()`, which creates the R package directory and makes it so that when we knit the file using `rmarkdown::render()`, a lot of special things will happen, such as code being sent to the R package directory.

2. Calls `rmarkdown::render()`.  This is done in a very particular way [as described in the Rmarkdown Cookbook](https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-render.html) that ensures the identical behavior to when one clicks the "Knit" in RStudio.  In particular, we have a fresh R session opened in which first `setup()` and then `rmarkdown::render()` are called.

3. If a .html file was created by the previous call, we call a function `add_function_hyperlinks()` that processes this .html file, making it so that one can easily navigate to function definitions within the .html file.  (This function is described lower in this section.)  We likewise call a function `add_chunk_label_hyperlinks()`, which makes chunk references into clickable links.  In particular, the chunk reference `<<my-chunk>>` within a code chunk would link to a chunk named "my-chunk" that begins with `###"my-chunk"###`.  The `###"my-chunk"###` line is added by a document hook defined in `setup()`.

4. Adds a field to the DESCRIPTION file giving the version of `litr` used to generate this package.  This will be useful for reproducibility.

5. Writes the special `litr` hash (as already described [here](#hash)).  Before we can write the hash, we need to determine the location of the outputted package.  The location of the package is specified as parameters in the YAML header of the generating .Rmd file; however, these parameter values can be overridden within a call to `render` if one passes any of these parameters as arguments. The function `get_params_used()`, defined at the end of this section, gets the actual parameters that are used so that the location of the outputted package can be found.

```{r}
#' Render R markdown file
#' 
#' Wrapper to `rmarkdown::render` that does some post-processing on the html 
#' file when that is the output.  In particular, when an html file is among the 
#' outputs, it adds hyperlinks to functions defined within the file to make it 
#' easier for someone reading the code to see where different functions are
#' defined.
#' 
#' @param input The input file to be rendered (see `rmarkdown::render`)
#' @param ... Additional parameters to pass to `rmarkdown::render`
#' @export
render <- function(input, ...) {
  # call rmarkdown::render in a new environment so it behaves the same as 
  # pressing the knit button in RStudio:
  # https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-render.html

  args <- list(...)
  params <- get_params_used(input, args$params)
  package_dir <- ifelse(
    params$package_parent_dir == ".",
    file.path(dirname(input), params$package_name),
    file.path(dirname(input), params$package_parent_dir, params$package_name)
  )
  args$package_dir <- package_dir

  render_ <- function(input, package_dir, ...) {
    litr::setup(package_dir)
    rmarkdown::render(input, ...)
  }

  out <- xfun::Rscript_call(render_, c(input = input, args))

  # add hyperlinks within html output to make it easier to navigate:
  if (any(stringr::str_detect(out, "html$"))) {
    html_file <- stringr::str_subset(out, "html$")
    add_function_hyperlinks(html_file)
    add_chunk_label_hyperlinks(html_file)
  }
  
  # add to DESCRIPTION file the version of litr used to create package:
  write_version_to_description(package_dir)
  
  # add litr hash so we can tell later if package files were manually edited:
  write_hash_to_description(package_dir)
}
```

**Note: When `litr::render()` encounters an error, it can leave the output directory partially modified but without an updated hash.  As a result, the next time one calls `litr::render()` it does not allow this directory to be overwritten.  This behavior should be fixed by wrapping the `xfun::Rscript_call` in a tryCatch and then if there's an error either (a) deleting everything that had been partially created or (b) writing the hash based on the current state.  Of course, if the DESCRIPTION file doesn't exist then this wouldn't work.**

We used the package `xfun`, so let's import it:

```{r}
usethis::use_package("xfun")
```

The function `add_function_hyperlinks()` looks for text of the form `foo <- function(` and then wraps `foo` in a `span` tag with `id="foo"` and then whenever `foo` is found it wraps a `a href="#foo"` tag so that it will be a hyperlink to `foo`'s definition.

```{r}
#' Add hyperlinks to function definitions
#' 
#' Finds functions that are defined in the html file by looking for text of the 
#' form `foo <- function(` and then wraps `foo` in a `span` tag with `id="foo"` 
#' and then whenever `foo` is found it wraps a `a href="#foo"` tag so that it be
#' a hyperlink to `foo`'s definition.
#' 
#' @param html_file File name of html file that was created from Rmd file
#' @param output_file File name to output to. Default: `html_file`
#' @export
add_function_hyperlinks <- function(html_file, output_file = html_file) {
  txt <- readLines(html_file)
  start_line <- which(txt == "<body>")
  pattern <- "([a-zA-Z0-9_.]+)(\\s*&lt;-\\s*function)"
  # find functions that are defined in this file:
  function_names <- character(0)
  for (i in seq(start_line + 1, length(txt))) {
    fn_name <- stringr::str_match(txt[i], pattern)[, 2]
    if(is.na(fn_name)) next
    # a function was defined in this line, so put a span around it
    txt[i] <- stringr::str_replace(
      txt[i],
      pattern,
      stringr::str_glue("<span id='{fn_name}'>\\1</span>\\2")
    )
    # and keep track of it for later:
    function_names <- c(function_names, fn_name)
  }
  
  # whenever one of these named functions is named, link to its definition
  txt <- stringr::str_replace_all(
    txt,
    paste0(function_names, "\\(", collapse = "|"),
    function(x) {
      fn_name <- stringr::str_remove(x, "\\(")
      stringr::str_glue("<a href='#{fn_name}'>{fn_name}</a>(")
    }
  )
  writeLines(txt, con = output_file)
}
```

In addition to adding hyperlinks to function definitions, we also want to add hyperlinks for chunk references of the form `<<foo>>` by wrapping comments of the form `###"foo"###` in a `span` tag with `id="foo"`.

```{r}
#' Add hyperlinks to embedded chunks
#' 
#' Finds chunks that are referenced in the html file by looking for comments
#' of the form `###"foo"###` and then wraps `foo` in a `span` tag with `id="foo"` 
#' and then whenever the chunk label `<<foo>>` is found it wraps it in a 
#' `a href="#foo"` tag so that it will be a hyperlink to `foo`'s definition.
#' 
#' @param html_file File name of html file that was created from Rmd file
#' @param output_file File name to output to. Default: `html_file`
#' @param reference_delim The delimiter used to indicate a chunk label 
#' @export
add_chunk_label_hyperlinks <- function(html_file, output_file = html_file,
                                       reference_start = "&lt;&lt;",
                                       reference_end = "&gt;&gt;"){
  txt <- readLines(html_file)
  start_line <- which(txt == "<body>")
  pattern <- '###&quot;([a-zA-Z0-9-_.]+)&quot;###'
  # find chunks that are defined in this file:
  chunk_names <- character(0)
  for (i in seq(start_line + 1, length(txt))) {
    chunk_name <- stringr::str_match(txt[i], pattern)[, 2]
    if(is.na(chunk_name)) next
    # a function was defined in this line, so put a span around it
    txt[i] <- stringr::str_replace(
      txt[i],
      pattern,
      stringr::str_glue("<span id='{chunk_name}'>###&quot;\\1&quot;###</span>")
    )
    # and keep track of it for later:
    chunk_names <- c(chunk_names, chunk_name)
  }
  
  # whenever one of these named chunks is referenced, link to its definition
  txt <- stringr::str_replace_all(
    txt,
    paste0(reference_start, chunk_names, reference_end, collapse = "|"),
    function(chunk_name) {
      chunk_name <- stringr::str_remove_all(
        chunk_name, 
        paste(reference_start, reference_end, sep = "|"))
      stringr::str_glue("<a href='#{chunk_name}'>&lt&lt{chunk_name}&gt&gt</a>")
    }
  )
  writeLines(txt, con = output_file)
}
```


As described earlier, the function `get_params_used()` combines the parameters from the YAML but allows for those values to be overridden through arguments passed to `render()`.

```{r}
#' Get parameter values used in rendering
#' 
#' When the `params` argument of `rmarkdown::render()` is explicitly used, this
#' overrides the default that appears in `input`.
#' @param input The input file to be rendered (see `rmarkdown::render`)
#' @param passed_params The list of parameters that were passed to `render`.
get_params_used <- function(input, passed_params) {
  params <- rmarkdown::yaml_front_matter(input)$params
  for (param in names(passed_params)) {
    params[[param]] <- passed_params[[param]]
  }
  params
}
```

We used the package `rmarkdown`, so let's import it:

```{r}
usethis::use_package("rmarkdown")
```

### Combining .R files

**This section should eventually be removed but for now I'm doing this to convince myself that the package generated by this .Rmd file really matches the initial version created without the package.**

```{r}
library(magrittr)
library(purrr)
rfiles <- fs::dir_ls("R")
code <- rfiles %>% 
  map(readLines) %>% 
  set_names(
    rfiles %>% stringr::str_remove("^.*/") %>% stringr::str_remove(".R$")
    )
hash_functions <- c("hash_package_directory",
                    "description_litr_hash_field_name",
                    "write_hash_to_description",
                    "read_hash_from_description",
                    "check_unedited")
render_functions <- c("render",
                      "add_function_hyperlinks",
                      "add_chunk_label_hyperlinks",
                      "get_params_used",
                      "do_not_edit_message",
                      "description_litr_version_field_name",
                      "write_version_to_description",
                      "document")
setup_functions <- c("setup",
                     "make_noticeable",
                     "send_to_package",
                     "add_text_to_file",
                     "find_labels")
remove_initial_lines <- function(code_list) {
  # drop first line of each list element except for the first list element
  c(code_list[1], map(code_list[-1], ~ .x[-1]))
}
fs::file_delete(setdiff(rfiles, "R/litr-package.R"))
writeLines(unlist(remove_initial_lines(code[hash_functions])), "R/hash.R")
writeLines(unlist(remove_initial_lines(code[render_functions])), "R/render.R")
writeLines(unlist(remove_initial_lines(code[setup_functions])), "R/setup.R")
```


## Including templates

We now add the .Rmd templates to the package.  We have the `skeleton.Rmd` defined in `litr-source-files`.  Note that paths are relative to the outputted package's location.

The first template is the simplest imaginable package with a single function:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package",
  template_dir = "make-an-r-package",
  template_description = "Template for an Rmd file for writing an R package using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "litr-source-files", "make-an-r-package", "skeleton.Rmd"
    ), 
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package", "skeleton"
    ), 
  overwrite = TRUE
)
```

The second template shows how to create a package with a dataset:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package With a Dataset",
  template_dir = "make-an-r-package-with-data",
  template_description = "Template for an Rmd file for writing an R package with a dataset using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "litr-source-files", "make-an-r-package-with-data", "skeleton.Rmd"
    ), 
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-data", "skeleton"
    ), 
  overwrite = TRUE
)
```

The third template shows how to create a package that uses `Rcpp`:

```{r}
usethis::use_rmarkdown_template(
  template_name = "Template To Make an R Package With Rcpp",
  template_dir = "make-an-r-package-with-rcpp",
  template_description = "Template for an Rmd file for writing an R package that makes use of Rcpp while using literate programming.",
  template_create_dir = FALSE
)
fs::file_copy(
  path = file.path(
    "..", "litr-source-files", "make-an-r-package-with-rcpp", "skeleton.Rmd"
    ),
  new_path = file.path(
    "inst", "rmarkdown", "templates", "make-an-r-package-with-rcpp", "skeleton"
    ),
  overwrite = TRUE
)
```

## Including README

We include a `README.Rmd` and then generate the `README.md` based on it:

```{r}
usethis::use_readme_rmd(open = FALSE)
fs::file_copy(
  path = file.path("..", "litr-source-files", "README.Rmd"), 
  new_path = "README.Rmd", 
  overwrite = TRUE
)
xfun::Rscript_call(
  rmarkdown::render,
  args = list(
    input = "README.Rmd",
    output_options = list(html_preview = "false")
    )
  )
```


## Defining some tests {#tests}

When using `litr` to create packages that are not `litr`, one should be able to run tests along the way as we did above in testing the function `add_text_to_file()`.  However, creating `litr` is a special case so we need to do something different for the tests that involve creating a .Rmd from template and then calling `litr::render()` on them (such as the tests in this section).  In particular, we use `eval=FALSE` for these code blocks and then at the end of this document we will install the newly created version of `litr` and then call `devtools::test()`.  Doing it this way is important for ensuring that the version of `litr` we are testing is the newest version, i.e. the version defined in this document.

To understand the reason we are doing it this way, imagine what would happen if instead we left `eval=TRUE` in the test in the [next section](#test-check-unedited).  When we use `rmarkdown::draft()` to create a .Rmd file from template, the file it will give us will be an old version (namely the installed version of `litr`'s template) rather than the latest version.^[If this were the only problem, we could get around this by using `pkgload::package_file()` to get the proper file; however, the next problem discussed was something that seemed quite hard to resolve.] Furthermore, consider what happens when we call `render()` in the test below.  This will start the knitting process on `my-package.Rmd`.  However, inside `my-package.Rmd`, we have `litr::setup()` and `litr::document()`.  When these are called in the knitting process, it will be the versions of the functions from the currently installed `litr` rather than the versions defined in this document.

Once we are done testing the new version of the package, we'd like to restore the state of `litr` to what it was previously.  If we don't do this, then this can lead to inadvertent circularity in which the next time we call `litr::render("create-litr.Rmd")`, we are using the version currently under development, which is bad because ultimately we need this version to be rendered by the previous version of `litr`.  The following function implements this approach to testing `litr`: 

```{r}
#' Run tests for `litr` itself
#' 
#' Special function for testing `litr`.  The trick is to temporarily install
#' the new version of `litr`, run the test, and then put things back how it was
#' before.
#' 
#' Typical values for `install_old` could be
#' - `function() devtools::install("[location of old version]")`
#' - `function() remotes::install_github("jacobbien/litr-project@*release", subdir = "litr")`.
#' 
#' @param install_old A function that when run will install the old version
#' @param location_of_new Path to the new package directory
#' @export
test_litr <- function(install_old, location_of_new) {
  devtools::install(location_of_new)
  out <- devtools::test(location_of_new)
  install_old()
  return(out)
}
```

### Testing `check_unedited()` {#test-check-unedited}

For our tests, we create a temporary directory (which we delete at the end).  In this directory, we create a generating .Rmd file from one of the templates.  We make repeated modifications to the package and each time verify that `check_unedited()` is `FALSE` with the modification and returns to `TRUE` when we put things back how they were.  The modifications we try are the following:

- Adding a file

- Removing a file

- Making a change to a file (in particular, adding a comment to an R file)

- Changing something in the DESCRIPTION file (but not on the special `litr` line)

- Changing the `litr` hash line itself

```{r, eval=FALSE}
testthat::test_that("check_unedited works", {
  # Including this next line seems to be necessary for R CMD check on the cmd line:
  #Sys.setenv(RSTUDIO_PANDOC = "/Applications/RStudio.app/Contents/MacOS/pandoc")
  dir <- tempfile()
  fs::dir_create(dir)
  rmd_file <- file.path(dir, "my-package.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package",
                   package = "litr",
                   edit = FALSE)
  # create R package (named "rhello") from the Rmd template:
  render(rmd_file)
  package_path <- file.path(dir, "rhello")
  testthat::expect_true(check_unedited(package_path))

  # what if a file has been added?
  added_file <- file.path(package_path, "R", "say_hello2.R")
  writeLines("# Added something here.", added_file)
  testthat::expect_false(check_unedited(package_path))

  # what if we now remove it?
  fs::file_delete(added_file)
  testthat::expect_true(check_unedited(package_path))

  # what if a file is removed from package?
  rfile <- file.path(package_path, "R", "say_hello.R")
  fs::file_move(rfile, dir)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  fs::file_move(file.path(dir, "say_hello.R"), file.path(package_path, "R"))
  testthat::expect_true(check_unedited(package_path))

  # what if something is changed in a file?
  txt <- readLines(rfile)
  txt_mod <- txt
  txt_mod[3] <- paste0(txt[3], " # added a comment!!")
  writeLines(txt_mod, rfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, rfile)
  testthat::expect_true(check_unedited(package_path))

  # what if something is changed in the DESCRIPTION file?
  descfile <- file.path(package_path, "DESCRIPTION")
  txt <- readLines(descfile)
  txt_mod <- txt
  txt_mod[1] <- "Package: newname"
  writeLines(txt_mod, descfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, descfile)
  testthat::expect_true(check_unedited(package_path))

  # what if the special litr hash field is changed in the DESCRIPTION file?
  txt <- readLines(descfile)
  i_litr <- stringr::str_which(txt, description_litr_hash_field_name())
  txt_mod <- txt
  txt_mod[i_litr] <- paste0(txt_mod[i_litr], "a")
  writeLines(txt_mod, descfile)
  testthat::expect_false(check_unedited(package_path))
  # now put it back
  writeLines(txt, descfile)
  testthat::expect_true(check_unedited(package_path))

  fs::dir_delete(dir)
})
```

### Testing `get_params_used()`

Let's now test the `get_params_used()` function, making sure it behaves how we expect it to:

```{r, eval=FALSE}
testthat::test_that("get_params_used works", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  rmd_file <- file.path(dir, "my-package.Rmd")
  rmarkdown::draft(rmd_file, template = "make-an-r-package", package = "litr",
                   edit = FALSE)
  default_params <- get_params_used(rmd_file, passed_params = list())
  testthat::expect_equal(
    default_params,
    rmarkdown::yaml_front_matter(rmd_file)$params
  )
  params1 <- default_params
  params1$package_parent_dir <- "dir"
  testthat::expect_equal(
    get_params_used(rmd_file, passed_params = list(package_parent_dir = "dir")),
    params1
  )
  params2 <- default_params
  params2$package_name <- "pkg"
  params2$package_parent_dir <- "dir"
  testthat::expect_equal(
    get_params_used(rmd_file,
                    passed_params = list(package_parent_dir = "dir",
                                         package_name = "pkg")),
    params2
  )
  fs::dir_delete(dir)
})
```

### Testing chunk referencing

Here we test the handling of chunk references (as implemented in the document output hook set within `setup()`).  In particular, we use a .Rmd that uses chunk references in several different ways.  Within the .Rmd itself, we have tests that ensure that the code can still be run as expected.

```{r}
fs::file_copy(
  path = file.path(
    "..", "litr-source-files", "test-example-files", "create-rknuth.Rmd"
    ), 
  new_path = file.path("tests", "testthat"), 
  overwrite = TRUE
)
```


```{r, eval=FALSE}
testthat::test_that('Knuth-style references work', {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  rmd_file <- file.path(dir, 'create-rknuth.Rmd')
  fs::file_copy(path = testthat::test_path("create-rknuth.Rmd"), new_path = rmd_file)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, 'create-rknuth.html')))
  fs::dir_delete(dir)
})
```


### Testing other templates

Let's now make sure that each template can be knit without error.

```{r, eval=FALSE}
testthat::test_that("templates can be knit", {
  dir <- tempfile()
  if (fs::file_exists(dir)) fs::file_delete(dir)
  fs::dir_create(dir)
  
  rmd_file <- file.path(dir, "create-rhello.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-rhello.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "rhello")))

  rmd_file <- file.path(dir, "create-rhasdata.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package-with-data",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-rhasdata.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "rhasdata")))

  rmd_file <- file.path(dir, "create-withrcpp.Rmd")
  rmarkdown::draft(rmd_file,
                   template = "make-an-r-package-with-rcpp",
                   package = "litr",
                   edit = FALSE)
  render(rmd_file)
  testthat::expect_true(fs::file_exists(file.path(dir, "create-withrcpp.html")))
  testthat::expect_true(fs::file_exists(file.path(dir, "withrcpp")))
  
  fs::dir_delete(dir)
 })
```

Even though `litr` doesn't directly use `Rcpp`, we'll add it as a "Suggests" package since it would be required for running the above test.

```{r}
usethis::use_package("Rcpp", type = "Suggests")
```


## Documenting the package and testing

We finish by running commands that will document and test `litr`.

**The formatting of the test output does not print out very neatly.**

We download the latest release:

```{r}
rm(list = ls())
litr::document()
install_old <- function() {
  remotes::install_github("jacobbien/litr-project@*release", subdir = "litr")
}
xfun::Rscript_call(test_litr,
                   list(install_old = install_old, location_of_new = "."))
```

## Add examples folder with the output of knitting each example

In this section, we will litr-knit each template and put the outputs in an examples directory that lives outside of the `litr` R package.  These examples are linked to in `README.Rmd`.

```{r}
build_all_templates <- function(install_old, location_of_new) {
  devtools::install(location_of_new)

  example_dir <- file.path("..", "examples")
  if (fs::dir_exists(example_dir)) fs::dir_delete(example_dir)
  fs::dir_create(example_dir)
  
  templates <- fs::path_file(fs::dir_ls("inst/rmarkdown/templates"))
  for (template in templates) {
    tmp_file <- file.path(example_dir, "temp.Rmd")
    rmarkdown::draft(tmp_file, template, package = "litr", edit = FALSE)
    pkg_name <- rmarkdown::yaml_front_matter(tmp_file)$params$package_name
    rmd_file <- file.path(example_dir, paste0("create-", pkg_name, ".Rmd"))
    fs::file_move(tmp_file, rmd_file)
    render(rmd_file)
    # move to a template-specific directory:
    template_dir <- file.path(example_dir, template)
    fs::dir_create(template_dir)
    fs::file_move(fs::dir_ls(example_dir, regexp = pkg_name), template_dir)
  }

  install_old()
}
```

```{r}
xfun::Rscript_call(build_all_templates,
                   list(install_old = install_old, location_of_new = "."))
```

