[["index.html", "Creating the litr R package 1 Preamble", " Creating the litr R package Jacob Bien May 27, 2022 1 Preamble This document uses literate programming to define the litr R package. This means that all source code for litr is contained and presented in this document alongside explanation. The litr R package gets created as an output when one runs a piece of code that takes this document as input. To modify the litr package, one should modify the code in this document (and the explanation, as needed) and then regenerate the package. But what piece of code do we use to create an R package from this document? Well… it turns out that this is precisely what the litr package is for. But how can we use litr to create litr? We actually use version \\(n-1\\) of litr to create version \\(n\\). When an R markdown file is rendered with litr, an R package is created in addition to the usual html/pdf/etc document. To learn more about using litr, please visit the litr website. This document is not intended for people who wish to use litr. Rather, it is intended for people who want to know how it works and (possibly) modify it. This document used litr version 0.9.0 to define the current version of litr. In particular, it was generated by running the following command in an R console from the working directory containing index.Rmd: litr::render(&quot;index.Rmd&quot;) fs::dir_copy(&quot;_book&quot;, &quot;../docs/create&quot;, overwrite = TRUE) fs::dir_delete(&quot;_book&quot;) The second and third lines move the generated bookdown to the docs/ directory so that it will render nicely on github by visiting https://jacobbien.github.io/litr-project/create/. "],["overview.html", "2 Overview", " 2 Overview The litr package consists of (a) document templates that users can use as the basis for creating an R package, (b) code needed so that when such a R markdown file is knitted, it will generate not just an .html (or some other output format) but also an R package. The code has the following components: Functionality for generating the R package when the .Rmd file is knitted. In particular, we define a knitr chunk hook, which we call send_to_package() that identifies code chunks in the .Rmd file that should be included in the package. To make it so that this chunk hook will be active, we also have a function called setup() that is called at the start of litr::render() right before rmarkdown::render() is called. The setup() function makes it so that when the .Rmd file is knitted, the chunk hook send_to_package() will be invoked on each code chunk. It is also responsible for other preliminaries, such as defining a new knitr language engine that can interpret package-level documentation. Functionality for making sure the R package outputted will not overwrite a manually edited R package. Our approach here is to use a hash that will make it clear whether something has been modified. Wrapper to devtools::document() The reason we write a wrapper for devtools::document() is because we want it to behave slightly differently. In particular, devtools::document() reminds the reader to edit the roxygen in the R/ files, whereas in our case, we want to make sure they edit the original .Rmd file, not the R/ files. Functionality to alter the rendering process The focus here is to make it so that all the special litr functionality will be active when the .Rmd is rendered. We implement two ways this can happen. First, we have several custom output formats, such as litr_html_document(). When rmarkdown::render() is called with one of these litr output formats, setup() gets called before knitting occurs and some other litr-specific post-processing occurs as well. The second way is through the function litr::render(). If a user calls litr::render() with a non-litr output format, e.g. rmarkdown::html_document(), then setup() gets called before rmarkdown::render() and also post-processing can again happen. Another thing of note about litr::render() is that it renders the document in a fresh environment, which ensures identical behavior to when a user presses “Knit” in RStudio. "],["package-setup.html", "3 Package setup 3.1 A note on circularity", " 3 Package setup We start by specifying the information needed in the DESCRIPTION file of the R package. We mostly follow the R Packages book’s description of version numbering. Releases 0.0.1, 0.0.2, and 0.0.3 should really have been 0.1.0, 0.2.0, and 0.3.0, because these were not just patches. Rather, each added quite substantial new functionality. For this reason, we have gone straight from 0.0.3 to 0.4.0. We will keep the leftmost number (“major release”) at 0 until we feel like the package is complete with all the intended features. usethis::create_package( path = &quot;.&quot;, fields = list( Package = params$package_name, Version = &quot;0.9.2&quot;, Title = &quot;Literate Programming for Writing R Packages&quot;, Description = &quot;Allows one to fully create an R package in a single .Rmd file. Includes functionality and .Rmd templates for a literate programming approach to R package development.&quot;, `Authors@R` = c( person(&quot;Jacob&quot;, &quot;Bien&quot;, email = &quot;jbien@usc.edu&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;)), person(&quot;Patrick Vossler&quot;, role = &quot;aut&quot;) ) ) ) usethis::use_mit_license(copyright_holder = &quot;J. Bien&quot;) Let’s add some package-level documentation. This is what will show up when someone types package?litr in the console. #&#39; Literate Programming for Writing R Packages #&#39; #&#39; Allows one to fully create an R package in a single .Rmd file. Includes #&#39; functionality and .Rmd templates for a literate programming approach to R #&#39; package development. #&#39; #&#39; @examples #&#39; \\dontrun{ #&#39; # Make a file create-rhello.Rmd based on a template #&#39; litr::draft(&quot;rhello&quot;) #&#39; # Now call litr::render (or press Knit if in RStudio) to generate not just #&#39; # create-rhello.html, but also an R package called `rhello`. #&#39; litr::render(&quot;create-rhello.Rmd&quot;) #&#39; } #&#39; @docType package #&#39; @seealso \\code{\\link{render}} 3.1 A note on circularity Keeping track of the version of litr used is particularly important when using litr to develop litr. There is a tendency to want to use the new functionality that we are creating in create-litr.Rmd itself as soon as we have defined it. However, this is circular and thus must be avoided. To see why we need to be careful, let’s consider an actual example that arose when working on litr version 0.0.3. After release v0.0.2, one of the new features we added is a new language engine called package_doc that allows us to have a special kind of code block defining the package documentation. In trying out this feature and making sure it works on skeleton.Rmd, we would most likely install version 0.0.3. Now that version 0.0.3 is installed, there will be a tendency to want to add a package_doc block to create-litr.Rmd, and it will appear to work. However, this is circular, because we have used version 0.0.3 to create version 0.0.3! In particular, if we remove litr and re-install it from github, we will get version 0.0.2 so that when we attempt to create the package using litr::render(\"create-litr.Rmd\"), we will get an error telling us that it doesn’t have a language engine named package_doc. The code chunk in this section is for preventing this from happening. For more on circularity, see the section on testing litr. install_version_of_litr &lt;- utils::packageVersion(&quot;litr&quot;) remote &lt;- remotes::github_remote( repo = &quot;jacobbien/litr-project@*release&quot;, subdir = &quot;litr&quot; ) version_of_latest_release &lt;- stringr::str_remove(remote$ref, &quot;v&quot;) if (install_version_of_litr != version_of_latest_release) stop(stringr::str_glue( &quot;You should be using the version of litr from the latest release (version&quot;, &quot; {version_of_latest_release}),\\n but you are using version&quot;, &quot; {install_version_of_litr}.\\n&quot;, &quot;You can install the release version of litr from GitHub by running the&quot;, &quot; the following command:\\n&quot;, &quot;remotes::install_github(repo=&#39;jacobbien/litr-project@*release&#39;, subdir = &#39;litr&#39;)&quot; )) "],["generating-package.html", "4 Generating the R package 4.1 Sending code chunks to the package 4.2 Setting up the R package creation", " 4 Generating the R package 4.1 Sending code chunks to the package We start by defining a chunk hook, which is a function that runs both before and after each code chunk is run in the knitting process. In this case, the function (called send_to_package) is responsible for determining whether the code chunk looks like something that should be exported to the R package. We don’t want all code sent off to our R package. For example, sometimes we’ll want to demonstrate in the Rmd file how a certain function we’ve just created is used by running it on an example or making a plot. That bit of example code would not be included in the package. We start by making sure that code is only sent to the R package once (arbitrarily we have code outputted to the package before and not after the chunk is run). The function then checks if this code chunk is code that should be put into the package. There are four specific cases it considers: If the special option send_to is used in this code chunk, then things are very simple in that the user has explicitly told us where this code should be added. For example, if send_to=\"R/file.R\", then the code in this chunk will be appended to R/file.R in the R package (and if that file doesn’t yet exist, it will be created). Is it a piece of code to be sent to the R/ directory? In particular, it checks to see if the code chunk begins with the characteristic roxygen2 characters #'. If it does, then the name of the object being documented is identified (could be a function, a dataset, an S4 object, etc.) and then we write the code chunk to the file R/&lt;objectname&gt;.R. If the code chunk does not start with #', then we check if it has any line starting with test_that( or testthat::test_that(. If so, then this whole code chunk is appended to tests/testthat/tests.R (and this file is created the first time a test chunk is sent to the package). Next, it checks if the language engine is Rcpp. This occurs when the code chunk starts with {Rcpp, rather than the usual {r (or alternatively when the engine=\"Rcpp\" option is used). We then set things up appropriately for the use of Rcpp within the package (by adapting some code from within the usethis::use_rcpp() function). Finally, we write the code chunk to src/code.cpp. There is a common header used, #include &lt;Rcpp.h&gt; using namespace Rcpp; and we only want this to appear once in code.cpp, so we do a bit of work to remove that if it appears in the code chunk. #&#39; A knitr chunk hook for writing R code and tests #&#39; #&#39; This chunk hook detects whether a chunk is defining a function or dataset #&#39; to be included in the R package (looks for the `roxygen2` comment format `#&#39; `). #&#39; If so, then it is written to the `R/` directory. It also looks for chunks #&#39; that have one or more lines that start with `test_that(` or #&#39; `testthat::test_that(` (potentially with some leading whitespace). These #&#39; chunks are then written to the `tests` directory of the R package. #&#39; #&#39; When the `send_to` option is used, this chunk hook instead simply writes the #&#39; code chunk to the file specified. #&#39; #&#39; @param before Indicates whether this is being called before or after the #&#39; chunk code is executed #&#39; @param options Has information from the chunk #&#39; @param envir Environment #&#39; @keywords internal send_to_package &lt;- function(before, options, envir) { msg &lt;- do_not_edit_message(knitr::current_input(), type = &quot;R&quot;) if (before == FALSE) { # Don&#39;t do anything after the code chunk has been executed. return() } package_dir &lt;- knitr::opts_knit$get(&quot;root.dir&quot;) package_name &lt;- fs::path_file(package_dir) if (!is.null(options$send_to)) { # the user has defined an option that indicates where in the package this # code should be written file &lt;- file.path(package_dir, options$send_to) add_text_to_file(options$code, file, pad = TRUE, msg = msg) return() } if (stringr::str_detect(options$code[1], &quot;^#&#39; &quot;)) { # starts with roxygen2, so let&#39;s assume this chunk is defining an R function # or dataset that belongs in the package non_comment &lt;- stringr::str_subset(options$code, &quot;^#&quot;, negate = TRUE) if (length(non_comment) &gt; 0) { if (stringr::str_detect(non_comment[1], &quot;&lt;-&quot;)) { # a function is being defined objname &lt;- stringr::str_match(non_comment[1], &quot;^(.*)\\\\s*&lt;-\\\\s*function&quot;)[, 2] objname &lt;- stringr::str_trim(objname) } else if (stringr::str_detect(non_comment[1], &#39;^&quot;.+&quot;$&#39;)) { # a dataset is being documented objname &lt;- stringr::str_sub(non_comment[1], start = 2, end = -2) } else { # Roxygen2 comment wasn&#39;t followed by anything recognized, so do not # send this to package return() } file &lt;- file.path(package_dir, &quot;R&quot;, stringr::str_glue(&quot;{objname}.R&quot;)) cat(paste(c(msg, &quot;&quot;, options$code, &quot;&quot;), collapse = &quot;\\n&quot;), file = file) } } else if (any(stringr::str_detect(options$code, &quot;^\\\\s*(testthat::)?test_that\\\\(&quot;))) { # This chunk is inferred to be a test test_dir &lt;- file.path(package_dir, &quot;tests&quot;, &quot;testthat&quot;) test_file &lt;- file.path(test_dir, &quot;tests.R&quot;) if (!file.exists(test_file)) { # It&#39;s the first chunk with tests if (!dir.exists(test_dir)) usethis::use_testthat() cat(c(msg, &quot;&quot;), collapse = &quot;\\n&quot;, file = test_file) } cat( paste(c(options$code, &quot;&quot;, &quot;&quot;), collapse = &quot;\\n&quot;), file = test_file, append = TRUE ) } else if (options$engine == &quot;Rcpp&quot;) { # To add Rcpp code, we need the package documentation file to exist if (!file.exists(file.path( package_dir, &quot;R&quot;, paste0(package_name, &quot;-package.R&quot;)) )) { usethis::use_package_doc(open = FALSE) } cpp_file &lt;- file.path(package_dir, &quot;src&quot;, &quot;code.cpp&quot;) if (!file.exists(cpp_file)) { # set up package for Rcpp # these next few lines are taken from usethis::use_rcpp() # it approximates a call to usethis::use_rcpp(name = &quot;code&quot;) usethis:::use_dependency(&quot;Rcpp&quot;, &quot;LinkingTo&quot;) usethis:::use_dependency(&quot;Rcpp&quot;, &quot;Imports&quot;) usethis:::roxygen_ns_append(&quot;@importFrom Rcpp sourceCpp&quot;) usethis:::use_src() usethis::use_template(&quot;code.cpp&quot;, save_as = &quot;src/code.cpp&quot;) msg &lt;- do_not_edit_message(knitr::current_input(), type = &quot;c&quot;) cat(msg, file = cpp_file, append = TRUE) } # append code to code.cpp, but remove lines that are `#include &lt;Rcpp.h&gt;` # or `using namespace Rcpp;` since this already appears at top of file cat(paste(c( &quot;&quot;, stringr::str_subset( options$code, r&quot;(^#include &lt;Rcpp.h&gt;$|^using namespace Rcpp;$)&quot;, negate = TRUE), &quot;&quot;), collapse = &quot;\\n&quot;), file = cpp_file, append = TRUE) } return() } The above code makes use of a number of functions from the stringr and usethis packages, so we’ll need to add those packages to the Imports section of the DESCRIPTION file: usethis::use_package(&quot;stringr&quot;) ## ✔ Adding &#39;stringr&#39; to Imports field in DESCRIPTION ## • Refer to functions with `stringr::fun()` usethis::use_package(&quot;usethis&quot;) ## ✔ Adding &#39;usethis&#39; to Imports field in DESCRIPTION ## • Refer to functions with `usethis::fun()` The code also calls the function do_not_edit_message(), which adds a line at the top of the files sent to the R package reminding the user that these are not source files to be edited but rather output of the generating .Rmd file. There are two variations on this message. #&#39; Generate do-not-edit message to put at top of file #&#39; #&#39; @param rmd_file Name of the Rmd file to mention #&#39; @param type Whether this is a R/ file, man/ file, or a c file #&#39; @keywords internal do_not_edit_message &lt;- function(rmd_file, type = c(&quot;R&quot;, &quot;man&quot;, &quot;c&quot;)) { if (type[1] == &quot;R&quot;) return(stringr::str_glue(&quot;# Generated from {rmd_file}: do not edit by hand&quot;)) else if (type[1] == &quot;man&quot;) return(stringr::str_glue(&quot;% Please edit documentation in {rmd_file}.&quot;)) else if (type[1] == &quot;c&quot;) return(stringr::str_glue(&quot;// Generated from {rmd_file}: do not edit by hand&quot;)) else stop(&quot;type must be either &#39;R&#39;, &#39;man&#39;, or &#39;c&#39;.&quot;) } This function will also be used with type = \"man\" by litr::document(). The above also makes use of a simple helper function that inserts text into a specified location of a file (or creates that file if it doesn’t exist). Actually currently it doesn’t, but we can replace cat() in the above with calls to add_text_to_file(). #&#39; Add Some Text to a File #&#39; #&#39; The text will be added to the file at a particular line specified by #&#39; `location`. The first line of `txt` will be on line `location` of the #&#39; modified file. If `location` is NULL, then text is added to end of file. #&#39; If file does not exist, it is created and `location` is ignored (unless #&#39; `req_exist` is `TRUE`, in which case an error is thrown). #&#39; #&#39; @param txt Character vector to add to file #&#39; @param filename Name of file #&#39; @param location Specifies where text should be added. See description for more. #&#39; @param req_exist If TRUE, then throws an error if file doesn&#39;t exist #&#39; @param pad If TRUE, then when text is being added to a preexisting file, it adds a newline #&#39; @param msg An optional message to put at top of file if this is a new file #&#39; @keywords internal add_text_to_file &lt;- function(txt, filename, location = NULL, req_exist = FALSE, pad = FALSE, msg = NULL) { if (!file.exists(filename)) { if (req_exist) stop(stringr::str_glue(&quot;Cannot find file {filename}.&quot;)) if (!is.null(msg)) txt &lt;- c(msg, &quot;&quot;, txt) writeLines(txt, con = filename) return() } if (pad) txt &lt;- c(&quot;&quot;, txt) filetxt &lt;- readLines(filename) if (is.null(location) || location == length(filetxt) + 1) { filetxt &lt;- c(filetxt, txt) } else if (location &gt; length(filetxt) + 1 | location &lt; 1) stop(&quot;Invalid location&quot;) else if (location == 1) { filetxt &lt;- c(txt, filetxt) } else { # location is somewhere in middle filetxt &lt;- c(filetxt[1:(location - 1)], txt, filetxt[location:length(filetxt)]) } writeLines(filetxt, con = filename) } testthat::test_that(&quot;add_text_to_file() works&quot;, { dir &lt;- tempfile() if (fs::file_exists(dir)) fs::file_delete(dir) fs::dir_create(dir) # should throw error when file does not exist and req_exist is TRUE: myfile &lt;- file.path(dir, &quot;file.txt&quot;) sometxt &lt;- c(&quot;hello&quot;, &quot;there&quot;) testthat::expect_error(add_text_to_file(sometxt, myfile, req_exist = TRUE)) # should create a new file where one does not exist: myfile &lt;- file.path(dir, &quot;file.txt&quot;) sometxt &lt;- c(&quot;hello&quot;, &quot;there&quot;) add_text_to_file(sometxt, myfile) testthat::expect_true(fs::file_exists(myfile)) testthat::expect_equal(sometxt, readLines(myfile)) # should append to end of file by default moretxt &lt;- &quot;world&quot; add_text_to_file(moretxt, myfile) testthat::expect_equal(c(sometxt, moretxt), readLines(myfile)) # should throw error for invalid locations: testthat::expect_error(add_text_to_file(sometxt, myfile, 0)) testthat::expect_error(add_text_to_file(sometxt, myfile, -1)) testthat::expect_error(add_text_to_file(sometxt, myfile, 5)) # should add to specified line: moretxt2 &lt;- &quot;hi&quot; add_text_to_file(moretxt2, myfile, 1) testthat::expect_equal(c(moretxt2, sometxt, moretxt), readLines(myfile)) # should add to specified line: moretxt3 &lt;- &quot;hi2&quot; add_text_to_file(moretxt3, myfile, 2) testthat::expect_equal(c(moretxt2, moretxt3, sometxt, moretxt), readLines(myfile)) # should add to specified line: moretxt4 &lt;- &quot;hi3&quot; add_text_to_file(moretxt4, myfile, 6) testthat::expect_equal(c(moretxt2, moretxt3, sometxt, moretxt, moretxt4), readLines(myfile)) fs::dir_delete(dir) }) ## Test passed 4.2 Setting up the R package creation When the user calls litr::render() (either in the console or by pressing “Knit” in RStudio), one of the first things that function does is to call the function litr::setup(), which does several things: Creates a new empty directory at the specified location while first making sure that it won’t overwrite something it shouldn’t. In particular, we guard against the case that the package was generated by litr::render() but then someone went in manually and made some changes. Even though users should never manually edit the package that was generated by litr::render(), we don’t want to have them inadvertently lose their work by doing so. Thus, we only overwrite an R package if we can tell that it is the unedited output of a call to litr::render(). The function check_unedited() is responsible for checking this, and is a pretty interesting function which we will describe in the next section. This part of the code also makes use of a function litr::make_noticeable(), which is simply a way of making error messages produced by litr more easy to see amid a lot of knitr output. Adjusts the root directory from the generating .Rmd file’s location to the R package’s location. Note: This behavior might not actually be desirable now that additional files will be loaded in. It might be awkward for a user writing the generating .Rmd file to have to make everything relative to the package. It might be convenient to provide a litr::add_file(from, to) function, where from is the path relative to the .Rmd file and to is the path relative to the package’s location. Makes it so that the send_to_package() chunk hook is active for each code chunk. This involves registering a new chunk hook using the function knitr::knit_hooks$set() and then setting an option with the same name to TRUE within each chunk. Deactivates an internal function of the usethis package, usethis:::challenge_nested_project(). This was actually a difficult issue to address that involves the intersection of usethis, here, and our particular use case. The problem is that usethis was not designed for our setting in which an R package is being created programmatically. When using litr, the project directory will have the generating .Rmd file and when this is knit it will create an R package within this project. However, this leads usethis to prompt the user with a message of the form “New project ‘[…]’ is nested inside an existing project ‘[…]’. This is rarely a good idea. Do you wish to create anyway?” But since this is encountered through knitting rather than interactively, this results in an error. This usethis issue describes this exact problem. The solution suggested there by jennybc involving testthat::with_mock() is along the lines of what we want; however, that would lead to some ugly looking code in the generating .Rmd file. The best solution I could find was to use utils::assignInNamespace() as described here. This function allows us to change the internal function usethis:::challenge_nested_project() so that it no longer prompts the user with concerns about nested projects. Changes how chunk references are handled. In particular, consider the following code chunk: a &lt;- 2 &lt;&lt;my-chunk&gt;&gt; a The way knitr handles this, the code chunk would no longer look like this but it would rather have replaced the &lt;&lt;my-chunk&gt;&gt; line by the code that appears in the code chunk labeled “my-chunk”. We instead would like the above code chunk to appear as written and then for the code chunk labeled “my-chunk” to have its label visible to the reader of the .html file. This gives the coder more control over when the reader learns about different parts of the code. It also more closely resembles Donald Knuth’s form of literate programming. For convenience, we’d like &lt;&lt;my-chunk&gt;&gt; to be a link that navigates to the code chunk labeled “my-chunk”. To accomplish this, we modify the document output hook in setup() (and then we also add a function called add_chunk_label_hyperlinks() within render()). Define a package_doc engine which allows users to define package-level documentation. #&#39; Code for setup chunk #&#39; #&#39; * Creates directory where package will be. (Deletes what is currently there as #&#39; long as it appears to have been created by litr and does not have any #&#39; subsequent manual edits.) #&#39; * Sets the root directory to this directory #&#39; * Sets up the main chunk hook `litr::send_to_package()` that sends code to the #&#39; R package directory. #&#39; * In the case that `minimal_eval=TRUE`, sets up an options hook for `eval` so #&#39; chunks are only evaluated if there is a `usethis` or `litr::document()` #&#39; command #&#39; * Deactivates an internal function of the `usethis` package #&#39; * Redefines the document output hook to handle chunk references differently #&#39; * Sets up a [custom language engine](https://bookdown.org/yihui/rmarkdown-cookbook/custom-engine.html) called #&#39; `package_doc` that creates a package documentation file and then inserts #&#39; whatever the user puts in the chunk. #&#39; #&#39; Returns the original state of the knitr objects that have been modified in #&#39; setup. This allows us to return things to the previous state after we are #&#39; finished. This is relevant in the case where litr-knitting occurs in the #&#39; current session and we don&#39;t want to leave things in a permanently modified #&#39; state. #&#39; #&#39; @param package_dir Directory where R package will be created #&#39; @param minimal_eval If `TRUE`, then only chunks with `litr::document()` or #&#39; `usethis` commands will be evaluated. This can be convenient in coding when #&#39; you just want to quickly update the R package without having to wait for long #&#39; evaluations to occur. #&#39; @keywords internal setup &lt;- function(package_dir, minimal_eval) { if (file.exists(package_dir)) { unedited &lt;- tryCatch(check_unedited(package_dir), error = function(e) { # contents of package_dir does not resemble # a litr package return(FALSE) }) if (!unedited) { stop(make_noticeable(paste( stringr::str_glue(&quot;The directory {normalizePath(package_dir)}&quot;), &quot;already exists and either was not created by litr or may have manual&quot;, &quot;edits. In either case, please rename that directory (or delete it)&quot;, &quot;and then try again.&quot;, sep = &quot;\\n&quot;))) } unlink(package_dir, recursive = TRUE) } fs::dir_create(package_dir) usethis:::proj_set_(usethis:::proj_path_prep(package_dir)) # let&#39;s keep a version of the knitr objects before modifying them: original_knitr &lt;- list(opts_knit = knitr::opts_knit$get(), knit_hooks = knitr::knit_hooks$get(), opts_chunk = knitr::opts_chunk$get(), opts_hooks = knitr::opts_hooks$get(), knit_engines = knitr::knit_engines$get() ) knitr::opts_knit$set(root.dir = package_dir) # sets wd of future chunks knitr::knit_hooks$set(send_to_package = send_to_package) knitr::opts_chunk$set(send_to_package = TRUE) if (minimal_eval) { # only evaluate chunks that appear to include usethis commands or # a call to litr::document() but if someone has specifically set eval=FALSE # in a particular chunk, do honor that usethis_exports &lt;- getNamespaceExports(&quot;usethis&quot;) patterns &lt;- paste(c(&quot;usethis::&quot;, usethis_exports, &quot;litr::document\\\\(&quot;), collapse = &quot;|&quot;) knitr::opts_hooks$set(eval = function(options) { if (options$eval) options$eval &lt;- any(stringr::str_detect(options$code, patterns)) return(options) }) } # change usethis:::challenge_nested_project so that it will not complain # about creating a nested project (e.g. if this is called within a git # subdirectory) utils::assignInNamespace(&quot;challenge_nested_project&quot;, function(...) NULL, ns = &quot;usethis&quot;) # define document hook to handle chunk references: knitr::knit_hooks$set(document = function(x) { # get the indices of x corresponding to code chunks chunk_start &lt;- &quot;^(\\n``` ?+[a-zA-Z0-9_]+\\n)&quot; idx_block &lt;- stringr::str_which(x, chunk_start) original_code &lt;- knitr::knit_code$get() # We first get indices of skipped chunks in original_code list skipped_chunks &lt;- which(sapply(original_code, function(x){ return(isFALSE(attr(x, &quot;chunk_opts&quot;)$echo) || isFALSE(attr(x, &quot;chunk_opts&quot;)$include)) })) # Next we remove the indices of skipped chunks original_code_idx_fixed &lt;- setdiff(seq(length(original_code)), skipped_chunks) labels &lt;- names(original_code) # replace each x[i] that has code in it with the original code for (i in seq_along(idx_block)) { # break code into multiple lines: chunk &lt;- strsplit(x[idx_block[i]], &quot;\\n&quot;)[[1]] # get the fence used (in case it&#39;s more than three ticks): i_start &lt;- stringr::str_which(chunk, &quot;^```+ ?[a-zA-Z0-9_]+&quot;) fence &lt;- stringr::str_replace(chunk[i_start[1]], &quot;^(```+) ?[a-zA-Z0-9_]+&quot;, &quot;\\\\1&quot;) i_fences &lt;- stringr::str_which(chunk, paste0(&quot;^&quot;, fence)) # there can be multiple code and output chunks strung together # within a single x[i] if results are not held to end i_all_code &lt;- c() for (j in seq_along(i_start)) { # get the elements corresponding the j-th code chunk within chunk i_code_end &lt;- i_fences[which(i_fences == i_start[j]) + 1] i_all_code &lt;- c(i_all_code, i_start[j]:i_code_end) } i_all_code &lt;- setdiff(i_all_code, i_start[1]) chunk_no_code &lt;- chunk[-i_all_code] chunk &lt;- c(chunk_no_code[1:i_start[1]], original_code[original_code_idx_fixed[i]][[1]], # insert the original version, accounting for skipped chunks fence) if (i_start[1] &lt; length(chunk_no_code)) chunk &lt;- c(chunk, chunk_no_code[(i_start[1] + 1):length(chunk_no_code)]) x[idx_block[i]] &lt;- paste(chunk, collapse = &quot;\\n&quot;) } # replace code chunks with the original code # (so we&#39;ll still have &lt;&lt;label&gt;&gt; chunk references) refs &lt;- c() # labels that get referred to for (label in labels) { refs &lt;- c(refs, find_labels(original_code[[label]])$chunk_ids) } refs &lt;- unique(refs) adj_labels &lt;- labels[!labels %in% names(skipped_chunks)] ref_id &lt;- match(refs, adj_labels) if (any(is.na(ref_id))) { stop(make_noticeable(paste( stringr::str_glue(&quot;The chunk reference &lt;&lt;{refs[is.na(ref_id)][1]}&gt;&gt; &quot;, &quot;is used, but there is no chunk with that label.&quot;, sep = &quot;\\n&quot;)))) } to_insert &lt;- paste0(&#39;###&quot;&#39;, adj_labels[ref_id], &#39;&quot;###\\n&#39;) x[idx_block[ref_id]] &lt;- stringr::str_replace(x[idx_block[ref_id]], chunk_start, paste0(&quot;\\\\1&quot;, to_insert)) x }) # setup package_doc engine knitr::knit_engines$set(package_doc = function(options) { # create package_doc usethis::use_package_doc(open = FALSE) # insert the contents of the code chunk into the package_doc pkgdoc &lt;- file.path(&quot;R&quot;, paste0(fs::path_file(package_dir), &quot;-package.R&quot;)) add_text_to_file(options$code, filename = pkgdoc, location = 1) # now treat this as if it were standard R code with eval=FALSE r_engine &lt;- knitr::knit_engines$get(&quot;R&quot;) options[[&quot;eval&quot;]] &lt;- FALSE return(r_engine(options)) }) return(original_knitr) } In our new document output hook defined above, we call a function find_labels(). It takes a block of code and returns both a logical vector of which lines contained chunk labels and another vector containing the labels of those referenced chunks. We define it here: #&#39; Find a .Rmd chunk label in a code chunk #&#39; #&#39; @param chunk_code Character vector of code from a .Rmd code chunk. Each element is a line of the code chunk. #&#39; @return List where chunk_idx is a logical vector for each line of the chunk corresponding to whether a chunk label of the form `&lt;&lt;label&gt;&gt;` was found and chunk_ids is a character vector of chunk label was found in that chunk. #&#39; @keywords internal find_labels &lt;- function(chunk_code) { rc &lt;- knitr::all_patterns$md$ref.chunk chunk_idx &lt;- any(idx = grepl(rc, chunk_code)) chunk_ids &lt;- stringr::str_trim(sub(rc, &quot;\\\\1&quot;, chunk_code[grepl(rc, chunk_code)])) return(list(chunk_idx = chunk_idx, chunk_ids = chunk_ids)) } The setup() function also uses a small function, make_noticeable(), which we define here: #&#39; Make error messages noticeable #&#39; #&#39; Since litr error messages are amid a lot of output from knitting, we&#39;d like #&#39; the litr ones to be eye-catching. #&#39; #&#39; @param msg Error message #&#39; @keywords internal make_noticeable &lt;- function(msg) { paste(&quot;&quot;, &quot;======&quot;, &quot;Please read your friendly litr error message here:&quot;, paste(&quot;&gt; &quot;, msg), &quot;======&quot;, sep = &quot;\\n&quot;) } The code in this section used the fs and knitr packages, so we import those: usethis::use_package(&quot;fs&quot;) ## ✔ Adding &#39;fs&#39; to Imports field in DESCRIPTION ## • Refer to functions with `fs::fun()` usethis::use_package(&quot;knitr&quot;) ## ✔ Adding &#39;knitr&#39; to Imports field in DESCRIPTION ## • Refer to functions with `knitr::fun()` "],["hash.html", "5 Not overwriting a manually edited R package", " 5 Not overwriting a manually edited R package As described in the previous section, the function setup() will only overwrite a directory if it is the unedited output from using litr. The basic idea is that the function litr::render() when creating a new package finishes by adding a hash to the DESCRIPTION file. (And likewise when rmarkdown::render() is used with a litr output format, as described here.) This hash is a function of everything in the package, so if anything about the package changes (any file is modified, added, or removed) then the function check_unedited() will be able to detect that by recomputing the hash and seeing that it doesn’t match the hash in the DESCRIPTION file. Let’s start by defining the function hash_package_directory() that does the hashing. The hash is a function of everything in the outputted package except for that special line in the DESCRIPTION file with the hash. We use tools::md5sum() and digest::digest() to do the hashing. #&#39; Hash package directory #&#39; #&#39; Gets an identifier that can be used to uniquely (whp) identify the current #&#39; state of the package. This is formed by ignoring the `LitrId` field of the #&#39; DESCRIPTION file, which is the location where the output of this function is #&#39; stored when `litr::render` generates the package. #&#39; #&#39; @param package_dir Path to package #&#39; @keywords internal hash_package_directory &lt;- function(package_dir) { pkg_files &lt;- fs::dir_ls(package_dir, recurse = TRUE, all = TRUE, type = &quot;file&quot;) pkg_files &lt;- stringr::str_subset(pkg_files, &quot;.DS_Store$&quot;, negate = TRUE) pkg_files &lt;- normalizePath(pkg_files) descr_file &lt;- normalizePath(file.path(package_dir, &quot;DESCRIPTION&quot;)) i_descr &lt;- which(pkg_files == descr_file) if (length(i_descr) == 0) stop(&quot;Cannot find DESCRIPTION file.&quot;) txt_descr &lt;- readLines(pkg_files[i_descr]) txt_descr_mod &lt;- stringr::str_subset( txt_descr, stringr::str_glue(&quot;{description_litr_hash_field_name()}: .+$&quot;), negate = TRUE) hashes &lt;- as.character(tools::md5sum(pkg_files[-i_descr])) digest::digest(c(hashes, list(txt_descr_mod))) } We used digest, so let’s import it: usethis::use_package(&quot;digest&quot;) ## ✔ Adding &#39;digest&#39; to Imports field in DESCRIPTION ## • Refer to functions with `digest::fun()` We will store this hash in a special field within the DESCRIPTION file. Let’s call this field LitrId. However, in case we ever decide to change the name of this field, it’s better that we only define it in one place. So we do this with the following function: #&#39; Generate litr hash field name for DESCRIPTION file #&#39; @keywords internal description_litr_hash_field_name &lt;- function() return(&quot;LitrId&quot;) Ok, now let’s write the function that litr::render() will call that will take the generated R package and add a line that puts the hash in the DESCRIPTION file under that special litr field: #&#39; Write the hash of the package to the DESCRIPTION file #&#39; #&#39; @param package_dir Path to package #&#39; @keywords internal write_hash_to_description &lt;- function(package_dir) { desc_file &lt;- file.path(package_dir, &quot;DESCRIPTION&quot;) if (!file.exists(desc_file)) file.create(desc_file) hash &lt;- hash_package_directory(package_dir) desc::desc_set(description_litr_hash_field_name(), hash, file = desc_file) } Let’s include the desc package, which helps us manipulate DESCRIPTION files. usethis::use_package(&quot;desc&quot;) ## ✔ Adding &#39;desc&#39; to Imports field in DESCRIPTION ## • Refer to functions with `desc::fun()` And of course we’ll need a function that can read the value of that field as well: #&#39; Get the hash of the package from the DESCRIPTION file #&#39; #&#39; @param package_dir Path to package #&#39; @keywords internal read_hash_from_description &lt;- function(package_dir) { descr &lt;- file.path(package_dir, &quot;DESCRIPTION&quot;) if (!file.exists(descr)) stop(&quot;Cannot find DESCRIPTION file.&quot;) txt &lt;- stringr::str_subset( readLines(descr), stringr::str_glue(&quot;{description_litr_hash_field_name()}: .+$&quot;)) if (length(txt) &gt; 1) stop(&quot;More than one hash found in DESCRIPTION.&quot;) if (length(txt) == 0) stop(&quot;No hash found in DESCRIPTION.&quot;) stringr::str_extract(txt, &quot;\\\\S+$&quot;) } With all this hash functionality in place, the function check_unedited() is actually quite simple to define: #&#39; Check if package directory is the unedited output of litr::render() #&#39; #&#39; Uses hash stored in a special `litr` field of DESCRIPTION file to check that #&#39; the current state of the R package directory is identical to its state at the #&#39; time that it was created by `litr::render()`. #&#39; #&#39; @param package_dir Path to package #&#39; @keywords internal check_unedited &lt;- function(package_dir) { hash &lt;- hash_package_directory(package_dir) hash == read_hash_from_description(package_dir) } It simply computes the hash of the current package and checks whether that hash is the same as what was originally written to the DESCRIPTION file by litr::render(). "],["document.html", "6 Wrapper to devtools::document()", " 6 Wrapper to devtools::document() This function is nearly identical to devtools::document() except that it changes the roxygen2 message that says “Please edit documentation in R/[…].R” to instead mention the generating .Rmd file. When Rcpp is used, it also makes sure that #include &lt;RcppArmadillo.h&gt; comes before #include &lt;Rcpp.h&gt;. #&#39; Use roxygen to document a package from within a Rmd file #&#39; #&#39; This is a wrapper for the `devtools::document()` function, which in turn is a #&#39; wrapper for the `roxygen2::roxygenize()` function. It is written assuming that #&#39; it is being called from within a generating Rmd file. The purpose for `litr` #&#39; having this wrapper is two-fold. First, it ensures that the first line #&#39; in the outputted `Rd` files should not say &quot;Please edit documentation in #&#39; R/file.R&quot; but instead should refer to the Rmd file that generates everything. #&#39; Second, in the case that Rcpp is being used, it makes some adjustments to ensure #&#39; that the compiling of the C++ code should be successful. #&#39; #&#39; @param ... Arguments to be passed to `devtools::document()` #&#39; @export document &lt;- function(...) { # prepare Rcpp code for compiling if (fs::file_exists(&quot;src/code.cpp&quot;)) { # make sure that #include &lt;RcppArmadillo.h&gt; if it exists # comes *before* (or instead of) &lt;Rcpp.h&gt; txt &lt;- readLines(&quot;src/code.cpp&quot;) loc &lt;- stringr::str_which(txt, r&quot;(#include &lt;RcppArmadillo.h&gt;)&quot;) if (length(loc) &gt; 0) { include_arma_line &lt;- txt[loc[1]] txt &lt;- c(include_arma_line, txt[-loc]) writeLines(txt, &quot;src/code.cpp&quot;) } } devtools::document(...) # remove the line of the following form in each man/*.Rd file: pattern &lt;- &quot;% Please edit documentation in .*$&quot; msg &lt;- do_not_edit_message(knitr::current_input(), type = &quot;man&quot;) for (fname in fs::dir_ls(&quot;man&quot;)) { txt &lt;- stringr::str_replace(readLines(fname), pattern, msg) cat(paste(txt, collapse = &quot;\\n&quot;), file = fname) } } We used devtools, so let’s import it: usethis::use_package(&quot;devtools&quot;) ## ✔ Adding &#39;devtools&#39; to Imports field in DESCRIPTION ## • Refer to functions with `devtools::fun()` "],["rendering.html", "7 Altering the rendering process 7.1 Defining litr output formats 7.2 Defining litr::render()", " 7 Altering the rendering process The focus here is to make it so that all the special litr functionality will be active when the .Rmd is rendered. In particular, we need to make sure that setup() has been called before knitting occurs (so that, for example, send_to_package() will be active). We also need to make sure that after knitting certain things occur, such as the litr-hash being written to the package and, in some cases, hyperlinks are added for easier navigation. We implement two ways for the above to occur, which we describe in the next two subsections: The first approach is by defining custom litr output formats. When rmarkdown::render() (or bookdown::render_book()) is called with one of these litr output formats, the litr-specific operations occur before and after knitting. The second way is through the function litr::render(). If a user calls litr::render() with a non-litr output format, e.g. rmarkdown::html_document(), then it adds the necessary litr-specific operations before/after rmarkdown::render() is called. Another thing of note about litr::render() is that it renders the document in a fresh environment, which ensures identical behavior to when a user presses “Knit” in RStudio. Although these are presented as two separate approaches, we have written litr::render() so that if a user passes one of the litr output formats to litr::render(), it will still work. We encourage users to use litr::render()1 rather than rmarkdown::render() since in litr::render() we’re able to wrap the call to rmarkdown::render() in the function with_cleanup(). This ensures that, if an error occurs during the knitting process, the special litr hash will still be created. This is desirable since it means that the next time we try to litr-knit, we will not get an error about overwriting a manually edited package directory. When coding an R package with litr, sometimes there are code chunks that can take a while to evaluate (e.g., tests), which slows down the coding process. We therefore provide an argument (to both litr::render() and the various litr output formats) that allows for “minimal eval” to occur. The goal is to allow the R package to be updated completely but without any of the code chunks being evaluated, except those whose involving usethis or a call to litr::document(), since these commands lead to changes in the R package itself. 7.1 Defining litr output formats The function rmarkdown::render() allows for customizable behavior through the use of custom output formats. Given a preexisting output format (e.g. rmarkdown::html_document), we would like to modify it to have litr-behavior – i.e., to create a package as it is being rendered. This next function takes a preexisting output format and “litr-ifies” it by making three changes: It modifies the pre_knit() function. It modifies the post_processor() function. It adds a marker (litr_format &lt;- TRUE) that will help litr::render() know when a litr output format is being passed to it. We present the function and then describe the details of the new pre_knit() and post_processor() functions below. #&#39; Modify an existing output format to have `litr` behavior #&#39; #&#39; This function modifies the `pre_knit()` and `post_processor()` functions of a #&#39; preexisting output format so that it will have the `litr` behavior (meaning that an R package will be created when `rmarkdown::render()` is called). #&#39; #&#39; @param base_format a preexisting, non-litr output format such as `rmarkdown::html_document` #&#39; @param minimal_eval If `TRUE`, then only chunks with `litr::document()` or #&#39; `usethis` commands will be evaluated. This can be convenient in coding when #&#39; you just want to quickly update the R package without having to wait for long #&#39; evaluations to occur. #&#39; @export litrify_output_format &lt;- function(base_format = rmarkdown::html_document, minimal_eval = FALSE) { force(base_format) # I think using force here is advisable? force(minimal_eval) # https://adv-r.hadley.nz/function-factories.html function(...) { old &lt;- base_format(...) new &lt;- old new$original_knitr_objects &lt;- list() new$pre_knit &lt;- function(...) { args &lt;- list(...) input &lt;- args$input params &lt;- knitr::knit_params(readLines(input)) package_dir &lt;- get_package_directory( params$package_parent_dir$value, params$package_name$value, input) new$original_knitr_objects &lt;&lt;- litr:::setup(package_dir, minimal_eval) if (!is.null(old$pre_knit)) old$pre_knit(...) } new$post_processor &lt;- function(metadata, input_file, output_file, ...) { # typically the post_processor function returns the output file path # if old$post_processor is NULL, as in the case of pdf_document, # then R will throw an error when trying to call old$post_processor # if we only add a check for non null old$post_processor and otherwise # set out &lt;- NULL then R will throw an error later in rmarkdown::render # since output_file is set to the output of the post_processor if # output_format$post_processor is not null (See line 478 in rmarkdown::render) # Therefore, our solution is to set out to the output_file path if old$post_process is null. if (!is.null(old$post_processor)){ out &lt;- old$post_processor(metadata, input_file, output_file, ...) } else { out &lt;- output_file } package_dir &lt;- get_package_directory( metadata$params$package_parent_dir, metadata$params$package_name, input_file ) # remove .Rproj and .gitignore if usethis::create_package() added these remove_rstudio_extras(package_dir) # add to DESCRIPTION file the version of litr used to create package: write_version_to_description(package_dir) # add litr hash so we can tell later if package files were manually edited: write_hash_to_description(package_dir) out } new$on_exit &lt;- function() { old$on_exit() # restore knitr to its original state restore_knitr_objects(new$original_knitr_objects) } # mark this as a litr_format new$litr_format &lt;- TRUE # litr formats have minimal_eval as an option new$minimal_eval &lt;- minimal_eval new } } The pre_knit() function is modified so that setup() is called before the preexisting output format’s pre_knit() function is called. As the name suggests, this is a function that gets called before knitting. The purpose of the call to setup() is to create the R package directory and make it so that when we knit the file using rmarkdown::render(), a lot of special things will happen, such as code being sent to the R package directory. The function setup() returns the state of the knitr settings before any changes were made. This previous state of the knitr settings will be restored at the end of the rendering process in on_exit(). The post_processor() function is modified so that the DESCRIPTION file gets marked with the version of litr used and with the litr hash (as already described here). Some special care is taken for the case that the original output format doesn’t have a post processor (e.g., this is the case for the pdf_document output format). The particulars of this are given in a comment in the code chunk above. The on_exit() function is modified so that it restores the state of all the knitr settings to how it was when render was first called. We use the above function to create some litr versions of common output formats, as seen in the next few subsections. Before proceeding, we define the function write_version_to_description() that is called above. #&#39; Generate litr version field name for DESCRIPTION file #&#39; @keywords internal description_litr_version_field_name &lt;- function() return(&quot;LitrVersionUsed&quot;) #&#39; Write the version of litr used to the DESCRIPTION file #&#39; #&#39; @param package_dir Path to package #&#39; @keywords internal write_version_to_description &lt;- function(package_dir) { ver &lt;- as.character(utils::packageVersion(&quot;litr&quot;)) add_text_to_file( txt = stringr::str_glue(&quot;{description_litr_version_field_name()}: {ver}&quot;), filename = file.path(package_dir, &quot;DESCRIPTION&quot;), req_exist = TRUE ) } Also, we made use of a small function for getting the package directory based on the input file’s location and the parameters that are being used in the rendering process. We define it here: #&#39; Get package directory #&#39; #&#39; @param package_parent_dir The directory of where the package should go (relative to the input directory) #&#39; @param package_name The name of the package #&#39; @param input The file name of the input #&#39; @keywords internal get_package_directory &lt;- function(package_parent_dir, package_name, input) { if (package_parent_dir == &quot;.&quot;) return(file.path(dirname(input), package_name)) file.path(dirname(input), package_parent_dir, package_name) } Let’s write some tests to make sure it’s behaving as expected: testthat::test_that(&quot;get_package_directory() works&quot;, { input &lt;- file.path(&quot;inputdir&quot;, &quot;input.Rmd&quot;) testthat::expect_equal( get_package_directory(&quot;.&quot;, &quot;mypkg&quot;, input), file.path(&quot;inputdir&quot;, &quot;mypkg&quot;) # inputdir/mypkg ) testthat::expect_equal( get_package_directory(&quot;..&quot;, &quot;mypkg&quot;, input), file.path(&quot;inputdir&quot;, &quot;..&quot;, &quot;mypkg&quot;) # inputdir/../mypkg ) }) ## Test passed 7.1.1 .pdf output format We want our .pdf documents to accurately display the “logging” output from functions in packages such as devtools that use special ANSI escape codes for displaying information in the terminal. Unfortunately, these codes use escape characters which cause problems when creating .pdf versions of our documents. While it is relatively straightforward to map ANSI escape codes to HTML tags, as we will see in the .html output format section, converting these escape codes to Latex commands is more complicated. As a result, we define a post_knit function in our litr_pdf_document format to avoid this issue by stripping out all escape codes in the file before it is converted into a .tex file and then compiled into a .pdf document. Specifically, the post_knit function modifies the intermediate .knit.md file, which contains both the .Rmd file, as well as the output of each code chunk. Thus, we can inspect the output text of each code chunk and remove any ANSI escape codes before the .knit.md is converted to a .tex file and then a .pdf document. We rely upon two internal functions from the fansi R package to remove all possible escape codes and return a clean character vector. #&#39; litr version of `rmarkdown::pdf_document()` #&#39; #&#39; This behaves exactly like `rmarkdown::pdf_document()` except it creates an #&#39; R package. #&#39; #&#39; @param minimal_eval If `TRUE`, then only chunks with `litr::document()` or #&#39; `usethis` commands will be evaluated. This can be convenient in coding when #&#39; you just want to quickly update the R package without having to wait for long #&#39; evaluations to occur. #&#39; @param ... Parameters to be passed to `rmarkdown::pdf_document()` #&#39; @export litr_pdf_document &lt;- function(minimal_eval = FALSE, ...) { litr_pdf_document_ &lt;- litrify_output_format(rmarkdown::pdf_document, minimal_eval = minimal_eval) old &lt;- litr_pdf_document_(...) new &lt;- old # post_knit new$post_knit = function(...){ args = list(...) input_filename &lt;- args[[2]] knitted_filename &lt;- fs::path_ext_set(input_filename, &quot;.knit.md&quot;) knitted_output &lt;- readLines(knitted_filename) cleaned_output &lt;- sapply(1:length(knitted_output), function(i){ test_str &lt;- knitted_output[i] fansi:::VAL_IN_ENV(x=test_str, ctl=&quot;all&quot;, warn=TRUE, warn.mask=fansi:::get_warn_mangled()) .Call(fansi:::FANSI_strip_csi, test_str, CTL.INT, WARN.INT) }) writeLines(cleaned_output, knitted_filename) } new } Since the above section uses the fansi package for handling ANSI escape sequences, we include it in our package: usethis::use_package(&quot;fansi&quot;) ## ✔ Adding &#39;fansi&#39; to Imports field in DESCRIPTION ## • Refer to functions with `fansi::fun()` 7.1.2 .html output format For .html documents, we’d like to add a bit more in the postprocessing step. In particular, we include some special function and chunk hyperlinking behavior described below. The function add_function_hyperlinks() processes the outputted .html file(s), making it so that one can easily navigate to function definitions. (This function is described lower in this section.) We likewise call a function add_chunk_label_hyperlinks(), which makes chunk references into clickable links. In particular, the chunk reference &lt;&lt;my-chunk&gt;&gt; within a code chunk would link to a chunk named “my-chunk” that begins with ###\"my-chunk\"###. The ###\"my-chunk\"### line is added by a document hook defined in setup(). Finally, we replace ANSI sequences with HTML tag equivalents (the need for this is explained in the section on the .pdf output format). #&#39; litr version of `rmarkdown::html_document()` #&#39; #&#39; This behaves like `rmarkdown::html_document()` with a few differences: #&#39; - It creates an R package. #&#39; - It adds hyperlinks to function definitions whenever a function is used #&#39; elsewhere in the document. #&#39; - It does &quot;Knuth-style&quot; chunk referencing with hyperlinks. #&#39; #&#39; @param minimal_eval If `TRUE`, then only chunks with `litr::document()` or #&#39; `usethis` commands will be evaluated. This can be convenient in coding when #&#39; you just want to quickly update the R package without having to wait for long #&#39; evaluations to occur. #&#39; @param ... Parameters to be passed to `rmarkdown::pdf_document()` #&#39; @export litr_html_document &lt;- function(minimal_eval = FALSE, ...) { litr_html_document_ &lt;- litrify_output_format(rmarkdown::html_document, minimal_eval = minimal_eval) old &lt;- litr_html_document_(...) new &lt;- old # modify post_processor new$post_processor = function(metadata, input_file, output_file, ...) { out &lt;- old$post_processor(metadata, input_file, output_file, ...) # html_files &lt;- fs::dir_ls(fs::path_dir(out), regexp = &quot;.html$&quot;) # add hyperlinks within html output to make it easier to navigate: add_function_hyperlinks(output_file, metadata$params$package_name) add_chunk_label_hyperlinks(output_file) # replace ANSI sequences with HTML tag equivalents replace_ansi_sequences(output_file) out } new } We describe these two add_*_hyperlinks() functions next. The function add_function_hyperlinks() looks for foo followed by &lt;- function( and then wraps foo in a span tag with id=\"foo\"; whenever foo is found elsewhere in the document, it calls the insert_hrefs() function to wrap a a href=\"file.html#foo\" tag (where file.html is the file where foo is defined), so that it will be a hyperlink to foo’s definition. #&#39; Add hyperlinks to function definitions #&#39; #&#39; Finds functions that are defined in the html file(s) by looking for text of the #&#39; form `foo &lt;- function(` and then wraps `foo` in a `span` tag with `id=&quot;foo&quot;` #&#39; and then whenever `foo` is found it wraps a `a href=&quot;file.html#foo&quot;` tag so #&#39; that it will be a hyperlink to `foo`&#39;s definition. #&#39; #&#39; @param html_files Character vector of file names of html files that were created #&#39; from Rmd files #&#39; @param pkg_name Name of the package created by litr. Taken from YAML front matter #&#39; @keywords internal add_function_hyperlinks &lt;- function(html_files, pkg_name) { find_function_defs &lt;- function(html_file) { txt &lt;- readLines(html_file) start_line &lt;- which(txt == &quot;&lt;body&gt;&quot;) pattern1 &lt;- &#39;([a-zA-Z0-9_.]+)(\\\\s*&amp;lt;-\\\\s*function)&#39; pattern2 &lt;- stringr::str_replace(pattern1, &#39;&amp;lt;-&#39;, &#39;&lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt;&#39;) pattern2 &lt;- stringr::str_replace(pattern2, &#39;function&#39;, &#39;&lt;span class=&quot;cf&quot;&gt;function&lt;/span&gt;&#39;) # find functions that are defined in this file: function_names &lt;- character(0) for (pattern in c(pattern1, pattern2)) { for (i in seq(start_line + 1, length(txt))) { fn_name &lt;- stringr::str_match(txt[i], pattern)[, 2] if(is.na(fn_name)) next # a function was defined in this line, so put a span around it txt[i] &lt;- stringr::str_replace( txt[i], pattern, stringr::str_glue(&quot;&lt;span id=&#39;{fn_name}&#39;&gt;\\\\1&lt;/span&gt;\\\\2&quot;) ) # and keep track of it for later: function_names &lt;- c(function_names, fn_name) } } list(function_names = function_names, txt = txt) } fdefs &lt;- lapply(html_files, find_function_defs) all_function_names &lt;- unlist(lapply(fdefs, function(lst) lst$function_names)) # if a function is defined multiple times, then it&#39;s ambiguous where to link to # so let&#39;s not try linking to it (this can occur when a function is defined # within a function, such as `new$post_processor()`) repeated &lt;- names(which(table(all_function_names) &gt; 1)) all_function_names &lt;- setdiff(all_function_names, repeated) if (length(all_function_names) == 0) { # no functions defined in package, so nothing more to be done here return() } num_per_file &lt;- unlist(lapply(fdefs, function(lst) { length(setdiff(lst$function_names, repeated)) })) where_defined &lt;- rep(fs::path_file(html_files), times = num_per_file) defined_functions_pattern &lt;- paste0(&quot;(::)?&quot;,all_function_names, &quot;\\\\(&quot;, collapse = &quot;|&quot;) # There&#39;s also this case: &lt;span class=&quot;fu&quot;&gt;myfunction&lt;/span&gt; defined_functions_pattern2 &lt;- paste0( &#39;&lt;span class=&quot;fu&quot;&gt;&#39;, all_function_names, &#39;&lt;/span&gt;\\\\(&#39;, collapse = &quot;|&quot;) for (i in seq_along(html_files)) { # whenever one of the defined functions is named, link to its definition # using the format `file_where_foo_is_defined.html#foo` modified_txt &lt;- insert_hrefs(fdefs[[i]]$txt, defined_functions_pattern, where_defined, all_function_names, pkg_name) modified_txt &lt;- insert_hrefs(modified_txt, defined_functions_pattern2, where_defined, all_function_names, pkg_name, remove_span=TRUE) writeLines(modified_txt, con = html_files[i]) } } We define next the helper function insert_hrefs(), which was called in the previous function. If the function foo() is defined in the .Rmd file that defines a package named pkg, then whenever foo() or pkg::foo() appears in the .Rmd, a link will be added; however, if other_pkg::foo() appears, then no link will be added. #&#39; Replace a function&#39;s name with a link to its definition #&#39; #&#39; A helper function for `add_function_hyperlinks` that wraps references to a #&#39; function in an anchor tag with a link to the function&#39;s definition. #&#39; #&#39; @param txt Character vector where each element is a row of the knitted HTML file. #&#39; @param function_pattern Regular Expression passed from `add_function_hyperlinks` that contains all referenced functions in the document. #&#39; @param where_defined Character vector that contains the name of the file in which a function was defined. #&#39; @param all_function_names Character vector of all referenced functions in the document. #&#39; @param pkg_name Name of the package created by litr. Taken from YAML front matter. #&#39; @param remove_span Boolean argument for removing span tags. Used for minimizing code duplication. #&#39; @keywords internal insert_hrefs &lt;- function(txt, function_pattern, where_defined, all_function_names, pkg_name, remove_span=FALSE){ # filter down matches of defined_functions_pattern has_fn_name &lt;- which(stringr::str_detect(txt, function_pattern)) has_colon_prefix &lt;- which(stringr::str_detect(txt, paste0(&quot;::&quot;, all_function_names, &quot;\\\\(&quot;, collapse = &quot;|&quot;))) has_only_fn_name &lt;- setdiff(has_fn_name, has_colon_prefix) has_pkg_colon_prefix &lt;- which(stringr::str_detect(txt, paste0(stringr::str_glue(&quot;{pkg_name}::&quot;)))) # define different replacement functions for colon prefix cases and regular cases colon_pref_replace_fn &lt;- function(x){ if(remove_span){ fn_name &lt;- stringr::str_remove(x, &quot;&lt;/span&gt;\\\\(&quot;) fn_name &lt;- stringr::str_remove(fn_name, &#39;&lt;span class=&quot;fu&quot;&gt;&#39;) } else{ fn_name &lt;- stringr::str_remove(x, &quot;\\\\(&quot;) } fn_name &lt;- stringr::str_remove(fn_name, stringr::str_glue(&#39;{pkg_name}::&#39;)) # implicitly assuming that a function is not redefined in another file def_file &lt;- where_defined[all_function_names == fn_name] return(stringr::str_glue(&quot;{pkg_name}::&lt;a href=&#39;{def_file}#{fn_name}&#39;&gt;{fn_name}&lt;/a&gt;(&quot;)) } regular_replace_fn &lt;- function(x){ if(remove_span){ fn_name &lt;- stringr::str_remove(x, &#39;&lt;/span&gt;\\\\(&#39;) fn_name &lt;- stringr::str_remove(fn_name, &#39;&lt;span class=&quot;fu&quot;&gt;&#39;) } else { fn_name &lt;- stringr::str_remove(x, &quot;\\\\(&quot;) } # implicitly assuming that a function is not redefined in another file def_file &lt;- where_defined[all_function_names == fn_name] stringr::str_glue(&quot;&lt;a href=&#39;{def_file}#{fn_name}&#39;&gt;{fn_name}&lt;/a&gt;(&quot;) } colon_prefix_function_pattern &lt;- paste0(stringr::str_glue(&quot;{pkg_name}::&quot;),all_function_names, &quot;\\\\(&quot;, collapse = &quot;|&quot;) colon_prefix_refs &lt;- stringr::str_replace_all( txt[has_pkg_colon_prefix], colon_prefix_function_pattern, colon_pref_replace_fn ) regular_refs &lt;- stringr::str_replace_all( txt[has_only_fn_name], function_pattern, regular_replace_fn ) # now put back in the changed lines txt[has_pkg_colon_prefix] &lt;- colon_prefix_refs txt[has_only_fn_name] &lt;- regular_refs txt } In addition to adding hyperlinks to function definitions, we also want to add hyperlinks for chunk references of the form &lt;&lt;chunk-name&gt;&gt; that link to user-defined chunk names that take the form ###chunk-name###. We want these user-defined chunk names to stand out to readers and in their original form as code comments they might be harder to notice. To solve this issue, we modify the formatting of these chunks to add a border with the name of the chunk set into the border, mimicking the look of a &lt;fieldset&gt; tag. The additional formatting requires inserting additional HTML tags as well as css into the knitted HTML file so we use the xml2 package to parse and manipulate the knitted HTML file. #&#39; Add hyperlinks to embedded chunks #&#39; #&#39; Finds chunks that are referenced in the html file(s) by looking for comments #&#39; of the form `###&quot;foo&quot;###` and then wraps `foo` in a `span` tag with `id=&quot;foo&quot;` #&#39; and then whenever the chunk label `&lt;&lt;foo&gt;&gt;` is found it wraps it in a #&#39; `a href=&quot;file.html#foo&quot;` tag so that it will be a hyperlink to `foo`&#39;s #&#39; definition. #&#39; #&#39; @param html_files Character vector of file names of html files that were created #&#39; from Rmd files #&#39; @param reference_start The delimiter used to indicate the start of a chunk label #&#39; @param reference_end The delimiter used to indicate the end of a chunk label #&#39; @keywords internal add_chunk_label_hyperlinks &lt;- function(html_files, reference_start = &quot;&amp;lt;&amp;lt;&quot;, reference_end = &quot;&amp;gt;&amp;gt;&quot;){ find_chunk_defs &lt;- function(html_file) { txt &lt;- readLines(html_file) start_line &lt;- which(txt == &quot;&lt;body&gt;&quot;) pattern &lt;- &#39;###&amp;quot;([a-zA-Z0-9-_.]+)&amp;quot;###&#39; # find chunks that are defined in this file: chunk_names &lt;- character(0) for (i in seq(start_line + 1, length(txt))) { chunk_name &lt;- stringr::str_match(txt[i], pattern)[, 2] if(is.na(chunk_name)) next # a chunk was defined in this line, so put a span around it txt[i] &lt;- stringr::str_replace( txt[i], pattern, stringr::str_glue(&quot;&lt;span id=&#39;{chunk_name}&#39;&gt;###&amp;quot;\\\\1&amp;quot;###&lt;/span&gt;&quot;) ) # and keep track of it for later. # we&#39;re using setNames here to make sure that we keep the name of file # where the chunk name is defined chunk_names &lt;- setNames(c(chunk_names, chunk_name), c(names(chunk_names), html_file)) } list(chunk_names = chunk_names, txt = txt) } cdefs &lt;- lapply(html_files, find_chunk_defs) all_chunk_names &lt;- unlist(lapply(cdefs, function(lst) lst$chunk_names)) num_per_file &lt;- unlist(lapply(cdefs, function(lst) length(lst$chunk_names))) where_defined &lt;- rep(fs::path_file(html_files), times = num_per_file) defined_chunks_pattern &lt;- paste0(reference_start, all_chunk_names, reference_end, collapse = &quot;|&quot;) ref_start &lt;- &#39;&lt;span class=&quot;sc&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;&amp;lt;&lt;/span&gt;&#39; ref_start_alt &lt;- &#39;&lt;span class=\\&quot;er\\&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&#39; ref_end &lt;- &#39;&lt;span class=&quot;sc&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;&amp;gt;&lt;/span&gt;&#39; hyphen_with_extras &lt;- &#39;&lt;span class=&quot;sc&quot;&gt;-&lt;/span&gt;&#39; all_chunk_names2 &lt;- stringr::str_replace_all(all_chunk_names, &quot;-&quot;, hyphen_with_extras) defined_chunks_pattern2 &lt;- paste0( ref_start, all_chunk_names2, ref_end, collapse = &quot;|&quot; ) defined_chunks_pattern2_alt &lt;- paste0( ref_start_alt, all_chunk_names2, ref_end, collapse = &quot;|&quot; ) defined_chunks_pattern2 &lt;- paste( defined_chunks_pattern2, defined_chunks_pattern2_alt, sep = &quot;|&quot; ) for (i in seq_along(html_files)) { # whenever one of these named chunks is referenced, link to its definition # using the format `file_where_chunk_is_defined.html#chunkname` txt &lt;- stringr::str_replace_all( cdefs[[i]]$txt, defined_chunks_pattern, function(x) { cname &lt;- stringr::str_remove_all( x, paste(reference_start, reference_end, sep = &quot;|&quot;) ) def_file &lt;- where_defined[all_chunk_names == cname] stringr::str_glue( &quot;&lt;a href=&#39;{def_file}#{cname}&#39;&gt;{reference_start}{cname}{reference_end}&lt;/a&gt;&quot; ) } ) txt &lt;- stringr::str_replace_all( txt, defined_chunks_pattern2, function(x) { cname &lt;- stringr::str_remove_all( x, paste(ref_start, ref_start_alt, ref_end, sep = &quot;|&quot;) ) def_file &lt;- where_defined[all_chunk_names2 == cname] cname &lt;- stringr::str_replace_all(cname, hyphen_with_extras, &quot;-&quot;) stringr::str_glue( &quot;&lt;a href=&#39;{def_file}#{cname}&#39;&gt;{reference_start}{cname}{reference_end}&lt;/a&gt;&quot; ) } ) parsed_html &lt;- xml2::read_html(paste(txt,collapse=&quot;\\n&quot;)) # get all possible chunk names in this file. chunk_names &lt;- all_chunk_names[which(names(all_chunk_names) == html_files[i])] if(length(chunk_names) &gt; 0){ for(j in seq_along(chunk_names)){ span_node &lt;- xml2::xml_find_first(parsed_html, stringr::str_glue(&#39;(.//span[@id=&quot;{chunk_names[j]}&quot;])&#39;)) span_node_path &lt;- stringr::str_split(xml2::xml_path(span_node),&quot;/&quot;) pre_path &lt;- paste(span_node_path[[1]][1:(max(which(stringr::str_detect(span_node_path[[1]], &quot;pre&quot;))))],collapse=&quot;/&quot;) if(nchar(pre_path) == 0){ next() } pre_parent &lt;- xml2::xml_find_first(parsed_html, pre_path) if(is.na(pre_parent)){ next() } xml2::xml_add_parent(pre_parent , xml2::read_xml(stringr::str_glue(&#39;&lt;fieldset id=&quot;{chunk_names[j]}&quot; class=&quot;chunkfield&quot;&gt; &lt;/fieldset&gt;&#39;))) xml2::xml_add_sibling(pre_parent, xml2::read_xml(stringr::str_glue(&#39;&lt;legend class=&quot;chunklegend&quot;&gt;{chunk_names[j]}&lt;/legend&gt;&#39;)), where=&quot;before&quot;) xml2::xml_remove(span_node) # remove the extra line break that is left over from removing the span code_node &lt;- xml2::xml_child(pre_parent) changed_txt &lt;- stringr::str_remove(paste(as.character(xml2::xml_contents(code_node)),collapse=&quot;&quot;), &#39;\\n&#39;) xml2::xml_replace(code_node, xml2::read_xml(stringr::str_glue(&#39;&lt;code&gt;{changed_txt}&lt;/code&gt;&#39;))) } } # last thing is to insert an additional style node in the head with our CSS so we have a standard style whether we are using bookdown or Rmarkdown css_string &lt;- &quot;fieldset.chunkfield {border:1px dotted black;padding-bottom: 0px;padding-top: 0px;margin:0 2px;padding:.35em .625em .75em} legend.chunklegend {padding:0;width:auto;border:0; border-bottom: none; margin-bottom:0} &quot; head_node &lt;- xml2::xml_find_first(parsed_html, &quot;.//head&quot;) xml2::xml_add_child(head_node, xml2::read_xml(stringr::str_glue(&quot;&lt;style type=&#39;text/css&#39;&gt;{css_string}&lt;/style&gt;&quot;))) txt &lt;- xml2::write_html(parsed_html, html_files[i]) } } Since we rely on the xml2 package to add in the extra label formatting, let’s import it: usethis::use_package(&quot;xml2&quot;) ## ✔ Adding &#39;xml2&#39; to Imports field in DESCRIPTION ## • Refer to functions with `xml2::fun()` Finally, we want to replace the ANSI escape sequences used by packages such as testthat and devtools with their HTML equivalents so the output matches what we see in the terminal. #&#39; Replace ANSI escape sequences with their HTML equivalents #&#39; #&#39; Finds ANSI escape sequences and replaces them with HTML tags using the `fansi` package #&#39; #&#39; @param html_files Character vector of file names of html files that were created #&#39; from Rmd files #&#39; @keywords internal replace_ansi_sequences &lt;- function(html_files) { for (i in seq_along(html_files)) { file_lines &lt;- readLines(html_files[i]) # look for lines with escape sequences for URLs and remove the URL # escape sequences before we convert to HTML url_code_regex &lt;- &quot;\\\\033]8;;.*\\\\a(.*?)\\\\033]8;;\\\\a&quot; url_seq_idx &lt;- which(stringr::str_detect(file_lines, url_code_regex)) file_lines[url_seq_idx] &lt;- sapply(url_seq_idx, function(idx){ line &lt;- file_lines[idx] stringr::str_replace(line, url_code_regex, stringr::str_glue(&quot;\\\\1&quot;)) }) txt &lt;- fansi::sgr_to_html(x = file_lines, warn = FALSE, term.cap = &quot;256&quot;) writeLines(txt, con = html_files[i]) } } 7.1.3 bookdown output format It turns out that our modification to the bookdown::gitbook() format’s postprocessor is identical to the above. This suggests that we should probably reuse code more effectively. But for now I will leave it how it is: #&#39; litr version of `bookdown::gitbook()` #&#39; #&#39; This behaves like `bookdown::gitbook()` with a few differences: #&#39; - It creates an R package. #&#39; - It adds hyperlinks to function definitions whenever a function is used #&#39; elsewhere in the document. #&#39; - It does &quot;Knuth-style&quot; chunk referencing with hyperlinks. #&#39; #&#39; @param minimal_eval If `TRUE`, then only chunks with `litr::document()` or #&#39; `usethis` commands will be evaluated. This can be convenient in coding when #&#39; you just want to quickly update the R package without having to wait for long #&#39; evaluations to occur. #&#39; @param ... Parameters to be passed to `bookdown::gitbook()` #&#39; @export litr_gitbook &lt;- function(minimal_eval = FALSE, ...) { litr_gitbook_ &lt;- litrify_output_format(bookdown::gitbook, minimal_eval = minimal_eval) old &lt;- litr_gitbook_(...) new &lt;- old # modify post_processor new$post_processor = function(metadata, input_file, output_file, ...) { out &lt;- old$post_processor(metadata, input_file, output_file, ...) out_dir &lt;- fs::path_dir(out) file_stems &lt;- readLines(file.path(out_dir, &quot;reference-keys.txt&quot;)) html_files &lt;- file.path(out_dir, paste0(file_stems, &quot;.html&quot;)) html_files &lt;- unique(intersect(c(out, html_files), fs::dir_ls(out_dir))) # add hyperlinks within html output to make it easier to navigate: add_function_hyperlinks(html_files, metadata$params$package_name) add_chunk_label_hyperlinks(html_files) # replace ANSI sequences with HTML tag equivalents replace_ansi_sequences(html_files) out } new } To use this output format, one would use bookdown::render_book() instead of rmarkdown::render(). In particular: bookdown::render_book(output_format = litr::litr_gitbook()) The preamble in index.Rmd would look something like this: --- title: &quot;A `litr` Book&quot; author: &quot;Your Name&quot; site: bookdown::bookdown_site params: package_name: &quot;frombookdown&quot; # &lt;-- change this to your package name package_parent_dir: &quot;.&quot; # &lt;-- relative to this file&#39;s location documentclass: book --- Or one can add to the preamble the lines knit: litr::render output: litr::litr_gitbook This first line makes it so that in RStudio when you press “Knit”, it calls litr::render(), and the second line makes it so that it will use the special litr bookdown output format. Since the above function uses bookdown, we include it in our package: usethis::use_package(&quot;bookdown&quot;) ## ✔ Adding &#39;bookdown&#39; to Imports field in DESCRIPTION ## • Refer to functions with `bookdown::fun()` 7.2 Defining litr::render() There are two primary use cases for this function: To render a .Rmd with a non-litr output format (e.g., rmarkdown::html_document) in such a way that it will generate an R package (and include the special litr-hyperlinking if .html files were created). To render a .Rmd with a litr output format (including the litr_gitbook() format). The second use case might seem unnecessary in that rmarkdown::render(&quot;create-pkg.Rmd&quot;, output_format = litr::litr_html_document()) or bookdown::render_book(&quot;index.Rmd&quot;, output_format = litr::litr_gitbook()) would do what we want. However, a reason to still prefer litr::render() is that this function ensures the identical behavior to when one clicks the “Knit” in RStudio. It does this by opening a fresh R session (when fresh_session=TRUE, which is the default) in which rmarkdown::render() (or bookdown::render_book()) is called. This is based on the description in the Rmarkdown Cookbook. Another reason to prefer litr::render() is that if there is an error in the rendering process, the special litr hash will still be written to the DESCRIPTION file. This means that after fixing that error when one calls litr::render(), one will not get the error telling the user to delete the partially generated package directory. We accomplish this with the function with_cleanup() defined below. In the first use case, litr::render() is responsible for ensuring all the special litr things happen (like setup() being called before knitting, the litr-hash being written afterwards, and hyperlinking occurs). The details of what it does is very similar to what is described in the output formats section, especially the one on the html output format. One thing that is different is that we need a function get_params_used(), defined at the end of this section, that gets the actual parameters that are used so that the location of the outputted package can be found. #&#39; Render R markdown file #&#39; #&#39; Wrapper to `rmarkdown::render()` that produces an R package as output in #&#39; addition to the standard output document. It does some post-processing on the #&#39; .html file when that is the output. In particular, when an .html file is among #&#39; the outputs, it adds hyperlinks to functions defined within the file to make #&#39; it easier for someone reading the code to see where different functions are #&#39; defined. #&#39; #&#39; @param input The input file to be rendered (see `rmarkdown::render`) #&#39; @param minimal_eval If `TRUE`, then only chunks with `litr::document()` or #&#39; `usethis` commands will be evaluated. This can be convenient in coding when #&#39; you just want to quickly update the R package without having to wait for long #&#39; evaluations to occur. #&#39; @param fresh_session Whether to call `rmarkdown::render` from a fresh R #&#39; session. By default TRUE, so that it matches the behavior of pressing &quot;Knitr&quot; #&#39; in RStudio. However, for debugging it can be useful to set this to FALSE so #&#39; that functions like `debug()` and `browser()` will work. #&#39; @param ... Additional parameters to pass to `rmarkdown::render` #&#39; @export render &lt;- function(input, minimal_eval, fresh_session = TRUE, ...) { # call rmarkdown::render in a new environment so it behaves the same as # pressing the knit button in RStudio: # https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-render.html args &lt;- list(...) # let&#39;s determine if the output format being used is a litr format. # If it is, then we&#39;ll simply want to call rmarkdown::render() since the # special litr behavior will be attained through the output format. litr_format &lt;- FALSE bookdown_format &lt;- FALSE output_format_arg &lt;- FALSE if (&quot;output_format&quot; %in% names(args)) { output_format_arg &lt;- TRUE if (&quot;litr_format&quot; %in% names(args$output_format)) { litr_format &lt;- TRUE } if (&quot;bookdown_output_format&quot; %in% names(args$output_format)) { bookdown_format &lt;- TRUE } } else { frontmatter &lt;- rmarkdown::yaml_front_matter(input) if (&quot;output&quot; %in% names(frontmatter)) { formats &lt;- ifelse(is.list(frontmatter$output), names(frontmatter$output), frontmatter$output) if (any(stringr::str_detect(formats, &quot;litr::&quot;))) { litr_format &lt;- TRUE } if (any(stringr::str_detect(formats, &quot;litr::litr_gitbook&quot;))) { bookdown_format &lt;- TRUE } } } # get package_directory params &lt;- get_params_used(input, args$params) package_dir &lt;- get_package_directory( params$package_parent_dir, params$package_name, input ) # if minimal_eval was passed to render, add this to the output_options # argument that will be passed to rmarkdown::render if (is.null(args$output_options)) args$output_options &lt;- list() if (!missing(minimal_eval)) args$output_options$minimal_eval &lt;- minimal_eval # determine whether a new R session will be created when we run the rendering # function of rmarkdown/bookdown if (fresh_session) run_function &lt;- xfun::Rscript_call else run_function &lt;- do.call if (litr_format) { # this uses a litr output format, so we don&#39;t need to do anything litr-specific # here because it will happen through the output format if (output_format_arg &amp; !missing(minimal_eval)) { # the output format was passed through the output_format argument rather # than through the metadata if (minimal_eval) { stop(make_noticeable(paste( &quot;When passing a litr output format using the output_format argument,&quot;, &quot;you should not pass minimal_eval = TRUE directly to render.&quot;, &quot;Instead, pass it to the litr output format function. For example,&quot;, &quot;litr::litr_html_document(minimal_eval = TRUE).&quot;, collapse = &quot; &quot; ))) } } if (bookdown_format) { if (fs::is_file(input)) input &lt;- fs::path_dir(input) return(invisible(run_function(with_cleanup(bookdown::render_book, package_dir), c(input = input, args)))) } else return(invisible(run_function(with_cleanup(rmarkdown::render, package_dir), c(input = input, args)))) } # the output format being used is not a litr-specific one, so we need to make # sure that all the special litr things happen args$package_dir &lt;- package_dir render_ &lt;- function(input, package_dir, minimal_eval, ...) { knitr_objects &lt;- litr:::setup(package_dir, minimal_eval) out &lt;- rmarkdown::render(input, ...) restore_knitr_objects(knitr_objects) # remove .Rproj and .gitignore if usethis::create_package() added these remove_rstudio_extras(package_dir) return(out) } if (missing(minimal_eval)) minimal_eval &lt;- FALSE out &lt;- run_function(with_cleanup(render_, package_dir), c(input = input, minimal_eval = minimal_eval, args)) # add hyperlinks within html output to make it easier to navigate: if (any(stringr::str_detect(out, &quot;html$&quot;))) { html_file &lt;- stringr::str_subset(out, &quot;html$&quot;) add_function_hyperlinks(html_file, params$package_name) add_chunk_label_hyperlinks(html_file) } # add to DESCRIPTION file the version of litr used to create package: write_version_to_description(package_dir) # add litr hash so we can tell later if package files were manually edited: write_hash_to_description(package_dir) } We used the package xfun, so let’s import it: usethis::use_package(&quot;xfun&quot;) ## ✔ Adding &#39;xfun&#39; to Imports field in DESCRIPTION ## • Refer to functions with `xfun::fun()` When litr::render() encounters an error, it can leave the output directory partially modified. We want to make sure the litr hash still gets written to the DESCRIPTION file. Otherwise, the next time one calls litr::render() it does not allow this directory to be overwritten. We do this by using withCallingHandlers(). This function, explained here, is similar to tryCatch(), but with the advantage that it lets the function to continue to run normally, meaning that we will still get the error message as it would appear if we hadn’t done the condition handling. #&#39; Add litr hash to DESCRIPTION file if error encountered #&#39; #&#39; This creates a function that calls the passed function within the context of #&#39; a try-catch. If an error is encountered, the litr hash is still added to #&#39; the DESCRIPTION file so that future calls to `litr::render()` will recognize #&#39; that it can safely overwrite the package directory (i.e., no manual editing #&#39; occurred). #&#39; #&#39; @param fun function being called #&#39; @param package_dir directory where package is being written to #&#39; @param ... arguments to be passed to `fun` #&#39; @keywords internal with_cleanup &lt;- function(fun, package_dir) { return(function(...) { withCallingHandlers( fun(...), error = function(e) { # add litr hash so we can tell later if package files were manually edited: write_hash_to_description(package_dir) }) }) } In setup(), we modified the knitr objects (e.g., adding hooks, engines, etc.). We call the function restore_knitr_objects() after we’re done, to put things back how they were: #&#39; Return the knitr objects to their original state #&#39; #&#39; @param original_knitr_objects As returned by `setup()` #&#39; @keywords internal restore_knitr_objects &lt;- function(original_knitr_objects) { knitr::opts_knit$restore(original_knitr_objects$opts_knit) knitr::knit_hooks$restore(original_knitr_objects$knit_hooks) knitr::opts_chunk$restore(original_knitr_objects$opts_chunk) knitr::opts_hooks$restore(original_knitr_objects$opts_hooks) knitr::knit_engines$restore(original_knitr_objects$knit_engines) } Another thing we want to do at the end of the rendering process is to remove two files that might have been created by usethis: .Rproj and .gitignore. These are created by usethis::create_package() when rstudio = TRUE. We don’t want these files created since this would suggest to a user that the R package should be worked on from within it rather than from the generating .Rmd file. #&#39; Remove extra files added by usethis #&#39; #&#39; Remove .Rproj and .gitignore files if they are in the package directory. #&#39; #&#39; @param package_dir Path to package #&#39; @keywords internal remove_rstudio_extras &lt;- function(package_dir) { extras &lt;- fs::dir_ls(package_dir, all = TRUE, regexp = &quot;[.]Rproj$|[.]gitignore$&quot;) rbuildignore &lt;- file.path(package_dir, &quot;.Rbuildignore&quot;) txt &lt;- readLines(rbuildignore) txt &lt;- stringr::str_subset(txt, &quot;^.*Rproj.*$&quot;, negate = TRUE) writeLines(txt, con = rbuildignore) for (extra in extras) fs::file_delete(extra) } As described earlier, the function get_params_used() combines the parameters from the YAML but allows for those values to be overridden through arguments passed to render(). #&#39; Get parameter values used in rendering #&#39; #&#39; When the `params` argument of `rmarkdown::render()` is explicitly used, this #&#39; overrides the default that appears in `input`. #&#39; @param input The input file to be rendered (see `rmarkdown::render`) #&#39; @param passed_params The list of parameters that were passed to `render`. #&#39; @keywords internal get_params_used &lt;- function(input, passed_params) { params &lt;- rmarkdown::yaml_front_matter(input)$params for (param in names(passed_params)) { params[[param]] &lt;- passed_params[[param]] } params } We used the package rmarkdown, so let’s import it: usethis::use_package(&quot;rmarkdown&quot;) ## ✔ Adding &#39;rmarkdown&#39; to Imports field in DESCRIPTION ## • Refer to functions with `rmarkdown::fun()` For example, we include the line knit: litr::render in the yaml of the templates for this reason.↩︎ "],["functionality-to-facilitate-workflow.html", "8 Functionality to facilitate workflow 8.1 Load all 8.2 Templates", " 8 Functionality to facilitate workflow 8.1 Load all When someone is writing an R package with devtools, it is common to use devtools::load_all() to quickly try out the functions of an R package in the console. We’d like to allow for a similar workflow using litr. We define a litr function called load_all(), which will do the following: Litr-knit the .Rmd file with minimal_eval=TRUE to some temporary location (since the idea of load_all() is to leave the .html file alone) and then delete the .html file. Run devtools::load_all() on the output. #&#39; Load complete package #&#39; #&#39; This is a litr wrapper to `devtools::load_all()`. It first calls #&#39; `litr::render()` with `minimal_eval=TRUE`, then it calls #&#39; `devtools::load_all()` on the generated package. #&#39; #&#39; @param input The input file to be rendered (see `rmarkdown::render`) #&#39; @param output_dir By default (and in typical usage) this is NULL, meaning #&#39; that no .html/bookdown/.pdf will result. However, when a directory is given, #&#39; the result of the litr-knitting will be saved to this location. #&#39; @param ... Additional parameters to be passed to `devtools::load_all()` #&#39; @export load_all &lt;- function(input, output_dir = NULL, ...) { no_output &lt;- is.null(output_dir) if (no_output) { output_dir &lt;- tempfile() if (fs::file_exists(output_dir)) fs::file_delete(output_dir) fs::dir_create(output_dir) } # let&#39;s copy over everything from input directory to output directory fs::dir_copy(fs::path_dir(input), output_dir, overwrite = TRUE) input_path &lt;- fs::path_split(input)[[1]] moved_input &lt;- file.path(output_dir, fs::path_file(input)) # get package directory params &lt;- get_params_used(moved_input, list()) package_dir &lt;- get_package_directory( params$package_parent_dir, params$package_name, moved_input ) # but if a package directory was copied here, let&#39;s remove it before # calling render to avoid a potential error if (fs::dir_exists(package_dir)) fs::dir_delete(package_dir) litr::render(moved_input, minimal_eval = TRUE, output_dir = output_dir, quiet = TRUE) new_package_dir &lt;- file.path(fs::path_dir(input), params$package_name) fs::dir_copy(package_dir, new_package_dir, overwrite = TRUE) if (no_output) fs::dir_delete(output_dir) devtools::load_all(new_package_dir) } Let’s test that this works. In particular, we’ll call load_all() and then try to use one of the functions from the package. testthat::test_that(&#39;load_all() works&#39;, { # setup files for tests: dir &lt;- tempfile() if (fs::file_exists(dir)) fs::file_delete(dir) fs::dir_create(dir) rmd_file &lt;- file.path(dir, &#39;create-pkg.Rmd&#39;) fs::file_copy(testthat::test_path(&quot;create-pkg.Rmd&quot;), rmd_file) html_file &lt;- file.path(dir, &quot;create-pkg.html&quot;) load_all(rmd_file) testthat::expect_equal(say_hello(&quot;Jacob&quot;), &quot;Hello Jacob!&quot;) fs::dir_delete(dir) }) 8.2 Templates 8.2.1 Including template files in package We now add the .Rmd templates to the package. We have the skeleton.Rmd for each template defined in source-files. Note that paths are relative to the outputted package’s location. The first template is the simplest imaginable package with a single function: usethis::use_rmarkdown_template( template_name = &quot;Template To Make an R Package&quot;, template_dir = &quot;make-an-r-package&quot;, template_description = &quot;Template for an Rmd file for writing an R package using literate programming.&quot;, template_create_dir = FALSE ) ## ✔ Creating &#39;inst/rmarkdown/templates/make-an-r-package/skeleton/&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package/template.yaml&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package/skeleton/skeleton.Rmd&#39; fs::file_copy( path = file.path( &quot;..&quot;, &quot;source-files&quot;, &quot;make-an-r-package&quot;, &quot;skeleton.Rmd&quot; ), new_path = file.path( &quot;inst&quot;, &quot;rmarkdown&quot;, &quot;templates&quot;, &quot;make-an-r-package&quot;, &quot;skeleton&quot; ), overwrite = TRUE ) The second template shows how to create a package with a dataset: usethis::use_rmarkdown_template( template_name = &quot;Template To Make an R Package With a Dataset&quot;, template_dir = &quot;make-an-r-package-with-data&quot;, template_description = &quot;Template for an Rmd file for writing an R package with a dataset using literate programming.&quot;, template_create_dir = FALSE ) ## ✔ Creating &#39;inst/rmarkdown/templates/make-an-r-package-with-data/skeleton/&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-with-data/template.yaml&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-with-data/skeleton/skeleton.Rmd&#39; fs::file_copy( path = file.path( &quot;..&quot;, &quot;source-files&quot;, &quot;make-an-r-package-with-data&quot;, &quot;skeleton.Rmd&quot; ), new_path = file.path( &quot;inst&quot;, &quot;rmarkdown&quot;, &quot;templates&quot;, &quot;make-an-r-package-with-data&quot;, &quot;skeleton&quot; ), overwrite = TRUE ) The third template shows how to create a package that uses Rcpp: usethis::use_rmarkdown_template( template_name = &quot;Template To Make an R Package With Rcpp&quot;, template_dir = &quot;make-an-r-package-with-rcpp&quot;, template_description = &quot;Template for an Rmd file for writing an R package that makes use of Rcpp while using literate programming.&quot;, template_create_dir = FALSE ) ## ✔ Creating &#39;inst/rmarkdown/templates/make-an-r-package-with-rcpp/skeleton/&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-with-rcpp/template.yaml&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-with-rcpp/skeleton/skeleton.Rmd&#39; fs::file_copy( path = file.path( &quot;..&quot;, &quot;source-files&quot;, &quot;make-an-r-package-with-rcpp&quot;, &quot;skeleton.Rmd&quot; ), new_path = file.path( &quot;inst&quot;, &quot;rmarkdown&quot;, &quot;templates&quot;, &quot;make-an-r-package-with-rcpp&quot;, &quot;skeleton&quot; ), overwrite = TRUE ) The fourth template shows how to create a package with “extras” such as a README, a vignette, and a pkgdown site: usethis::use_rmarkdown_template( template_name = &quot;Template To Make an R Package With a README, Vignette, and Pkgdown Site&quot;, template_dir = &quot;make-an-r-package-with-extras&quot;, template_description = &quot;Template for an Rmd file for writing an R package that has a README, vignette, and pkgdown site while using literate programming.&quot;, template_create_dir = FALSE ) ## ✔ Creating &#39;inst/rmarkdown/templates/make-an-r-package-with-extras/skeleton/&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-with-extras/template.yaml&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-with-extras/skeleton/skeleton.Rmd&#39; fs::file_copy( path = file.path( &quot;..&quot;, &quot;source-files&quot;, &quot;make-an-r-package-with-extras&quot;, &quot;skeleton.Rmd&quot; ), new_path = file.path( &quot;inst&quot;, &quot;rmarkdown&quot;, &quot;templates&quot;, &quot;make-an-r-package-with-extras&quot;, &quot;skeleton&quot; ), overwrite = TRUE ) fs::dir_copy( path = file.path( &quot;..&quot;, &quot;source-files&quot;, &quot;make-an-r-package-with-extras&quot;, &quot;source-files&quot; ), new_path = file.path( &quot;inst&quot;, &quot;rmarkdown&quot;, &quot;templates&quot;, &quot;make-an-r-package-with-extras&quot;, &quot;skeleton&quot;, &quot;source-files&quot; ), overwrite = TRUE ) The fifth template shows how to create a package from a bookdown site, i.e. instead of having just a single create-pkg.Rmd, we can have a series of .Rmd files that together create a bookdown: usethis::use_rmarkdown_template( template_name = &quot;Template To Make an R Package From a Bookdown&quot;, template_dir = &quot;make-an-r-package-from-bookdown&quot;, template_description = &quot;Template for a bookdown that defines an R package using literate programming.&quot;, template_create_dir = TRUE ) ## ✔ Creating &#39;inst/rmarkdown/templates/make-an-r-package-from-bookdown/skeleton/&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-from-bookdown/template.yaml&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-from-bookdown/skeleton/skeleton.Rmd&#39; fs::dir_copy( path = file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;make-an-r-package-from-bookdown&quot;), new_path = file.path( &quot;inst&quot;, &quot;rmarkdown&quot;, &quot;templates&quot;, &quot;make-an-r-package-from-bookdown&quot;, &quot;skeleton&quot; ), overwrite = TRUE ) The sixth template shows how to create a package that uses RcppArmadillo: usethis::use_rmarkdown_template( template_name = &quot;Template To Make an R Package With RcppArmadillo&quot;, template_dir = &quot;make-an-r-package-with-armadillo&quot;, template_description = &quot;Template for an Rmd file for writing an R package that makes use of RcppArmadillo while using literate programming.&quot;, template_create_dir = FALSE ) ## ✔ Creating &#39;inst/rmarkdown/templates/make-an-r-package-with-armadillo/skeleton/&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-with-armadillo/template.yaml&#39; ## ✔ Writing &#39;inst/rmarkdown/templates/make-an-r-package-with-armadillo/skeleton/skeleton.Rmd&#39; fs::file_copy( path = file.path( &quot;..&quot;, &quot;source-files&quot;, &quot;make-an-r-package-with-armadillo&quot;, &quot;skeleton.Rmd&quot; ), new_path = file.path( &quot;inst&quot;, &quot;rmarkdown&quot;, &quot;templates&quot;, &quot;make-an-r-package-with-armadillo&quot;, &quot;skeleton&quot; ), overwrite = TRUE ) 8.2.2 Draft functions for working from template The syntax for working from template using rmarkdown is a bit cumbersome: rmarkdown::draft(&quot;create-rhello.Rmd&quot;, template = &quot;make-an-r-package&quot;, package = &quot;litr&quot;) We therefore define some litr-specific draft functions (thanks to Yihui Xie for suggesting this!). There is some reusable documentation in these functions, so we’ll define these reusable parts first and then reuse them later. The functions will all have the following parameters: #&#39; @param pkg_name Name of package to be created. #&#39; @param dir (Optional) Directory where .Rmd file should be created The heart of the functions will be to call rmarkdown::draft() on a template but then modify the template so that it has the package name in it rather than whatever the default was. #&#39; Internal function for creating a .Rmd file from template #&#39; @param pkg_name Name of package to be created. #&#39; @param dir (Optional) Directory where .Rmd file should be created #&#39; @param template_name Name of template #&#39; @keywords internal create_from_template &lt;- function(pkg_name, dir, template_name) { filename &lt;- stringr::str_glue(file.path(dir, &quot;create-{pkg_name}.Rmd&quot;)) rmarkdown::draft(filename, template = template_name, package = &quot;litr&quot;, edit = FALSE) rmd &lt;- readLines(filename) rmd &lt;- stringr::str_replace(rmd, &#39;package_name: .+$&#39;, stringr::str_glue(&#39;package_name: &quot;{pkg_name}&quot;&#39;)) writeLines(rmd, filename) message(stringr::str_glue(&quot;Created new file {filename}.&quot;)) } We are now ready to define the draft functions. We start with the simplest: #&#39; Create a new litr .Rmd document for creating an R package #&#39; #&#39; This creates `create-[pkg_name].Rmd` that when knitted (i.e., when passed to #&#39; `litr::render()`) will create an R package called `pkg_name`. #&#39; #&#39; This is the most basic R package template, with one function and one test #&#39; function. #&#39; @param pkg_name Name of package to be created. #&#39; @param dir (Optional) Directory where .Rmd file should be created #&#39; @export #&#39; @seealso \\code{\\link{draft_bookdown}} \\code{\\link{draft_data}} \\code{\\link{draft_rcpp}} \\code{\\link{draft_extras}} \\code{\\link{draft_armadillo}} draft &lt;- function(pkg_name = &quot;rhello&quot;, dir = &quot;.&quot;) { create_from_template(pkg_name, dir, &quot;make-an-r-package&quot;) } And now we define the draft function for creating an R package with a data set in it: #&#39; Create a new litr .Rmd document for creating an R package with a data set #&#39; #&#39; This creates `create-[pkg_name].Rmd` that when knitted (i.e., when passed to #&#39; `litr::render()`) will create an R package called `pkg_name`. #&#39; This template shows how to make an R package with a data set in it. #&#39; #&#39; @param pkg_name Name of package to be created. #&#39; @param dir (Optional) Directory where .Rmd file should be created #&#39; @export #&#39; @seealso \\code{\\link{draft}} \\code{\\link{draft_bookdown}} \\code{\\link{draft_rcpp}} \\code{\\link{draft_extras}} \\code{\\link{draft_armadillo}} draft_data &lt;- function(pkg_name = &quot;rhasdata&quot;, dir = &quot;.&quot;) { create_from_template(pkg_name, dir, &quot;make-an-r-package-with-data&quot;) } And now we define the draft function for creating an R package that uses Rcpp: #&#39; Create a new litr .Rmd document for creating an R package that uses `Rcpp` #&#39; #&#39; This creates `create-[pkg_name].Rmd` that when knitted (i.e., when passed to #&#39; `litr::render()`) will create an R package called `pkg_name`. #&#39; This template shows how to make an R package that uses `Rcpp`. #&#39; #&#39; @param pkg_name Name of package to be created. #&#39; @param dir (Optional) Directory where .Rmd file should be created #&#39; @export #&#39; @seealso \\code{\\link{draft}} \\code{\\link{draft_bookdown}} \\code{\\link{draft_data}} \\code{\\link{draft_extras}} \\code{\\link{draft_armadillo}} draft_rcpp &lt;- function(pkg_name = &quot;withrcpp&quot;, dir = &quot;.&quot;) { create_from_template(pkg_name, dir, &quot;make-an-r-package-with-rcpp&quot;) } And now we define the draft function for creating an R package that has “extras” such as a README, vignette(s), a pkgdown site, and a hex sticker: #&#39; Create a new litr .Rmd document for creating an R package with extras #&#39; #&#39; This creates `create-[pkg_name].Rmd` that when knitted (i.e., when passed to #&#39; `litr::render()`) will create an R package called `pkg_name`. #&#39; This template shows how to make an R package that has &quot;extras&quot; such as a #&#39; README, vignette(s), a pkgdown site, and a hex sticker. #&#39; #&#39; @param pkg_name Name of package to be created. #&#39; @param dir (Optional) Directory where .Rmd file should be created #&#39; @export #&#39; @seealso \\code{\\link{draft}} \\code{\\link{draft_bookdown}} \\code{\\link{draft_data}} \\code{\\link{draft_rcpp}} \\code{\\link{draft_armadillo}} draft_extras &lt;- function(pkg_name = &quot;withpkgdown&quot;, dir = &quot;.&quot;) { create_from_template(pkg_name, dir, &quot;make-an-r-package-with-extras&quot;) } And now we define the draft function for creating an R package that uses RcppArmadillo: #&#39; Create a new litr .Rmd document for creating an R package that uses `RcppArmadillo` #&#39; #&#39; This creates `create-[pkg_name].Rmd` that when knitted (i.e., when passed to #&#39; `litr::render()`) will create an R package called `pkg_name`. #&#39; This template shows how to make an R package that uses `RcppArmadillo`. #&#39; #&#39; @param pkg_name Name of package to be created. #&#39; @param dir (Optional) Directory where .Rmd file should be created #&#39; @export #&#39; @seealso \\code{\\link{draft}} \\code{\\link{draft_bookdown}} \\code{\\link{draft_data}} \\code{\\link{draft_rcpp}} \\code{\\link{draft_extras}} draft_armadillo &lt;- function(pkg_name = &quot;witharmadillo&quot;, dir = &quot;.&quot;) { create_from_template(pkg_name, dir, &quot;make-an-r-package-with-armadillo&quot;) } Finally, we define the draft function for creating an R package from bookdown. The code for this one is a bit different because it creates a directory with a number of .Rmd files. #&#39; Create a new litr .Rmd document for creating an R package from `bookdown` #&#39; #&#39; This template shows how to make an R package from `bookdown`. It creates a directory called `create-[pkg_name]` in `dir`. Rendering the file `index.Rmd` #&#39; with `litr::render()` creates the bookdown and package. #&#39; #&#39; @param pkg_name Name of package to be created. #&#39; @param dir (Optional) Directory where .Rmd file should be created #&#39; @export #&#39; @seealso \\code{\\link{draft}} \\code{\\link{draft_data}} \\code{\\link{draft_rcpp}} \\code{\\link{draft_extras}} \\code{\\link{draft_armadillo}} draft_bookdown &lt;- function(pkg_name = &quot;frombookdown&quot;, dir = &quot;.&quot;) { create_pkg &lt;- stringr::str_glue(&quot;create-{pkg_name}&quot;) dirname &lt;- stringr::str_glue(file.path(dir, create_pkg)) rmarkdown::draft(dirname, template = &quot;make-an-r-package-from-bookdown&quot;, package = &quot;litr&quot;, edit = FALSE) # delete unneeded file: fs::file_delete(file.path(dirname, paste0(create_pkg, &quot;.Rmd&quot;))) index_file &lt;- file.path(dirname, &quot;index.Rmd&quot;) # adjust index.Rmd with name of package rmd &lt;- readLines(index_file) rmd &lt;- stringr::str_replace(rmd, &#39;package_name: .+$&#39;, stringr::str_glue(&#39;package_name: &quot;{pkg_name}&quot;&#39;)) writeLines(rmd, index_file) message(stringr::str_glue(&quot;Created new directory {dirname}&quot;)) } "],["adding-extras-to-an-r-package.html", "9 Adding extras to an R package 9.1 Adding a README 9.2 Adding a hex sticker 9.3 Adding vignettes 9.4 Add a pkgdown site", " 9 Adding extras to an R package When writing an R package, there are some additional items one typically wants to include, such as a README file, one or more vignettes, and a pkgdown site. In this section, we define some helper functions that will be make it easy to add these “extras” to a package. While a user could choose to generate all these items within the generating .Rmd file, for all but the simplest examples, it will probably be preferred to have these as separate source files. These source files can live in the same directory as the generating .Rmd file or in their own directory (e.g., source-files lives in the same directory as create-litr.Rmd, which is called litr-project). 9.1 Adding a README We define a helper function that takes an externally defined README.Rmd and puts it into the package, creates a README.md, and makes sure that these will be added to the .Rbuildignore. #&#39; Add README to package #&#39; #&#39; This function takes a README.Rmd file, copies it into the package, and then #&#39; renders it to a README.md file. It also adds these two files to the #&#39; .Rbuildignore. #&#39; #&#39; @param rmd_file The path to a .Rmd file. #&#39; @export add_readme &lt;- function(rmd_file) { usethis::use_readme_rmd(open = FALSE) fs::file_copy(rmd_file, new_path = &quot;README.Rmd&quot;, overwrite = TRUE) out &lt;- xfun::Rscript_call( rmarkdown::render, args = list( input = &quot;README.Rmd&quot;, output_options = list(html_preview = &quot;false&quot;) ) ) } 9.2 Adding a hex sticker We define a helper function that takes an externally defined hex sticker (.png file) and puts it into the package under man/figures. The suggestion for storing it in this directory came from here. #&#39; Add a hex sticker to package #&#39; #&#39; In addition to calling this function, you should add to your README.Rmd something like this: #&#39; #&#39; `# your-title &lt;img src=&quot;man/figures/logo.png&quot; align=&quot;right&quot; height=&quot;139&quot; /&gt;` #&#39; #&#39; See [here](https://pkgdown.r-lib.org/reference/build_home.html#package-logo) #&#39; for more. #&#39; #&#39; @param hex_png_file The .png file with your package&#39;s hex sticker #&#39; @export add_hex_sticker &lt;- function(hex_png_file) { figures_dir &lt;- file.path(&quot;man&quot;, &quot;figures&quot;) fs::dir_create(figures_dir) fs::file_copy(path = hex_png_file, new_path = file.path(figures_dir, &quot;logo.png&quot;), overwrite = TRUE) } 9.3 Adding vignettes We next define a helper function for adding vignettes to the package. This mimics usethis::use_vignette(). We couldn’t directly use that function because we want the project file to live outside of the package directory, which confuses usethis. #&#39; Add one or more vignettes to package #&#39; #&#39; @param rmd_files A character vector of .Rmd files, each corresponding to #&#39; a vignette #&#39; @param other_files A character vector of any other files needed in the #&#39; vignettes directory (.bib file, images, etc.) #&#39; @export add_vignettes &lt;- function(rmd_files, other_files = NULL) { fs::dir_create(&quot;vignettes&quot;) for (fn in c(rmd_files, other_files)) fs::file_copy(fn, &quot;vignettes&quot;) # update DESCRIPTION file: deps &lt;- desc::desc_get_deps()$package if (!(&quot;knitr&quot; %in% deps)) desc::desc_set_dep(&quot;knitr&quot;, type = &quot;Suggests&quot;) if (!(&quot;rmarkdown&quot; %in% deps)) desc::desc_set_dep(&quot;rmarkdown&quot;, type = &quot;Suggests&quot;) out &lt;- desc::desc_set(&quot;VignetteBuilder&quot;, &quot;knitr&quot;) } 9.4 Add a pkgdown site We define a function based on usethis::use_pkgdown(), but with a few differences: Avoid the parts to do with looking for projects Allow one to use a custom _pkgdown.yml that is stored outside of package #&#39; Add a pkgdown site #&#39; #&#39; This function creates a website for your package. You can see it locally by #&#39; opening `docs/index.html` in your package. To get it online you can copy the #&#39; `docs` directory to your website&#39;s server. #&#39; #&#39; Be sure that in the generating .Rmd file this is called *after* #&#39; `litr::document()` has been called. To customize the site, you may pass a #&#39; customized `_pkgdown.yml` file as described in [this `pkgdown` vignette](https://pkgdown.r-lib.org/articles/customise.html). #&#39; #&#39; @param config_path The _pkgdown.yml file that lives somewhere outside of your package. If NULL, then a basic default will be used. #&#39; @export add_pkgdown &lt;- function(config_path = NULL) { config_file &lt;- &quot;_pkgdown.yml&quot; destdir &lt;- &quot;docs&quot; usethis::use_build_ignore(c(config_file, destdir, &quot;pkgdown&quot;)) if (is.null(config_path)) { # create a new config file (note it lives outside of package) config &lt;- usethis:::pkgdown_config(destdir) usethis::write_over(config_file, yaml::as.yaml(config)) } else { # copy the one that already exists: fs::file_copy(config_path, config_file) } pkgdown::build_site() } After this step, you can locally see the site by opening docs/index.html in the browser. You can then copy the docs directory to your website’s server and you’re done. Since the above function uses pkgdown and yaml, we include these in our package: usethis::use_package(&quot;pkgdown&quot;) ## ✔ Adding &#39;pkgdown&#39; to Imports field in DESCRIPTION ## • Refer to functions with `pkgdown::fun()` usethis::use_package(&quot;yaml&quot;) ## ✔ Adding &#39;yaml&#39; to Imports field in DESCRIPTION ## • Refer to functions with `yaml::fun()` "],["tests.html", "10 Defining some tests 10.1 Testing check_unedited() 10.2 Testing get_params_used() 10.3 Testing chunk referencing 10.4 Testing different ways of rendering 10.5 Testing other templates", " 10 Defining some tests When using litr to create packages that are not litr, one should be able to run tests along the way as we did above in testing the function add_text_to_file(). However, creating litr is a special case so we need to do something different for the tests that involve creating a .Rmd from template and then calling litr::render() on them (such as the tests in this section). In particular, we use eval=FALSE for these code blocks and then at the end of this document we will install the newly created version of litr and then call devtools::test(). Doing it this way is important for ensuring that the version of litr we are testing is the newest version, i.e. the version defined in this document. To understand the reason we are doing it this way, imagine what would happen if instead we left eval=TRUE in the test in the next section. When we use rmarkdown::draft() to create a .Rmd file from template, the file it will give us will be an old version (namely the installed version of litr’s template) rather than the latest version.2 Furthermore, consider what happens when we call render() in the test below. This will start the knitting process on my-package.Rmd. However, inside my-package.Rmd, we have litr::setup() and litr::document(). When these are called in the knitting process, it will be the versions of the functions from the currently installed litr rather than the versions defined in this document. Once we are done testing the new version of the package, we’d like to restore the state of litr to what it was previously. If we don’t do this, then this can lead to inadvertent circularity in which the next time we call litr::render(\"create-litr.Rmd\"), we are using the version currently under development, which is bad because ultimately we need this version to be rendered by the previous version of litr. The following function implements this approach to testing litr: #&#39; Run tests for `litr` itself #&#39; #&#39; Special function for testing `litr`. The trick is to temporarily install #&#39; the new version of `litr`, run the test, and then put things back how it was #&#39; before. #&#39; #&#39; Typical values for `install_old` could be #&#39; - `function() devtools::install(&quot;[location of old version]&quot;)` #&#39; - `function() remotes::install_github(&quot;jacobbien/litr-project@*release&quot;, subdir = &quot;litr&quot;)`. #&#39; #&#39; @param install_old A function that when run will install the old version #&#39; @param location_of_new Path to the new package directory #&#39; @keywords internal test_litr &lt;- function(install_old, location_of_new) { devtools::unload(params$package_name) devtools::install(location_of_new) out &lt;- devtools::test(location_of_new) install_old() return(out) } Note: The call to devtools::unload() is to address an issue discussed here. 10.1 Testing check_unedited() For our tests, we create a temporary directory (which we delete at the end). In this directory, we create a generating .Rmd file from one of the templates. We make repeated modifications to the package and each time verify that check_unedited() is FALSE with the modification and returns to TRUE when we put things back how they were. The modifications we try are the following: Adding a file Removing a file Making a change to a file (in particular, adding a comment to an R file) Changing something in the DESCRIPTION file (but not on the special litr line) Changing the litr hash line itself testthat::test_that(&quot;check_unedited works&quot;, { # Including this next line seems to be necessary for R CMD check on the cmd line: #Sys.setenv(RSTUDIO_PANDOC = &quot;/Applications/RStudio.app/Contents/MacOS/pandoc&quot;) dir &lt;- tempfile() fs::dir_create(dir) rmd_file &lt;- file.path(dir, &quot;my-package.Rmd&quot;) rmarkdown::draft(rmd_file, template = &quot;make-an-r-package&quot;, package = &quot;litr&quot;, edit = FALSE) # create R package (named &quot;rhello&quot;) from the Rmd template: render(rmd_file) package_path &lt;- file.path(dir, &quot;rhello&quot;) testthat::expect_true(check_unedited(package_path)) # what if a file has been added? added_file &lt;- file.path(package_path, &quot;R&quot;, &quot;say_hello2.R&quot;) writeLines(&quot;# Added something here.&quot;, added_file) testthat::expect_false(check_unedited(package_path)) # what if we now remove it? fs::file_delete(added_file) testthat::expect_true(check_unedited(package_path)) # what if a file is removed from package? rfile &lt;- file.path(package_path, &quot;R&quot;, &quot;say_hello.R&quot;) fs::file_move(rfile, dir) testthat::expect_false(check_unedited(package_path)) # now put it back fs::file_move(file.path(dir, &quot;say_hello.R&quot;), file.path(package_path, &quot;R&quot;)) testthat::expect_true(check_unedited(package_path)) # what if something is changed in a file? txt &lt;- readLines(rfile) txt_mod &lt;- txt txt_mod[3] &lt;- paste0(txt[3], &quot; # added a comment!!&quot;) writeLines(txt_mod, rfile) testthat::expect_false(check_unedited(package_path)) # now put it back writeLines(txt, rfile) testthat::expect_true(check_unedited(package_path)) # what if something is changed in the DESCRIPTION file? descfile &lt;- file.path(package_path, &quot;DESCRIPTION&quot;) txt &lt;- readLines(descfile) txt_mod &lt;- txt txt_mod[1] &lt;- &quot;Package: newname&quot; writeLines(txt_mod, descfile) testthat::expect_false(check_unedited(package_path)) # now put it back writeLines(txt, descfile) testthat::expect_true(check_unedited(package_path)) # what if the special litr hash field is changed in the DESCRIPTION file? txt &lt;- readLines(descfile) i_litr &lt;- stringr::str_which(txt, description_litr_hash_field_name()) txt_mod &lt;- txt txt_mod[i_litr] &lt;- paste0(txt_mod[i_litr], &quot;a&quot;) writeLines(txt_mod, descfile) testthat::expect_false(check_unedited(package_path)) # now put it back writeLines(txt, descfile) testthat::expect_true(check_unedited(package_path)) fs::dir_delete(dir) }) 10.2 Testing get_params_used() Let’s now test the get_params_used() function, making sure it behaves how we expect it to: testthat::test_that(&quot;get_params_used works&quot;, { dir &lt;- tempfile() if (fs::file_exists(dir)) fs::file_delete(dir) fs::dir_create(dir) rmd_file &lt;- file.path(dir, &quot;my-package.Rmd&quot;) rmarkdown::draft(rmd_file, template = &quot;make-an-r-package&quot;, package = &quot;litr&quot;, edit = FALSE) default_params &lt;- get_params_used(rmd_file, passed_params = list()) testthat::expect_equal( default_params, rmarkdown::yaml_front_matter(rmd_file)$params ) params1 &lt;- default_params params1$package_parent_dir &lt;- &quot;dir&quot; testthat::expect_equal( get_params_used(rmd_file, passed_params = list(package_parent_dir = &quot;dir&quot;)), params1 ) params2 &lt;- default_params params2$package_name &lt;- &quot;pkg&quot; params2$package_parent_dir &lt;- &quot;dir&quot; testthat::expect_equal( get_params_used(rmd_file, passed_params = list(package_parent_dir = &quot;dir&quot;, package_name = &quot;pkg&quot;)), params2 ) fs::dir_delete(dir) }) 10.3 Testing chunk referencing Here we test the handling of chunk references (as implemented in the document output hook set within setup()). In particular, we use a .Rmd that uses chunk references in several different ways. Within the .Rmd itself, we have tests that ensure that the code can still be run as expected. fs::file_copy( path = file.path( &quot;..&quot;, &quot;source-files&quot;, &quot;test-example-files&quot;, &quot;create-rknuth.Rmd&quot; ), new_path = file.path(&quot;tests&quot;, &quot;testthat&quot;), overwrite = TRUE ) testthat::test_that(&#39;Knuth-style references work&#39;, { dir &lt;- tempfile() if (fs::file_exists(dir)) fs::file_delete(dir) fs::dir_create(dir) rmd_file &lt;- file.path(dir, &#39;create-rknuth.Rmd&#39;) fs::file_copy(path = testthat::test_path(&quot;create-rknuth.Rmd&quot;), new_path = rmd_file) render(rmd_file) testthat::expect_true(fs::file_exists(file.path(dir, &#39;create-rknuth.html&#39;))) fs::dir_delete(dir) }) 10.4 Testing different ways of rendering The mechanism by which rendering occurs depends on several factors: Whether litr::render() or rmarkdown::render() is being called. Whether there is a litr output format specified in the preamble of the .Rmd. Whether there is a litr output format being passed an argument to the render function. In this section, we will test that one gets the same result regardless of how rendering was invoked.3 We will use variations on a base .Rmd file whose preamble is simply the following: --- title: &#39;A Test&#39; params: package_name: &#39;pkg&#39; # &lt;-- change this to your package name package_parent_dir: &#39;.&#39; # &lt;-- relative to this file location --- fs::file_copy( path = file.path( &quot;..&quot;, &quot;source-files&quot;, &quot;test-example-files&quot;, &quot;create-pkg.Rmd&quot; ), new_path = file.path(&quot;tests&quot;, &quot;testthat&quot;), overwrite = TRUE ) There are 7 cases to consider (\\(2^3-1\\), since we exclude the case where rmarkdown::render() is called and no argument or preamble would indicate that this should be a litr-knit). testthat::test_that(&#39;Rendering in all possible ways works&#39;, { # setup files for tests: dir &lt;- tempfile() if (fs::file_exists(dir)) fs::file_delete(dir) fs::dir_create(dir) # .Rmd without output format in preamble rmd_file1 &lt;- file.path(dir, &#39;create-pkg1.Rmd&#39;) fs::file_copy(testthat::test_path(&quot;create-pkg.Rmd&quot;), rmd_file1) # .Rmd without output format in preamble rmd_file2 &lt;- file.path(dir, &#39;create-pkg2.Rmd&#39;) fs::file_copy(rmd_file1, rmd_file2) litr:::add_text_to_file(&quot;output: litr::litr_html_document&quot;, rmd_file2, 3) # files names rmd_file &lt;- file.path(dir, &quot;create-pkg.Rmd&quot;) html_file &lt;- file.path(dir, &quot;create-pkg.html&quot;) html_file_a &lt;- file.path(dir, &quot;a&quot;,&quot;create-pkg.html&quot;) pkg &lt;- file.path(dir, &quot;pkg&quot;) pkg_a &lt;- file.path(dir, &quot;a&quot;, &quot;pkg&quot;) check_outputs_are_same &lt;- function() { # html files should be the same: testthat::expect_equal(readLines(html_file_a), readLines(html_file)) # packages should be the same (relying here on litr-hash in DESCRIPTION): testthat::expect_equal(readLines(file.path(pkg, &quot;DESCRIPTION&quot;)), readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;))) } ## Now test that all the cases give the same outputs: # Case 1: no preamble + litr::render() fs::file_copy(rmd_file1, rmd_file, overwrite = TRUE) render(rmd_file, output_file = html_file) if (fs::file_exists(file.path(dir, &quot;a&quot;))) fs::file_delete(file.path(dir, &quot;a&quot;)) fs::dir_create(file.path(dir, &quot;a&quot;)) fs::dir_copy(pkg, pkg_a) fs::dir_delete(pkg) fs::file_move(html_file, html_file_a) # Case 2: with preamble + litr::render() fs::file_copy(rmd_file2, rmd_file, overwrite = TRUE) render(rmd_file, output_file = html_file) check_outputs_are_same() # Case 3: no preamble + litr::render() with output format argument fs::file_copy(rmd_file1, rmd_file, overwrite = TRUE) render(rmd_file, output_format = litr::litr_html_document(), output_file = html_file) check_outputs_are_same() # Case 4: with preamble + litr::render() with output format argument fs::file_copy(rmd_file2, rmd_file, overwrite = TRUE) render(rmd_file, output_format = litr::litr_html_document(), output_file = html_file) check_outputs_are_same() # Case 5: with preamble + rmarkdown::render() fs::file_copy(rmd_file2, rmd_file, overwrite = TRUE) xfun::Rscript_call(rmarkdown::render, list(input = rmd_file, output_file = html_file) ) check_outputs_are_same() # Case 6: no preamble + rmarkdown::render() with output format argument fs::file_copy(rmd_file1, rmd_file, overwrite = TRUE) xfun::Rscript_call(rmarkdown::render, list(input = rmd_file, output_format = litr::litr_html_document(), output_file = html_file) ) check_outputs_are_same() # Case 7: with preamble + rmarkdown::render() with output format argument fs::file_copy(rmd_file2, rmd_file, overwrite = TRUE) xfun::Rscript_call(rmarkdown::render, list(input = rmd_file, output_format = litr::litr_html_document(), output_file = html_file) ) check_outputs_are_same() fs::dir_delete(dir) }) Let’s also make sure that we get the same R package output when using minimal_eval=TRUE as minimal_eval=TRUE. testthat::test_that(&#39;Rendering with minimal_eval=TRUE works&#39;, { # setup files for tests: dir &lt;- tempfile() if (fs::file_exists(dir)) fs::file_delete(dir) fs::dir_create(dir) rmd_file &lt;- file.path(dir, &#39;create-pkg.Rmd&#39;) fs::file_copy(testthat::test_path(&quot;create-pkg.Rmd&quot;), rmd_file) # .Rmd without output format in preamble html_file &lt;- file.path(dir, &quot;create-pkg.html&quot;) html_file_a &lt;- file.path(dir, &quot;a&quot;,&quot;create-pkg.html&quot;) pkg &lt;- file.path(dir, &quot;pkg&quot;) pkg_a &lt;- file.path(dir, &quot;a&quot;, &quot;pkg&quot;) ## Now test that all the cases give the same outputs: # Case 1: minimal_eval = FALSE render(rmd_file, output_file = html_file, minimal_eval = FALSE) if (fs::file_exists(file.path(dir, &quot;a&quot;))) fs::file_delete(file.path(dir, &quot;a&quot;)) fs::dir_create(file.path(dir, &quot;a&quot;)) fs::dir_copy(pkg, pkg_a) fs::dir_delete(pkg) # Case 2: minimal_eval = TRUE passed to render render(rmd_file, output_file = html_file, minimal_eval = TRUE) testthat::expect_equal(readLines(file.path(pkg, &quot;DESCRIPTION&quot;)), readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;))) # Case 3: minimal_eval = TRUE passed to output format render(rmd_file, output_file = html_file, output_format = litr::litr_html_document(minimal_eval = TRUE) ) testthat::expect_equal(readLines(file.path(pkg, &quot;DESCRIPTION&quot;)), readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;))) fs::dir_delete(dir) }) 10.5 Testing other templates Let’s now make sure that each template can be knit without error. testthat::test_that(&quot;templates can be knit&quot;, { dir &lt;- tempfile() if (fs::file_exists(dir)) fs::file_delete(dir) fs::dir_create(dir) rmd_file &lt;- file.path(dir, &quot;create-rhello.Rmd&quot;) rmarkdown::draft(rmd_file, template = &quot;make-an-r-package&quot;, package = &quot;litr&quot;, edit = FALSE) render(rmd_file) testthat::expect_true(fs::file_exists(file.path(dir, &quot;create-rhello.html&quot;))) testthat::expect_true(fs::file_exists(file.path(dir, &quot;rhello&quot;))) rmd_file &lt;- file.path(dir, &quot;create-rhasdata.Rmd&quot;) rmarkdown::draft(rmd_file, template = &quot;make-an-r-package-with-data&quot;, package = &quot;litr&quot;, edit = FALSE) render(rmd_file) testthat::expect_true(fs::file_exists(file.path(dir, &quot;create-rhasdata.html&quot;))) testthat::expect_true(fs::file_exists(file.path(dir, &quot;rhasdata&quot;))) rmd_file &lt;- file.path(dir, &quot;create-withrcpp.Rmd&quot;) rmarkdown::draft(rmd_file, template = &quot;make-an-r-package-with-rcpp&quot;, package = &quot;litr&quot;, edit = FALSE) render(rmd_file) testthat::expect_true(fs::file_exists(file.path(dir, &quot;create-withrcpp.html&quot;))) testthat::expect_true(fs::file_exists(file.path(dir, &quot;withrcpp&quot;))) rmd_file &lt;- file.path(dir, &quot;create-witharmadillo.Rmd&quot;) rmarkdown::draft(rmd_file, template = &quot;make-an-r-package-with-armadillo&quot;, package = &quot;litr&quot;, edit = FALSE) render(rmd_file) testthat::expect_true(fs::file_exists(file.path(dir, &quot;create-witharmadillo.Rmd&quot;))) testthat::expect_true(fs::file_exists(file.path(dir, &quot;witharmadillo&quot;))) rmd_file &lt;- file.path(dir, &quot;create-withpkgdown.Rmd&quot;) rmarkdown::draft(rmd_file, template = &quot;make-an-r-package-with-extras&quot;, package = &quot;litr&quot;, edit = FALSE) render(rmd_file) testthat::expect_true(fs::file_exists(file.path(dir, &quot;create-withpkgdown.html&quot;))) testthat::expect_true(fs::file_exists(file.path(dir, &quot;withpkgdown&quot;))) rmd_file &lt;- file.path(dir, &quot;create-frombookdown.Rmd&quot;) rmarkdown::draft(rmd_file, template = &quot;make-an-r-package-from-bookdown&quot;, package = &quot;litr&quot;, edit = FALSE) prev_dir &lt;- getwd() setwd(file.path(dir, &quot;create-frombookdown&quot;)) fs::file_delete(&quot;create-frombookdown.Rmd&quot;) render(&quot;index.Rmd&quot;) setwd(prev_dir) testthat::expect_true( fs::file_exists(file.path(dir, &quot;create-frombookdown&quot;, &quot;_book&quot;, &quot;index.html&quot;)) ) testthat::expect_true( fs::file_exists(file.path(dir, &quot;create-frombookdown&quot;, &quot;frombookdown&quot;)) ) fs::dir_delete(dir) }) Even though litr doesn’t directly use Rcpp, we’ll add it as a “Suggests” package since it would be required for running the above test. usethis::use_package(&quot;Rcpp&quot;, type = &quot;Suggests&quot;) ## ✔ Adding &#39;Rcpp&#39; to Suggests field in DESCRIPTION ## • Use `requireNamespace(&quot;Rcpp&quot;, quietly = TRUE)` to test if package is installed ## • Then directly refer to functions with `Rcpp::fun()` If this were the only problem, we could get around this by using pkgload::package_file() to get the proper file; however, the next problem discussed was something that seemed quite hard to resolve.↩︎ Note: When we call rmarkdown::render(), we call it in a fresh, non-interactive R session.↩︎ "],["documenting-the-package-and-testing.html", "11 Documenting the package and testing 11.1 Add examples folder with the output of knitting each example", " 11 Documenting the package and testing We finish by running commands that will document and test litr. The formatting of the test output does not print out very neatly. We download the latest release: litr::document() ## ℹ Updating litr documentation ## ℹ Loading litr ## Writing &#39;NAMESPACE&#39; ## Writing &#39;create_from_template.Rd&#39; ## Writing &#39;draft.Rd&#39; ## Writing &#39;draft_data.Rd&#39; ## Writing &#39;draft_rcpp.Rd&#39; ## Writing &#39;draft_extras.Rd&#39; ## Writing &#39;draft_armadillo.Rd&#39; ## Writing &#39;draft_bookdown.Rd&#39; ## Writing &#39;add_readme.Rd&#39; ## Writing &#39;add_hex_sticker.Rd&#39; ## Writing &#39;add_vignettes.Rd&#39; ## Writing &#39;add_pkgdown.Rd&#39; ## Writing &#39;hash_package_directory.Rd&#39; ## Writing &#39;description_litr_hash_field_name.Rd&#39; ## Writing &#39;write_hash_to_description.Rd&#39; ## Writing &#39;read_hash_from_description.Rd&#39; ## Writing &#39;check_unedited.Rd&#39; ## Writing &#39;litr-package.Rd&#39; ## Writing &#39;do_not_edit_message.Rd&#39; ## Writing &#39;document.Rd&#39; ## Writing &#39;litrify_output_format.Rd&#39; ## Writing &#39;description_litr_version_field_name.Rd&#39; ## Writing &#39;write_version_to_description.Rd&#39; ## Writing &#39;get_package_directory.Rd&#39; ## Writing &#39;litr_pdf_document.Rd&#39; ## Writing &#39;litr_html_document.Rd&#39; ## Writing &#39;add_function_hyperlinks.Rd&#39; ## Writing &#39;insert_hrefs.Rd&#39; ## Writing &#39;add_chunk_label_hyperlinks.Rd&#39; ## Writing &#39;replace_ansi_sequences.Rd&#39; ## Writing &#39;litr_gitbook.Rd&#39; ## Writing &#39;render.Rd&#39; ## Writing &#39;with_cleanup.Rd&#39; ## Writing &#39;restore_knitr_objects.Rd&#39; ## Writing &#39;remove_rstudio_extras.Rd&#39; ## Writing &#39;get_params_used.Rd&#39; ## Writing &#39;load_all.Rd&#39; ## Writing &#39;send_to_package.Rd&#39; ## Writing &#39;add_text_to_file.Rd&#39; ## Writing &#39;setup.Rd&#39; ## Writing &#39;find_labels.Rd&#39; ## Writing &#39;make_noticeable.Rd&#39; ## Writing &#39;test_litr.Rd&#39; install_old &lt;- function() { remotes::install_github(&quot;jacobbien/litr-project@*release&quot;, subdir = &quot;litr&quot;) } xfun::Rscript_call(test_litr, list(install_old = install_old, location_of_new = &quot;.&quot;)) ## file context test nb failed skipped ## 1 tests.R tests add_text_to_file() works 10 0 FALSE ## 2 tests.R tests get_package_directory() works 2 0 FALSE ## 3 tests.R tests load_all() works 1 0 FALSE ## 4 tests.R tests check_unedited works 11 0 FALSE ## 5 tests.R tests get_params_used works 3 0 FALSE ## 6 tests.R tests Knuth-style references work 1 0 FALSE ## 7 tests.R tests Rendering in all possible ways works 12 0 FALSE ## 8 tests.R tests Rendering with minimal_eval=TRUE works 2 0 FALSE ## 9 tests.R tests templates can be knit 12 0 FALSE ## error warning user system real passed ## 1 FALSE 0 0.097 0.006 0.103 10 ## 2 FALSE 0 0.002 0.001 0.003 2 ## 3 FALSE 0 0.204 0.019 1.139 1 ## 4 FALSE 0 0.055 0.011 1.098 11 ## 5 FALSE 0 0.004 0.002 0.006 3 ## 6 FALSE 0 0.019 0.003 1.131 1 ## 7 FALSE 0 0.368 0.029 7.721 12 ## 8 FALSE 0 0.219 0.016 3.112 2 ## 9 FALSE 0 0.113 0.023 43.311 12 ## result ## 1 , 10, 3, 10, 77, 3, 77, 10, 10, testthat::expect_error(add_text_to_file(sometxt, myfile, req_exist = TRUE)), expect_condition_matching(&quot;error&quot;, {, {, object, }, }, regexp = regexp, class = class, ..., inherit = inherit, info = info, , label = label), quasi_capture(enquo(object), label, capture_matching_condition, , matches = matcher), .capture(act$val &lt;- eval_bare(quo_get_expr(.quo), quo_get_env(.quo)), , ...), withCallingHandlers(expr, condition = function(cnd) {, if (!is.null(matched) || !matches(cnd)) {, return(), }, if (can_entrace(cnd)) {, cnd &lt;- cnd_entrace(cnd), }, matched &lt;&lt;- cnd, if (inherits(cnd, &quot;message&quot;) || inherits(cnd, &quot;warning&quot;)) {, cnd_muffle(cnd), }, else if (inherits(cnd, &quot;error&quot;) || inherits(cnd, &quot;skip&quot;)) {, return_from(tl, cnd), }, }), eval_bare(quo_get_expr(.quo), quo_get_env(.quo)), add_text_to_file(sometxt, myfile, req_exist = TRUE), 0, 1, 2, 3, 4, 3, 0, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, testthat, testthat, testthat, testthat, base, rlang, litr, ::, :::, :::, local, ::, ::, :::, 45, 47, add_text_to_file() works, fs::file_exists(myfile) is not TRUE\\n\\n, 16, 3, 16, 48, 3, 48, 16, 16, 45, 47, add_text_to_file() works, `sometxt` (`actual`) not equal to readLines(myfile) (`expected`).\\n\\n, 17, 3, 17, 52, 3, 52, 17, 17, 45, 47, add_text_to_file() works, c(sometxt, moretxt) (`actual`) not equal to readLines(myfile) (`expected`).\\n\\n, 22, 3, 22, 64, 3, 64, 22, 22, 45, 47, add_text_to_file() works, , 25, 3, 25, 62, 3, 62, 25, 25, testthat::expect_error(add_text_to_file(sometxt, myfile, 0)), expect_condition_matching(&quot;error&quot;, {, {, object, }, }, regexp = regexp, class = class, ..., inherit = inherit, info = info, , label = label), quasi_capture(enquo(object), label, capture_matching_condition, , matches = matcher), .capture(act$val &lt;- eval_bare(quo_get_expr(.quo), quo_get_env(.quo)), , ...), withCallingHandlers(expr, condition = function(cnd) {, if (!is.null(matched) || !matches(cnd)) {, return(), }, if (can_entrace(cnd)) {, cnd &lt;- cnd_entrace(cnd), }, matched &lt;&lt;- cnd, if (inherits(cnd, &quot;message&quot;) || inherits(cnd, &quot;warning&quot;)) {, cnd_muffle(cnd), }, else if (inherits(cnd, &quot;error&quot;) || inherits(cnd, &quot;skip&quot;)) {, return_from(tl, cnd), }, }), eval_bare(quo_get_expr(.quo), quo_get_env(.quo)), add_text_to_file(sometxt, myfile, 0), 0, 1, 2, 3, 4, 3, 0, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, testthat, testthat, testthat, testthat, base, rlang, litr, ::, :::, :::, local, ::, ::, :::, 45, 47, add_text_to_file() works, , 26, 3, 26, 63, 3, 63, 26, 26, testthat::expect_error(add_text_to_file(sometxt, myfile, -1)), expect_condition_matching(&quot;error&quot;, {, {, object, }, }, regexp = regexp, class = class, ..., inherit = inherit, info = info, , label = label), quasi_capture(enquo(object), label, capture_matching_condition, , matches = matcher), .capture(act$val &lt;- eval_bare(quo_get_expr(.quo), quo_get_env(.quo)), , ...), withCallingHandlers(expr, condition = function(cnd) {, if (!is.null(matched) || !matches(cnd)) {, return(), }, if (can_entrace(cnd)) {, cnd &lt;- cnd_entrace(cnd), }, matched &lt;&lt;- cnd, if (inherits(cnd, &quot;message&quot;) || inherits(cnd, &quot;warning&quot;)) {, cnd_muffle(cnd), }, else if (inherits(cnd, &quot;error&quot;) || inherits(cnd, &quot;skip&quot;)) {, return_from(tl, cnd), }, }), eval_bare(quo_get_expr(.quo), quo_get_env(.quo)), add_text_to_file(sometxt, myfile, -1), 0, 1, 2, 3, 4, 3, 0, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, testthat, testthat, testthat, testthat, base, rlang, litr, ::, :::, :::, local, ::, ::, :::, 45, 47, add_text_to_file() works, , 27, 3, 27, 62, 3, 62, 27, 27, testthat::expect_error(add_text_to_file(sometxt, myfile, 5)), expect_condition_matching(&quot;error&quot;, {, {, object, }, }, regexp = regexp, class = class, ..., inherit = inherit, info = info, , label = label), quasi_capture(enquo(object), label, capture_matching_condition, , matches = matcher), .capture(act$val &lt;- eval_bare(quo_get_expr(.quo), quo_get_env(.quo)), , ...), withCallingHandlers(expr, condition = function(cnd) {, if (!is.null(matched) || !matches(cnd)) {, return(), }, if (can_entrace(cnd)) {, cnd &lt;- cnd_entrace(cnd), }, matched &lt;&lt;- cnd, if (inherits(cnd, &quot;message&quot;) || inherits(cnd, &quot;warning&quot;)) {, cnd_muffle(cnd), }, else if (inherits(cnd, &quot;error&quot;) || inherits(cnd, &quot;skip&quot;)) {, return_from(tl, cnd), }, }), eval_bare(quo_get_expr(.quo), quo_get_env(.quo)), add_text_to_file(sometxt, myfile, 5), 0, 1, 2, 3, 4, 3, 0, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, testthat, testthat, testthat, testthat, base, rlang, litr, ::, :::, :::, local, ::, ::, :::, 45, 47, add_text_to_file() works, c(moretxt2, sometxt, moretxt) (`actual`) not equal to readLines(myfile) (`expected`).\\n\\n, 32, 3, 32, 74, 3, 74, 32, 32, 45, 47, add_text_to_file() works, c(moretxt2, moretxt3, sometxt, moretxt) (`actual`) not equal to readLines(myfile) (`expected`).\\n\\n, 37, 3, 38, 43, 3, 43, 37, 38, 45, 47, add_text_to_file() works, c(moretxt2, moretxt3, sometxt, moretxt, moretxt4) (`actual`) not equal to readLines(myfile) (`expected`).\\n\\n, 43, 3, 44, 43, 3, 43, 43, 44, 45, 47, add_text_to_file() works ## 2 get_package_directory(&quot;.&quot;, &quot;mypkg&quot;, input) (`actual`) not equal to file.path(&quot;inputdir&quot;, &quot;mypkg&quot;) (`expected`).\\n\\n, 50, 3, 53, 3, 3, 3, 50, 53, 45, 47, get_package_directory() works, get_package_directory(&quot;..&quot;, &quot;mypkg&quot;, input) (`actual`) not equal to file.path(&quot;inputdir&quot;, &quot;..&quot;, &quot;mypkg&quot;) (`expected`).\\n\\n, 54, 3, 57, 3, 3, 3, 54, 57, 45, 47, get_package_directory() works ## 3 say_hello(&quot;Jacob&quot;) (`actual`) not equal to &quot;Hello Jacob!&quot; (`expected`).\\n\\n, 70, 3, 70, 60, 3, 60, 70, 70, 45, 47, load_all() works ## 4 check_unedited(package_path) is not TRUE\\n\\n, 88, 3, 88, 53, 3, 53, 88, 88, 45, 47, check_unedited works, check_unedited(package_path) is not FALSE\\n\\n, 93, 3, 93, 54, 3, 54, 93, 93, 45, 47, check_unedited works, check_unedited(package_path) is not TRUE\\n\\n, 97, 3, 97, 53, 3, 53, 97, 97, 45, 47, check_unedited works, check_unedited(package_path) is not FALSE\\n\\n, 102, 3, 102, 54, 3, 54, 102, 102, 45, 47, check_unedited works, check_unedited(package_path) is not TRUE\\n\\n, 105, 3, 105, 53, 3, 53, 105, 105, 45, 47, check_unedited works, check_unedited(package_path) is not FALSE\\n\\n, 112, 3, 112, 54, 3, 54, 112, 112, 45, 47, check_unedited works, check_unedited(package_path) is not TRUE\\n\\n, 115, 3, 115, 53, 3, 53, 115, 115, 45, 47, check_unedited works, check_unedited(package_path) is not FALSE\\n\\n, 123, 3, 123, 54, 3, 54, 123, 123, 45, 47, check_unedited works, check_unedited(package_path) is not TRUE\\n\\n, 126, 3, 126, 53, 3, 53, 126, 126, 45, 47, check_unedited works, check_unedited(package_path) is not FALSE\\n\\n, 134, 3, 134, 54, 3, 54, 134, 134, 45, 47, check_unedited works, check_unedited(package_path) is not TRUE\\n\\n, 137, 3, 137, 53, 3, 53, 137, 137, 45, 47, check_unedited works ## 5 `default_params` (`actual`) not equal to rmarkdown::yaml_front_matter(rmd_file)$params (`expected`).\\n\\n, 150, 3, 153, 3, 3, 3, 150, 153, 45, 47, get_params_used works, get_params_used(rmd_file, passed_params = list(package_parent_dir = &quot;dir&quot;)) (`actual`) not equal to `params1` (`expected`).\\n\\n, 156, 3, 159, 3, 3, 3, 156, 159, 45, 47, get_params_used works, get_params_used(...) (`actual`) not equal to `params2` (`expected`).\\n\\n, 163, 3, 168, 3, 3, 3, 163, 168, 45, 47, get_params_used works ## 6 fs::file_exists(file.path(dir, &quot;create-rknuth.html&quot;)) is not TRUE\\n\\n, 179, 3, 179, 78, 3, 78, 179, 179, 45, 47, Knuth-style references work ## 7 readLines(html_file_a) (`actual`) not equal to readLines(html_file) (`expected`).\\n\\n, 204, 5, 204, 72, 5, 72, 204, 204, 45, 48, Rendering in all possible ways works, readLines(file.path(pkg, &quot;DESCRIPTION&quot;)) (`actual`) not equal to readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;)) (`expected`).\\n\\n, 206, 5, 207, 70, 5, 70, 206, 207, 45, 48, Rendering in all possible ways works, readLines(html_file_a) (`actual`) not equal to readLines(html_file) (`expected`).\\n\\n, 204, 5, 204, 72, 5, 72, 204, 204, 45, 48, Rendering in all possible ways works, readLines(file.path(pkg, &quot;DESCRIPTION&quot;)) (`actual`) not equal to readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;)) (`expected`).\\n\\n, 206, 5, 207, 70, 5, 70, 206, 207, 45, 48, Rendering in all possible ways works, readLines(html_file_a) (`actual`) not equal to readLines(html_file) (`expected`).\\n\\n, 204, 5, 204, 72, 5, 72, 204, 204, 45, 48, Rendering in all possible ways works, readLines(file.path(pkg, &quot;DESCRIPTION&quot;)) (`actual`) not equal to readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;)) (`expected`).\\n\\n, 206, 5, 207, 70, 5, 70, 206, 207, 45, 48, Rendering in all possible ways works, readLines(html_file_a) (`actual`) not equal to readLines(html_file) (`expected`).\\n\\n, 204, 5, 204, 72, 5, 72, 204, 204, 45, 48, Rendering in all possible ways works, readLines(file.path(pkg, &quot;DESCRIPTION&quot;)) (`actual`) not equal to readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;)) (`expected`).\\n\\n, 206, 5, 207, 70, 5, 70, 206, 207, 45, 48, Rendering in all possible ways works, readLines(html_file_a) (`actual`) not equal to readLines(html_file) (`expected`).\\n\\n, 204, 5, 204, 72, 5, 72, 204, 204, 45, 48, Rendering in all possible ways works, readLines(file.path(pkg, &quot;DESCRIPTION&quot;)) (`actual`) not equal to readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;)) (`expected`).\\n\\n, 206, 5, 207, 70, 5, 70, 206, 207, 45, 48, Rendering in all possible ways works, readLines(html_file_a) (`actual`) not equal to readLines(html_file) (`expected`).\\n\\n, 204, 5, 204, 72, 5, 72, 204, 204, 45, 48, Rendering in all possible ways works, readLines(file.path(pkg, &quot;DESCRIPTION&quot;)) (`actual`) not equal to readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;)) (`expected`).\\n\\n, 206, 5, 207, 70, 5, 70, 206, 207, 45, 48, Rendering in all possible ways works ## 8 readLines(file.path(pkg, &quot;DESCRIPTION&quot;)) (`actual`) not equal to readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;)) (`expected`).\\n\\n, 291, 3, 292, 68, 3, 68, 291, 292, 45, 47, Rendering with minimal_eval=TRUE works, readLines(file.path(pkg, &quot;DESCRIPTION&quot;)) (`actual`) not equal to readLines(file.path(pkg_a, &quot;DESCRIPTION&quot;)) (`expected`).\\n\\n, 299, 3, 300, 68, 3, 68, 299, 300, 45, 47, Rendering with minimal_eval=TRUE works ## 9 fs::file_exists(file.path(dir, &quot;create-rhello.html&quot;)) is not TRUE\\n\\n, 316, 3, 316, 78, 3, 78, 316, 316, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;rhello&quot;)) is not TRUE\\n\\n, 317, 3, 317, 66, 3, 66, 317, 317, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;create-rhasdata.html&quot;)) is not TRUE\\n\\n, 325, 3, 325, 80, 3, 80, 325, 325, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;rhasdata&quot;)) is not TRUE\\n\\n, 326, 3, 326, 68, 3, 68, 326, 326, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;create-withrcpp.html&quot;)) is not TRUE\\n\\n, 334, 3, 334, 80, 3, 80, 334, 334, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;withrcpp&quot;)) is not TRUE\\n\\n, 335, 3, 335, 68, 3, 68, 335, 335, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;create-witharmadillo.Rmd&quot;)) is not TRUE\\n\\n, 343, 3, 343, 84, 3, 84, 343, 343, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;witharmadillo&quot;)) is not TRUE\\n\\n, 344, 3, 344, 73, 3, 73, 344, 344, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;create-withpkgdown.html&quot;)) is not TRUE\\n\\n, 352, 3, 352, 83, 3, 83, 352, 352, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;withpkgdown&quot;)) is not TRUE\\n\\n, 353, 3, 353, 71, 3, 71, 353, 353, 45, 47, templates can be knit, fs::file_exists(...) is not TRUE\\n\\n, 365, 3, 367, 5, 3, 5, 365, 367, 45, 47, templates can be knit, fs::file_exists(file.path(dir, &quot;create-frombookdown&quot;, &quot;frombookdown&quot;)) is not TRUE\\n\\n, 368, 3, 370, 5, 3, 5, 368, 370, 45, 47, templates can be knit 11.1 Add examples folder with the output of knitting each example In this section, we will litr-knit each template and put the outputs in an examples directory that lives outside of the litr R package. These examples are linked to in README.Rmd. build_all_templates &lt;- function(install_old, location_of_new) { devtools::install(location_of_new) example_dir &lt;- file.path(&quot;..&quot;, &quot;examples&quot;) if (fs::dir_exists(example_dir)) fs::dir_delete(example_dir) fs::dir_create(example_dir) templates &lt;- fs::path_file(fs::dir_ls(&quot;inst/rmarkdown/templates&quot;)) templates_bookdown &lt;- stringr::str_subset(templates, &quot;bookdown&quot;) templates_nonbookdown &lt;- setdiff(templates, templates_bookdown) for (template in templates_nonbookdown) { tmp_file &lt;- file.path(example_dir, &quot;temp.Rmd&quot;) rmarkdown::draft(tmp_file, template, package = &quot;litr&quot;, edit = FALSE) pkg_name &lt;- rmarkdown::yaml_front_matter(tmp_file)$params$package_name rmd_file &lt;- file.path(example_dir, paste0(&quot;create-&quot;, pkg_name, &quot;.Rmd&quot;)) fs::file_move(tmp_file, rmd_file) render(rmd_file) # move to a template-specific directory: template_dir &lt;- file.path(example_dir, template) fs::dir_create(template_dir) fs::file_move(fs::dir_ls(example_dir, regexp = pkg_name), template_dir) # move the source-files directory if (fs::dir_exists(file.path(example_dir, &quot;source-files&quot;))) { fs::dir_create(file.path(example_dir, template, &quot;source-files&quot;)) fs::dir_copy(file.path(example_dir, &quot;source-files&quot;), file.path(example_dir, template)) fs::dir_delete(file.path(example_dir, &quot;source-files&quot;)) } # move the docs directory (when pkgdown creates one) if (fs::dir_exists(file.path(example_dir, &quot;docs&quot;))) { fs::dir_create(file.path(example_dir, template, &quot;docs&quot;)) fs::dir_copy(file.path(example_dir, &quot;docs&quot;), file.path(example_dir, template)) fs::dir_delete(file.path(example_dir, &quot;docs&quot;)) } } for (template in templates_bookdown) { tmp_dir &lt;- file.path(example_dir, &quot;temp&quot;) rmarkdown::draft(file.path(example_dir, &quot;temp.Rmd&quot;), template, package = &quot;litr&quot;, edit = FALSE) prev_dir &lt;- getwd() setwd(tmp_dir) fs::file_delete(&quot;temp.Rmd&quot;) render(&quot;index.Rmd&quot;) # move to a template-specific directory: setwd(prev_dir) fs::dir_copy(tmp_dir, file.path(example_dir, template)) fs::dir_delete(tmp_dir) } install_old() } xfun::Rscript_call(build_all_templates, list(install_old = install_old, location_of_new = &quot;.&quot;)) ## [1] &quot;litr&quot; "],["including-extras-for-litr.html", "12 Including extras for litr 12.1 README with hex sticker 12.2 Vignettes 12.3 A pkgdown site", " 12 Including extras for litr 12.1 README with hex sticker We include a README.Rmd and then generate the README.md based on it: add_readme(file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;README.Rmd&quot;)) ## ✔ Writing &#39;README.Rmd&#39; ## ✔ Adding &#39;^README\\\\.Rmd$&#39; to &#39;.Rbuildignore&#39; ## ✔ Creating &#39;.git/hooks/&#39; ## ✔ Writing &#39;.git/hooks/pre-commit&#39; Let’s add the litr hex sticker too (which is referred to in the README). add_hex_sticker(file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;litr-hex.png&quot;)) Let’s also add a figure we include in the README. fs::file_copy(file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;diagram3.png&quot;), file.path(&quot;man&quot;, &quot;figures&quot;)) 12.2 Vignettes add_vignettes(c(file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;package-templates.Rmd&quot;), file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;packages-in-the-wild.Rmd&quot;), file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;faqs.Rmd&quot;), file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;basic-example.Rmd&quot;), file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;videos.Rmd&quot;))) The templates vignette uses dplyr and stringr, so we add them as “Suggests” in the DESCRIPTION file: usethis::use_package(&quot;dplyr&quot;, type = &quot;Suggests&quot;) ## ✔ Adding &#39;dplyr&#39; to Suggests field in DESCRIPTION ## • Use `requireNamespace(&quot;dplyr&quot;, quietly = TRUE)` to test if package is installed ## • Then directly refer to functions with `dplyr::fun()` usethis::use_package(&quot;stringr&quot;, type = &quot;Suggests&quot;) ## Warning: Package &#39;stringr&#39; is already listed in &#39;Imports&#39; in DESCRIPTION, no ## change made. 12.3 A pkgdown site We’ll first add the github url to the DESCRIPTION file. desc::desc_set(&quot;URL&quot;, &quot;https://github.com/jacobbien/litr-project/tree/main/litr&quot;) ## Package: litr ## Title: Literate Programming for Writing R Packages ## Version: 0.9.2 ## Authors@R (parsed): ## * Jacob Bien &lt;jbien@usc.edu&gt; [aut, cre] ## * Patrick Vossler [aut] ## Description: Allows one to fully create an R package in a single .Rmd ## file. Includes functionality and .Rmd templates for a literate ## programming approach to R package development. ## License: MIT + file LICENSE ## URL: https://github.com/jacobbien/litr-project/tree/main/litr ## Imports: ## bookdown, ## desc, ## devtools, ## digest, ## fansi, ## fs, ## knitr, ## pkgdown, ## rmarkdown, ## stringr, ## usethis, ## xfun, ## xml2, ## yaml ## Suggests: ## dplyr, ## Rcpp, ## testthat (&gt;= 3.0.0) ## VignetteBuilder: ## knitr ## Config/testthat/edition: 3 ## Encoding: UTF-8 ## Roxygen: list(markdown = TRUE) ## RoxygenNote: 7.3.1 Next, we create the pkgdown site. The customizations come from the source file source-files/_pkgdown.yml. pkgdown_yml &lt;- file.path(&quot;..&quot;, &quot;source-files&quot;, &quot;_pkgdown.yml&quot;) add_pkgdown(pkgdown_yml) ## ✔ Adding &#39;^_pkgdown\\\\.yml$&#39;, &#39;^docs$&#39;, &#39;^pkgdown$&#39; to &#39;.Rbuildignore&#39; ## ── Installing package litr into temporary library ────────────────────────────── ## ── Building pkgdown site for package litr ────────────────────────────────────── ## Reading from: /Users/jacobbien/Documents/GitHub/litr-project/litr ## Writing to: /Users/jacobbien/Documents/GitHub/litr-project/docs ## ── Initialising site ─────────────────────────────────────────────────────────── ## ── Building favicons ─────────────────────────────────────────────────────────── ## ℹ Building favicons with &lt;https://realfavicongenerator.net&gt; ... ## Copying pkgdown/favicon/apple-touch-icon-120x120.png, ## pkgdown/favicon/apple-touch-icon-152x152.png, ## pkgdown/favicon/apple-touch-icon-180x180.png, ## pkgdown/favicon/apple-touch-icon-60x60.png, ## pkgdown/favicon/apple-touch-icon-76x76.png, ## pkgdown/favicon/apple-touch-icon.png, pkgdown/favicon/favicon-16x16.png, and ## pkgdown/favicon/favicon-32x32.png ## to apple-touch-icon-120x120.png, apple-touch-icon-152x152.png, ## apple-touch-icon-180x180.png, apple-touch-icon-60x60.png, ## apple-touch-icon-76x76.png, apple-touch-icon.png, favicon-16x16.png, and ## favicon-32x32.png ## ── Building home ─────────────────────────────────────────────────────────────── ## Reading LICENSE.md ## Writing `404.html` ## ── Building function reference ───────────────────────────────────────────────── ## Reading man/add_chunk_label_hyperlinks.Rd ## Reading man/add_function_hyperlinks.Rd ## Reading man/add_hex_sticker.Rd ## Reading man/add_pkgdown.Rd ## Reading man/add_readme.Rd ## Reading man/add_text_to_file.Rd ## Reading man/add_vignettes.Rd ## Reading man/check_unedited.Rd ## Reading man/create_from_template.Rd ## Reading man/description_litr_hash_field_name.Rd ## Reading man/description_litr_version_field_name.Rd ## Reading man/do_not_edit_message.Rd ## Reading man/document.Rd ## Reading man/draft.Rd ## Reading man/draft_armadillo.Rd ## Reading man/draft_bookdown.Rd ## Reading man/draft_data.Rd ## Reading man/draft_extras.Rd ## Reading man/draft_rcpp.Rd ## Reading man/find_labels.Rd ## Reading man/get_package_directory.Rd ## Reading man/get_params_used.Rd ## Reading man/hash_package_directory.Rd ## Reading man/insert_hrefs.Rd ## Reading man/litr-package.Rd ## Reading man/litr_gitbook.Rd ## Reading man/litr_html_document.Rd ## Reading man/litr_pdf_document.Rd ## Reading man/litrify_output_format.Rd ## Reading man/load_all.Rd ## Reading man/make_noticeable.Rd ## Reading man/read_hash_from_description.Rd ## Reading man/remove_rstudio_extras.Rd ## Reading man/render.Rd ## Reading man/replace_ansi_sequences.Rd ## Reading man/restore_knitr_objects.Rd ## Reading man/send_to_package.Rd ## Reading man/setup.Rd ## Reading man/test_litr.Rd ## Reading man/with_cleanup.Rd ## Reading man/write_hash_to_description.Rd ## Reading man/write_version_to_description.Rd ## ── Building articles ─────────────────────────────────────────────────────────── ## Reading vignettes/basic-example.Rmd ## Reading vignettes/faqs.Rmd ## Reading vignettes/package-templates.Rmd ## Reading vignettes/packages-in-the-wild.Rmd ## Reading vignettes/videos.Rmd ## Writing sitemap.xml ## ── Building search index ─────────────────────────────────────────────────────── ## ── Finished building pkgdown site for package litr ───────────────────────────── ## ── Finished building pkgdown site for package litr ───────────────────────────── We follow this pkgdown vignette in our customizations. Here is the contents of the _pkgdown.yml that was used: cat(readLines(&quot;../source-files/_pkgdown.yml&quot;), sep = &#39;\\n&#39;) destination: ../docs/ url: ~ template: bootstrap: 5 bootswatch: cosmo repo: url: home: https://github.com/jacobbien/litr-project/tree/main/litr/ source: https://github.com/jacobbien/litr-project/tree/main/litr/ issue: https://github.com/jacobbien/litr-project/issues/ user: https://github.com/ authors: Jacob Bien: href: http://faculty.marshall.usc.edu/jacob-bien/ Patrick Vossler: href: https://www.patvoss.me/ navbar: structure: left: [reference, articles] right: [github] components: github: icon: fa-github href: https://github.com/jacobbien/litr-project/tree/main/litr/ reference: - title: Primary functions desc: &gt; These are the functions you&#39;ll use the most. contents: - draft - render - document - load_all - title: Working from template desc: &gt; These are functions for quickly creating different kinds of R packages. contents: - draft - draft_bookdown - draft_data - draft_rcpp - draft_extras - draft_armadillo - title: Functions for adding &quot;extras&quot; to your package desc: &gt; These functions can help you add a README, vignettes, a pkgdown site, and a hex sticker to your package. contents: - add_readme - add_vignettes - add_pkgdown - add_hex_sticker - title: Custom output formats desc: &gt; These are the functions for producing different output formats. contents: - litr_html_document - litr_pdf_document - litr_gitbook - litrify_output_format After this step, you can locally see the site by opening docs/index.html in the browser. You can then copy the docs directory to your website’s server and you’re done. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
